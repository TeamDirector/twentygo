// Package response provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

func (c *Client) DeleteManyAttachments(ctx context.Context, params *DeleteManyAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyAttachmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyAttachments(ctx context.Context, params *FindManyAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyAttachmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyAttachmentsWithBody(ctx context.Context, params *UpdateManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyAttachmentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyAttachments(ctx context.Context, params *UpdateManyAttachmentsParams, body UpdateManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyAttachmentsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneAttachmentWithBody(ctx context.Context, params *CreateOneAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneAttachmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneAttachment(ctx context.Context, params *CreateOneAttachmentParams, body CreateOneAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneAttachmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAttachmentDuplicatesWithBody(ctx context.Context, params *FindAttachmentDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAttachmentDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAttachmentDuplicates(ctx context.Context, params *FindAttachmentDuplicatesParams, body FindAttachmentDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAttachmentDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyAttachmentsWithBody(ctx context.Context, params *MergeManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyAttachmentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyAttachments(ctx context.Context, params *MergeManyAttachmentsParams, body MergeManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyAttachmentsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneAttachment(ctx context.Context, id IdPath, params *DeleteOneAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneAttachmentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneAttachment(ctx context.Context, id IdPath, params *FindOneAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneAttachmentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneAttachmentWithBody(ctx context.Context, id IdPath, params *UpdateOneAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneAttachmentRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneAttachment(ctx context.Context, id IdPath, params *UpdateOneAttachmentParams, body UpdateOneAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneAttachmentRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyAttachmentsWithBody(ctx context.Context, params *CreateManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyAttachmentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyAttachments(ctx context.Context, params *CreateManyAttachmentsParams, body CreateManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyAttachmentsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyBlocklistsWithBody(ctx context.Context, params *CreateManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyBlocklistsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyBlocklists(ctx context.Context, params *CreateManyBlocklistsParams, body CreateManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyBlocklistsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarChannelEventAssociationsWithBody(ctx context.Context, params *CreateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarChannelEventAssociationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarChannelEventAssociations(ctx context.Context, params *CreateManyCalendarChannelEventAssociationsParams, body CreateManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarChannelEventAssociationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarChannelsWithBody(ctx context.Context, params *CreateManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarChannels(ctx context.Context, params *CreateManyCalendarChannelsParams, body CreateManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarEventParticipantsWithBody(ctx context.Context, params *CreateManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarEventParticipantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarEventParticipants(ctx context.Context, params *CreateManyCalendarEventParticipantsParams, body CreateManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarEventParticipantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarEventsWithBody(ctx context.Context, params *CreateManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarEventsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCalendarEvents(ctx context.Context, params *CreateManyCalendarEventsParams, body CreateManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCalendarEventsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCompaniesWithBody(ctx context.Context, params *CreateManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCompaniesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyCompanies(ctx context.Context, params *CreateManyCompaniesParams, body CreateManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyCompaniesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyConnectedAccountsWithBody(ctx context.Context, params *CreateManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyConnectedAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyConnectedAccounts(ctx context.Context, params *CreateManyConnectedAccountsParams, body CreateManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyConnectedAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyDashboardsWithBody(ctx context.Context, params *CreateManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyDashboardsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyDashboards(ctx context.Context, params *CreateManyDashboardsParams, body CreateManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyDashboardsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyFavoriteFoldersWithBody(ctx context.Context, params *CreateManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyFavoriteFoldersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyFavoriteFolders(ctx context.Context, params *CreateManyFavoriteFoldersParams, body CreateManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyFavoriteFoldersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyFavoritesWithBody(ctx context.Context, params *CreateManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyFavoritesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyFavorites(ctx context.Context, params *CreateManyFavoritesParams, body CreateManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyFavoritesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageChannelMessageAssociationsWithBody(ctx context.Context, params *CreateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageChannelMessageAssociationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageChannelMessageAssociations(ctx context.Context, params *CreateManyMessageChannelMessageAssociationsParams, body CreateManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageChannelMessageAssociationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageChannelsWithBody(ctx context.Context, params *CreateManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageChannels(ctx context.Context, params *CreateManyMessageChannelsParams, body CreateManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageFoldersWithBody(ctx context.Context, params *CreateManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageFoldersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageFolders(ctx context.Context, params *CreateManyMessageFoldersParams, body CreateManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageFoldersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageParticipantsWithBody(ctx context.Context, params *CreateManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageParticipantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageParticipants(ctx context.Context, params *CreateManyMessageParticipantsParams, body CreateManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageParticipantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageThreadsWithBody(ctx context.Context, params *CreateManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageThreadsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessageThreads(ctx context.Context, params *CreateManyMessageThreadsParams, body CreateManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessageThreadsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessagesWithBody(ctx context.Context, params *CreateManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessagesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyMessages(ctx context.Context, params *CreateManyMessagesParams, body CreateManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyMessagesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyNoteTargetsWithBody(ctx context.Context, params *CreateManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyNoteTargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyNoteTargets(ctx context.Context, params *CreateManyNoteTargetsParams, body CreateManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyNoteTargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyNotesWithBody(ctx context.Context, params *CreateManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyNotesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyNotes(ctx context.Context, params *CreateManyNotesParams, body CreateManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyNotesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyOpportunitiesWithBody(ctx context.Context, params *CreateManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyOpportunitiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyOpportunities(ctx context.Context, params *CreateManyOpportunitiesParams, body CreateManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyOpportunitiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyPeopleWithBody(ctx context.Context, params *CreateManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyPeopleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyPeople(ctx context.Context, params *CreateManyPeopleParams, body CreateManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyPeopleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyTaskTargetsWithBody(ctx context.Context, params *CreateManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyTaskTargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyTaskTargets(ctx context.Context, params *CreateManyTaskTargetsParams, body CreateManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyTaskTargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyTasksWithBody(ctx context.Context, params *CreateManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyTasksRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyTasks(ctx context.Context, params *CreateManyTasksParams, body CreateManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyTasksRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyTimelineActivitiesWithBody(ctx context.Context, params *CreateManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyTimelineActivitiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyTimelineActivities(ctx context.Context, params *CreateManyTimelineActivitiesParams, body CreateManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyTimelineActivitiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflowAutomatedTriggersWithBody(ctx context.Context, params *CreateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowAutomatedTriggersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflowAutomatedTriggers(ctx context.Context, params *CreateManyWorkflowAutomatedTriggersParams, body CreateManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowAutomatedTriggersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflowRunsWithBody(ctx context.Context, params *CreateManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowRunsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflowRuns(ctx context.Context, params *CreateManyWorkflowRunsParams, body CreateManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowRunsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflowVersionsWithBody(ctx context.Context, params *CreateManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowVersionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflowVersions(ctx context.Context, params *CreateManyWorkflowVersionsParams, body CreateManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowVersionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflowsWithBody(ctx context.Context, params *CreateManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkflows(ctx context.Context, params *CreateManyWorkflowsParams, body CreateManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkflowsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkspaceMembersWithBody(ctx context.Context, params *CreateManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkspaceMembersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManyWorkspaceMembers(ctx context.Context, params *CreateManyWorkspaceMembersParams, body CreateManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManyWorkspaceMembersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyBlocklists(ctx context.Context, params *DeleteManyBlocklistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyBlocklistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyBlocklists(ctx context.Context, params *FindManyBlocklistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyBlocklistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyBlocklistsWithBody(ctx context.Context, params *UpdateManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyBlocklistsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyBlocklists(ctx context.Context, params *UpdateManyBlocklistsParams, body UpdateManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyBlocklistsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneBlocklistWithBody(ctx context.Context, params *CreateOneBlocklistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneBlocklistRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneBlocklist(ctx context.Context, params *CreateOneBlocklistParams, body CreateOneBlocklistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneBlocklistRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBlocklistDuplicatesWithBody(ctx context.Context, params *FindBlocklistDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBlocklistDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBlocklistDuplicates(ctx context.Context, params *FindBlocklistDuplicatesParams, body FindBlocklistDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBlocklistDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyBlocklistsWithBody(ctx context.Context, params *MergeManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyBlocklistsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyBlocklists(ctx context.Context, params *MergeManyBlocklistsParams, body MergeManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyBlocklistsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneBlocklist(ctx context.Context, id IdPath, params *DeleteOneBlocklistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneBlocklistRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneBlocklist(ctx context.Context, id IdPath, params *FindOneBlocklistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneBlocklistRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneBlocklistWithBody(ctx context.Context, id IdPath, params *UpdateOneBlocklistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneBlocklistRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneBlocklist(ctx context.Context, id IdPath, params *UpdateOneBlocklistParams, body UpdateOneBlocklistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneBlocklistRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyCalendarChannelEventAssociations(ctx context.Context, params *DeleteManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyCalendarChannelEventAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyCalendarChannelEventAssociations(ctx context.Context, params *FindManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyCalendarChannelEventAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarChannelEventAssociationsWithBody(ctx context.Context, params *UpdateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarChannelEventAssociationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarChannelEventAssociations(ctx context.Context, params *UpdateManyCalendarChannelEventAssociationsParams, body UpdateManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarChannelEventAssociationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarChannelEventAssociationWithBody(ctx context.Context, params *CreateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarChannelEventAssociationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarChannelEventAssociation(ctx context.Context, params *CreateOneCalendarChannelEventAssociationParams, body CreateOneCalendarChannelEventAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarChannelEventAssociationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarChannelEventAssociationDuplicatesWithBody(ctx context.Context, params *FindCalendarChannelEventAssociationDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarChannelEventAssociationDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarChannelEventAssociationDuplicates(ctx context.Context, params *FindCalendarChannelEventAssociationDuplicatesParams, body FindCalendarChannelEventAssociationDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarChannelEventAssociationDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarChannelEventAssociationsWithBody(ctx context.Context, params *MergeManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarChannelEventAssociationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarChannelEventAssociations(ctx context.Context, params *MergeManyCalendarChannelEventAssociationsParams, body MergeManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarChannelEventAssociationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneCalendarChannelEventAssociation(ctx context.Context, id IdPath, params *DeleteOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneCalendarChannelEventAssociationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneCalendarChannelEventAssociation(ctx context.Context, id IdPath, params *FindOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneCalendarChannelEventAssociationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarChannelEventAssociationWithBody(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarChannelEventAssociationRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarChannelEventAssociation(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, body UpdateOneCalendarChannelEventAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarChannelEventAssociationRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyCalendarChannels(ctx context.Context, params *DeleteManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyCalendarChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyCalendarChannels(ctx context.Context, params *FindManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyCalendarChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarChannelsWithBody(ctx context.Context, params *UpdateManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarChannels(ctx context.Context, params *UpdateManyCalendarChannelsParams, body UpdateManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarChannelWithBody(ctx context.Context, params *CreateOneCalendarChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarChannelRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarChannel(ctx context.Context, params *CreateOneCalendarChannelParams, body CreateOneCalendarChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarChannelRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarChannelDuplicatesWithBody(ctx context.Context, params *FindCalendarChannelDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarChannelDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarChannelDuplicates(ctx context.Context, params *FindCalendarChannelDuplicatesParams, body FindCalendarChannelDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarChannelDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarChannelsWithBody(ctx context.Context, params *MergeManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarChannels(ctx context.Context, params *MergeManyCalendarChannelsParams, body MergeManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneCalendarChannel(ctx context.Context, id IdPath, params *DeleteOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneCalendarChannelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneCalendarChannel(ctx context.Context, id IdPath, params *FindOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneCalendarChannelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarChannelWithBody(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarChannelRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarChannel(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelParams, body UpdateOneCalendarChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarChannelRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyCalendarEventParticipants(ctx context.Context, params *DeleteManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyCalendarEventParticipantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyCalendarEventParticipants(ctx context.Context, params *FindManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyCalendarEventParticipantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarEventParticipantsWithBody(ctx context.Context, params *UpdateManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarEventParticipantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarEventParticipants(ctx context.Context, params *UpdateManyCalendarEventParticipantsParams, body UpdateManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarEventParticipantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarEventParticipantWithBody(ctx context.Context, params *CreateOneCalendarEventParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarEventParticipantRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarEventParticipant(ctx context.Context, params *CreateOneCalendarEventParticipantParams, body CreateOneCalendarEventParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarEventParticipantRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarEventParticipantDuplicatesWithBody(ctx context.Context, params *FindCalendarEventParticipantDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarEventParticipantDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarEventParticipantDuplicates(ctx context.Context, params *FindCalendarEventParticipantDuplicatesParams, body FindCalendarEventParticipantDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarEventParticipantDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarEventParticipantsWithBody(ctx context.Context, params *MergeManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarEventParticipantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarEventParticipants(ctx context.Context, params *MergeManyCalendarEventParticipantsParams, body MergeManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarEventParticipantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneCalendarEventParticipant(ctx context.Context, id IdPath, params *DeleteOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneCalendarEventParticipantRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneCalendarEventParticipant(ctx context.Context, id IdPath, params *FindOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneCalendarEventParticipantRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarEventParticipantWithBody(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarEventParticipantRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarEventParticipant(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParticipantParams, body UpdateOneCalendarEventParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarEventParticipantRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyCalendarEvents(ctx context.Context, params *DeleteManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyCalendarEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyCalendarEvents(ctx context.Context, params *FindManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyCalendarEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarEventsWithBody(ctx context.Context, params *UpdateManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarEventsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCalendarEvents(ctx context.Context, params *UpdateManyCalendarEventsParams, body UpdateManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCalendarEventsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarEventWithBody(ctx context.Context, params *CreateOneCalendarEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarEventRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCalendarEvent(ctx context.Context, params *CreateOneCalendarEventParams, body CreateOneCalendarEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCalendarEventRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarEventDuplicatesWithBody(ctx context.Context, params *FindCalendarEventDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarEventDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCalendarEventDuplicates(ctx context.Context, params *FindCalendarEventDuplicatesParams, body FindCalendarEventDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCalendarEventDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarEventsWithBody(ctx context.Context, params *MergeManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarEventsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCalendarEvents(ctx context.Context, params *MergeManyCalendarEventsParams, body MergeManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCalendarEventsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneCalendarEvent(ctx context.Context, id IdPath, params *DeleteOneCalendarEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneCalendarEventRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneCalendarEvent(ctx context.Context, id IdPath, params *FindOneCalendarEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneCalendarEventRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarEventWithBody(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarEventRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCalendarEvent(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParams, body UpdateOneCalendarEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCalendarEventRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyCompanies(ctx context.Context, params *DeleteManyCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyCompaniesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyCompanies(ctx context.Context, params *FindManyCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyCompaniesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCompaniesWithBody(ctx context.Context, params *UpdateManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCompaniesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyCompanies(ctx context.Context, params *UpdateManyCompaniesParams, body UpdateManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyCompaniesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCompanyWithBody(ctx context.Context, params *CreateOneCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCompanyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneCompany(ctx context.Context, params *CreateOneCompanyParams, body CreateOneCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneCompanyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCompanyDuplicatesWithBody(ctx context.Context, params *FindCompanyDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCompanyDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCompanyDuplicates(ctx context.Context, params *FindCompanyDuplicatesParams, body FindCompanyDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCompanyDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCompaniesWithBody(ctx context.Context, params *MergeManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCompaniesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyCompanies(ctx context.Context, params *MergeManyCompaniesParams, body MergeManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyCompaniesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneCompany(ctx context.Context, id IdPath, params *DeleteOneCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneCompanyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneCompany(ctx context.Context, id IdPath, params *FindOneCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneCompanyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCompanyWithBody(ctx context.Context, id IdPath, params *UpdateOneCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCompanyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneCompany(ctx context.Context, id IdPath, params *UpdateOneCompanyParams, body UpdateOneCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneCompanyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyConnectedAccounts(ctx context.Context, params *DeleteManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyConnectedAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyConnectedAccounts(ctx context.Context, params *FindManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyConnectedAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyConnectedAccountsWithBody(ctx context.Context, params *UpdateManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyConnectedAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyConnectedAccounts(ctx context.Context, params *UpdateManyConnectedAccountsParams, body UpdateManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyConnectedAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneConnectedAccountWithBody(ctx context.Context, params *CreateOneConnectedAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneConnectedAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneConnectedAccount(ctx context.Context, params *CreateOneConnectedAccountParams, body CreateOneConnectedAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneConnectedAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindConnectedAccountDuplicatesWithBody(ctx context.Context, params *FindConnectedAccountDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindConnectedAccountDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindConnectedAccountDuplicates(ctx context.Context, params *FindConnectedAccountDuplicatesParams, body FindConnectedAccountDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindConnectedAccountDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyConnectedAccountsWithBody(ctx context.Context, params *MergeManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyConnectedAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyConnectedAccounts(ctx context.Context, params *MergeManyConnectedAccountsParams, body MergeManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyConnectedAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneConnectedAccount(ctx context.Context, id IdPath, params *DeleteOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneConnectedAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneConnectedAccount(ctx context.Context, id IdPath, params *FindOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneConnectedAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneConnectedAccountWithBody(ctx context.Context, id IdPath, params *UpdateOneConnectedAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneConnectedAccountRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneConnectedAccount(ctx context.Context, id IdPath, params *UpdateOneConnectedAccountParams, body UpdateOneConnectedAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneConnectedAccountRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyDashboards(ctx context.Context, params *DeleteManyDashboardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyDashboardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyDashboards(ctx context.Context, params *FindManyDashboardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyDashboardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyDashboardsWithBody(ctx context.Context, params *UpdateManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyDashboardsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyDashboards(ctx context.Context, params *UpdateManyDashboardsParams, body UpdateManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyDashboardsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneDashboardWithBody(ctx context.Context, params *CreateOneDashboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneDashboardRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneDashboard(ctx context.Context, params *CreateOneDashboardParams, body CreateOneDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneDashboardRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDashboardDuplicatesWithBody(ctx context.Context, params *FindDashboardDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDashboardDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDashboardDuplicates(ctx context.Context, params *FindDashboardDuplicatesParams, body FindDashboardDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDashboardDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyDashboardsWithBody(ctx context.Context, params *MergeManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyDashboardsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyDashboards(ctx context.Context, params *MergeManyDashboardsParams, body MergeManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyDashboardsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneDashboard(ctx context.Context, id IdPath, params *DeleteOneDashboardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneDashboardRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneDashboard(ctx context.Context, id IdPath, params *FindOneDashboardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneDashboardRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneDashboardWithBody(ctx context.Context, id IdPath, params *UpdateOneDashboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneDashboardRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneDashboard(ctx context.Context, id IdPath, params *UpdateOneDashboardParams, body UpdateOneDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneDashboardRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuplicateDashboard(ctx context.Context, id IdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuplicateDashboardRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyFavoriteFolders(ctx context.Context, params *DeleteManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyFavoriteFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyFavoriteFolders(ctx context.Context, params *FindManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyFavoriteFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyFavoriteFoldersWithBody(ctx context.Context, params *UpdateManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyFavoriteFoldersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyFavoriteFolders(ctx context.Context, params *UpdateManyFavoriteFoldersParams, body UpdateManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyFavoriteFoldersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneFavoriteFolderWithBody(ctx context.Context, params *CreateOneFavoriteFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneFavoriteFolderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneFavoriteFolder(ctx context.Context, params *CreateOneFavoriteFolderParams, body CreateOneFavoriteFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneFavoriteFolderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindFavoriteFolderDuplicatesWithBody(ctx context.Context, params *FindFavoriteFolderDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindFavoriteFolderDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindFavoriteFolderDuplicates(ctx context.Context, params *FindFavoriteFolderDuplicatesParams, body FindFavoriteFolderDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindFavoriteFolderDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyFavoriteFoldersWithBody(ctx context.Context, params *MergeManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyFavoriteFoldersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyFavoriteFolders(ctx context.Context, params *MergeManyFavoriteFoldersParams, body MergeManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyFavoriteFoldersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneFavoriteFolder(ctx context.Context, id IdPath, params *DeleteOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneFavoriteFolderRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneFavoriteFolder(ctx context.Context, id IdPath, params *FindOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneFavoriteFolderRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneFavoriteFolderWithBody(ctx context.Context, id IdPath, params *UpdateOneFavoriteFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneFavoriteFolderRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneFavoriteFolder(ctx context.Context, id IdPath, params *UpdateOneFavoriteFolderParams, body UpdateOneFavoriteFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneFavoriteFolderRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyFavorites(ctx context.Context, params *DeleteManyFavoritesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyFavoritesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyFavorites(ctx context.Context, params *FindManyFavoritesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyFavoritesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyFavoritesWithBody(ctx context.Context, params *UpdateManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyFavoritesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyFavorites(ctx context.Context, params *UpdateManyFavoritesParams, body UpdateManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyFavoritesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneFavoriteWithBody(ctx context.Context, params *CreateOneFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneFavoriteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneFavorite(ctx context.Context, params *CreateOneFavoriteParams, body CreateOneFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneFavoriteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindFavoriteDuplicatesWithBody(ctx context.Context, params *FindFavoriteDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindFavoriteDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindFavoriteDuplicates(ctx context.Context, params *FindFavoriteDuplicatesParams, body FindFavoriteDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindFavoriteDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyFavoritesWithBody(ctx context.Context, params *MergeManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyFavoritesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyFavorites(ctx context.Context, params *MergeManyFavoritesParams, body MergeManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyFavoritesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneFavorite(ctx context.Context, id IdPath, params *DeleteOneFavoriteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneFavoriteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneFavorite(ctx context.Context, id IdPath, params *FindOneFavoriteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneFavoriteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneFavoriteWithBody(ctx context.Context, id IdPath, params *UpdateOneFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneFavoriteRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneFavorite(ctx context.Context, id IdPath, params *UpdateOneFavoriteParams, body UpdateOneFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneFavoriteRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyMessageChannelMessageAssociations(ctx context.Context, params *DeleteManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyMessageChannelMessageAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyMessageChannelMessageAssociations(ctx context.Context, params *FindManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyMessageChannelMessageAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageChannelMessageAssociationsWithBody(ctx context.Context, params *UpdateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageChannelMessageAssociationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageChannelMessageAssociations(ctx context.Context, params *UpdateManyMessageChannelMessageAssociationsParams, body UpdateManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageChannelMessageAssociationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageChannelMessageAssociationWithBody(ctx context.Context, params *CreateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageChannelMessageAssociationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageChannelMessageAssociation(ctx context.Context, params *CreateOneMessageChannelMessageAssociationParams, body CreateOneMessageChannelMessageAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageChannelMessageAssociationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageChannelMessageAssociationDuplicatesWithBody(ctx context.Context, params *FindMessageChannelMessageAssociationDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageChannelMessageAssociationDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageChannelMessageAssociationDuplicates(ctx context.Context, params *FindMessageChannelMessageAssociationDuplicatesParams, body FindMessageChannelMessageAssociationDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageChannelMessageAssociationDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageChannelMessageAssociationsWithBody(ctx context.Context, params *MergeManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageChannelMessageAssociationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageChannelMessageAssociations(ctx context.Context, params *MergeManyMessageChannelMessageAssociationsParams, body MergeManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageChannelMessageAssociationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneMessageChannelMessageAssociation(ctx context.Context, id IdPath, params *DeleteOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneMessageChannelMessageAssociationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneMessageChannelMessageAssociation(ctx context.Context, id IdPath, params *FindOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneMessageChannelMessageAssociationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageChannelMessageAssociationWithBody(ctx context.Context, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageChannelMessageAssociationRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageChannelMessageAssociation(ctx context.Context, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, body UpdateOneMessageChannelMessageAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageChannelMessageAssociationRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyMessageChannels(ctx context.Context, params *DeleteManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyMessageChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyMessageChannels(ctx context.Context, params *FindManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyMessageChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageChannelsWithBody(ctx context.Context, params *UpdateManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageChannels(ctx context.Context, params *UpdateManyMessageChannelsParams, body UpdateManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageChannelWithBody(ctx context.Context, params *CreateOneMessageChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageChannelRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageChannel(ctx context.Context, params *CreateOneMessageChannelParams, body CreateOneMessageChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageChannelRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageChannelDuplicatesWithBody(ctx context.Context, params *FindMessageChannelDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageChannelDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageChannelDuplicates(ctx context.Context, params *FindMessageChannelDuplicatesParams, body FindMessageChannelDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageChannelDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageChannelsWithBody(ctx context.Context, params *MergeManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageChannels(ctx context.Context, params *MergeManyMessageChannelsParams, body MergeManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneMessageChannel(ctx context.Context, id IdPath, params *DeleteOneMessageChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneMessageChannelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneMessageChannel(ctx context.Context, id IdPath, params *FindOneMessageChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneMessageChannelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageChannelWithBody(ctx context.Context, id IdPath, params *UpdateOneMessageChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageChannelRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageChannel(ctx context.Context, id IdPath, params *UpdateOneMessageChannelParams, body UpdateOneMessageChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageChannelRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyMessageFolders(ctx context.Context, params *DeleteManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyMessageFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyMessageFolders(ctx context.Context, params *FindManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyMessageFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageFoldersWithBody(ctx context.Context, params *UpdateManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageFoldersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageFolders(ctx context.Context, params *UpdateManyMessageFoldersParams, body UpdateManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageFoldersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageFolderWithBody(ctx context.Context, params *CreateOneMessageFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageFolderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageFolder(ctx context.Context, params *CreateOneMessageFolderParams, body CreateOneMessageFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageFolderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageFolderDuplicatesWithBody(ctx context.Context, params *FindMessageFolderDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageFolderDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageFolderDuplicates(ctx context.Context, params *FindMessageFolderDuplicatesParams, body FindMessageFolderDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageFolderDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageFoldersWithBody(ctx context.Context, params *MergeManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageFoldersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageFolders(ctx context.Context, params *MergeManyMessageFoldersParams, body MergeManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageFoldersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneMessageFolder(ctx context.Context, id IdPath, params *DeleteOneMessageFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneMessageFolderRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneMessageFolder(ctx context.Context, id IdPath, params *FindOneMessageFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneMessageFolderRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageFolderWithBody(ctx context.Context, id IdPath, params *UpdateOneMessageFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageFolderRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageFolder(ctx context.Context, id IdPath, params *UpdateOneMessageFolderParams, body UpdateOneMessageFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageFolderRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyMessageParticipants(ctx context.Context, params *DeleteManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyMessageParticipantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyMessageParticipants(ctx context.Context, params *FindManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyMessageParticipantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageParticipantsWithBody(ctx context.Context, params *UpdateManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageParticipantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageParticipants(ctx context.Context, params *UpdateManyMessageParticipantsParams, body UpdateManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageParticipantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageParticipantWithBody(ctx context.Context, params *CreateOneMessageParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageParticipantRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageParticipant(ctx context.Context, params *CreateOneMessageParticipantParams, body CreateOneMessageParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageParticipantRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageParticipantDuplicatesWithBody(ctx context.Context, params *FindMessageParticipantDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageParticipantDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageParticipantDuplicates(ctx context.Context, params *FindMessageParticipantDuplicatesParams, body FindMessageParticipantDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageParticipantDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageParticipantsWithBody(ctx context.Context, params *MergeManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageParticipantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageParticipants(ctx context.Context, params *MergeManyMessageParticipantsParams, body MergeManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageParticipantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneMessageParticipant(ctx context.Context, id IdPath, params *DeleteOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneMessageParticipantRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneMessageParticipant(ctx context.Context, id IdPath, params *FindOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneMessageParticipantRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageParticipantWithBody(ctx context.Context, id IdPath, params *UpdateOneMessageParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageParticipantRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageParticipant(ctx context.Context, id IdPath, params *UpdateOneMessageParticipantParams, body UpdateOneMessageParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageParticipantRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyMessageThreads(ctx context.Context, params *DeleteManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyMessageThreadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyMessageThreads(ctx context.Context, params *FindManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyMessageThreadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageThreadsWithBody(ctx context.Context, params *UpdateManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageThreadsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessageThreads(ctx context.Context, params *UpdateManyMessageThreadsParams, body UpdateManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessageThreadsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageThreadWithBody(ctx context.Context, params *CreateOneMessageThreadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageThreadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageThread(ctx context.Context, params *CreateOneMessageThreadParams, body CreateOneMessageThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageThreadRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageThreadDuplicatesWithBody(ctx context.Context, params *FindMessageThreadDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageThreadDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageThreadDuplicates(ctx context.Context, params *FindMessageThreadDuplicatesParams, body FindMessageThreadDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageThreadDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageThreadsWithBody(ctx context.Context, params *MergeManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageThreadsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessageThreads(ctx context.Context, params *MergeManyMessageThreadsParams, body MergeManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessageThreadsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneMessageThread(ctx context.Context, id IdPath, params *DeleteOneMessageThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneMessageThreadRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneMessageThread(ctx context.Context, id IdPath, params *FindOneMessageThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneMessageThreadRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageThreadWithBody(ctx context.Context, id IdPath, params *UpdateOneMessageThreadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageThreadRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageThread(ctx context.Context, id IdPath, params *UpdateOneMessageThreadParams, body UpdateOneMessageThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageThreadRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyMessages(ctx context.Context, params *DeleteManyMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyMessages(ctx context.Context, params *FindManyMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessagesWithBody(ctx context.Context, params *UpdateManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessagesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyMessages(ctx context.Context, params *UpdateManyMessagesParams, body UpdateManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyMessagesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessageWithBody(ctx context.Context, params *CreateOneMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneMessage(ctx context.Context, params *CreateOneMessageParams, body CreateOneMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneMessageRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageDuplicatesWithBody(ctx context.Context, params *FindMessageDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMessageDuplicates(ctx context.Context, params *FindMessageDuplicatesParams, body FindMessageDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMessageDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessagesWithBody(ctx context.Context, params *MergeManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessagesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyMessages(ctx context.Context, params *MergeManyMessagesParams, body MergeManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyMessagesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneMessage(ctx context.Context, id IdPath, params *DeleteOneMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneMessageRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneMessage(ctx context.Context, id IdPath, params *FindOneMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneMessageRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessageWithBody(ctx context.Context, id IdPath, params *UpdateOneMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneMessage(ctx context.Context, id IdPath, params *UpdateOneMessageParams, body UpdateOneMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneMessageRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyNoteTargets(ctx context.Context, params *DeleteManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyNoteTargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyNoteTargets(ctx context.Context, params *FindManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyNoteTargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyNoteTargetsWithBody(ctx context.Context, params *UpdateManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyNoteTargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyNoteTargets(ctx context.Context, params *UpdateManyNoteTargetsParams, body UpdateManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyNoteTargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneNoteTargetWithBody(ctx context.Context, params *CreateOneNoteTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneNoteTargetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneNoteTarget(ctx context.Context, params *CreateOneNoteTargetParams, body CreateOneNoteTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneNoteTargetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindNoteTargetDuplicatesWithBody(ctx context.Context, params *FindNoteTargetDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindNoteTargetDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindNoteTargetDuplicates(ctx context.Context, params *FindNoteTargetDuplicatesParams, body FindNoteTargetDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindNoteTargetDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyNoteTargetsWithBody(ctx context.Context, params *MergeManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyNoteTargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyNoteTargets(ctx context.Context, params *MergeManyNoteTargetsParams, body MergeManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyNoteTargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneNoteTarget(ctx context.Context, id IdPath, params *DeleteOneNoteTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneNoteTargetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneNoteTarget(ctx context.Context, id IdPath, params *FindOneNoteTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneNoteTargetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneNoteTargetWithBody(ctx context.Context, id IdPath, params *UpdateOneNoteTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneNoteTargetRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneNoteTarget(ctx context.Context, id IdPath, params *UpdateOneNoteTargetParams, body UpdateOneNoteTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneNoteTargetRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyNotes(ctx context.Context, params *DeleteManyNotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyNotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyNotes(ctx context.Context, params *FindManyNotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyNotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyNotesWithBody(ctx context.Context, params *UpdateManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyNotesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyNotes(ctx context.Context, params *UpdateManyNotesParams, body UpdateManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyNotesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneNoteWithBody(ctx context.Context, params *CreateOneNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneNoteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneNote(ctx context.Context, params *CreateOneNoteParams, body CreateOneNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneNoteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindNoteDuplicatesWithBody(ctx context.Context, params *FindNoteDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindNoteDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindNoteDuplicates(ctx context.Context, params *FindNoteDuplicatesParams, body FindNoteDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindNoteDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyNotesWithBody(ctx context.Context, params *MergeManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyNotesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyNotes(ctx context.Context, params *MergeManyNotesParams, body MergeManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyNotesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneNote(ctx context.Context, id IdPath, params *DeleteOneNoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneNoteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneNote(ctx context.Context, id IdPath, params *FindOneNoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneNoteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneNoteWithBody(ctx context.Context, id IdPath, params *UpdateOneNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneNoteRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneNote(ctx context.Context, id IdPath, params *UpdateOneNoteParams, body UpdateOneNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneNoteRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenApiSchema(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenApiSchemaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyOpportunities(ctx context.Context, params *DeleteManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyOpportunitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyOpportunities(ctx context.Context, params *FindManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyOpportunitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyOpportunitiesWithBody(ctx context.Context, params *UpdateManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyOpportunitiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyOpportunities(ctx context.Context, params *UpdateManyOpportunitiesParams, body UpdateManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyOpportunitiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneOpportunityWithBody(ctx context.Context, params *CreateOneOpportunityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneOpportunityRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneOpportunity(ctx context.Context, params *CreateOneOpportunityParams, body CreateOneOpportunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneOpportunityRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOpportunityDuplicatesWithBody(ctx context.Context, params *FindOpportunityDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOpportunityDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOpportunityDuplicates(ctx context.Context, params *FindOpportunityDuplicatesParams, body FindOpportunityDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOpportunityDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyOpportunitiesWithBody(ctx context.Context, params *MergeManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyOpportunitiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyOpportunities(ctx context.Context, params *MergeManyOpportunitiesParams, body MergeManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyOpportunitiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneOpportunity(ctx context.Context, id IdPath, params *DeleteOneOpportunityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneOpportunityRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneOpportunity(ctx context.Context, id IdPath, params *FindOneOpportunityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneOpportunityRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneOpportunityWithBody(ctx context.Context, id IdPath, params *UpdateOneOpportunityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneOpportunityRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneOpportunity(ctx context.Context, id IdPath, params *UpdateOneOpportunityParams, body UpdateOneOpportunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneOpportunityRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyPeople(ctx context.Context, params *DeleteManyPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyPeople(ctx context.Context, params *FindManyPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyPeopleWithBody(ctx context.Context, params *UpdateManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyPeopleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyPeople(ctx context.Context, params *UpdateManyPeopleParams, body UpdateManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyPeopleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOnePersonWithBody(ctx context.Context, params *CreateOnePersonParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnePersonRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOnePerson(ctx context.Context, params *CreateOnePersonParams, body CreateOnePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnePersonRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPersonDuplicatesWithBody(ctx context.Context, params *FindPersonDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPersonDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPersonDuplicates(ctx context.Context, params *FindPersonDuplicatesParams, body FindPersonDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPersonDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyPeopleWithBody(ctx context.Context, params *MergeManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyPeopleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyPeople(ctx context.Context, params *MergeManyPeopleParams, body MergeManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyPeopleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOnePerson(ctx context.Context, id IdPath, params *DeleteOnePersonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOnePersonRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOnePerson(ctx context.Context, id IdPath, params *FindOnePersonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOnePersonRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOnePersonWithBody(ctx context.Context, id IdPath, params *UpdateOnePersonParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOnePersonRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOnePerson(ctx context.Context, id IdPath, params *UpdateOnePersonParams, body UpdateOnePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOnePersonRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyAttachments(ctx context.Context, params *RestoreManyAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyAttachmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneAttachment(ctx context.Context, id IdPath, params *RestoreOneAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneAttachmentRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyBlocklists(ctx context.Context, params *RestoreManyBlocklistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyBlocklistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneBlocklist(ctx context.Context, id IdPath, params *RestoreOneBlocklistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneBlocklistRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyCalendarChannelEventAssociations(ctx context.Context, params *RestoreManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyCalendarChannelEventAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneCalendarChannelEventAssociation(ctx context.Context, id IdPath, params *RestoreOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneCalendarChannelEventAssociationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyCalendarChannels(ctx context.Context, params *RestoreManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyCalendarChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneCalendarChannel(ctx context.Context, id IdPath, params *RestoreOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneCalendarChannelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyCalendarEventParticipants(ctx context.Context, params *RestoreManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyCalendarEventParticipantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneCalendarEventParticipant(ctx context.Context, id IdPath, params *RestoreOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneCalendarEventParticipantRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyCalendarEvents(ctx context.Context, params *RestoreManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyCalendarEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneCalendarEvent(ctx context.Context, id IdPath, params *RestoreOneCalendarEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneCalendarEventRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyCompanies(ctx context.Context, params *RestoreManyCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyCompaniesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneCompany(ctx context.Context, id IdPath, params *RestoreOneCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneCompanyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyConnectedAccounts(ctx context.Context, params *RestoreManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyConnectedAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneConnectedAccount(ctx context.Context, id IdPath, params *RestoreOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneConnectedAccountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyDashboards(ctx context.Context, params *RestoreManyDashboardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyDashboardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneDashboard(ctx context.Context, id IdPath, params *RestoreOneDashboardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneDashboardRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyFavoriteFolders(ctx context.Context, params *RestoreManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyFavoriteFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneFavoriteFolder(ctx context.Context, id IdPath, params *RestoreOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneFavoriteFolderRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyFavorites(ctx context.Context, params *RestoreManyFavoritesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyFavoritesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneFavorite(ctx context.Context, id IdPath, params *RestoreOneFavoriteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneFavoriteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyMessageChannelMessageAssociations(ctx context.Context, params *RestoreManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyMessageChannelMessageAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneMessageChannelMessageAssociation(ctx context.Context, id IdPath, params *RestoreOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneMessageChannelMessageAssociationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyMessageChannels(ctx context.Context, params *RestoreManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyMessageChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneMessageChannel(ctx context.Context, id IdPath, params *RestoreOneMessageChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneMessageChannelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyMessageFolders(ctx context.Context, params *RestoreManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyMessageFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneMessageFolder(ctx context.Context, id IdPath, params *RestoreOneMessageFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneMessageFolderRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyMessageParticipants(ctx context.Context, params *RestoreManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyMessageParticipantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneMessageParticipant(ctx context.Context, id IdPath, params *RestoreOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneMessageParticipantRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyMessageThreads(ctx context.Context, params *RestoreManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyMessageThreadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneMessageThread(ctx context.Context, id IdPath, params *RestoreOneMessageThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneMessageThreadRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyMessages(ctx context.Context, params *RestoreManyMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneMessage(ctx context.Context, id IdPath, params *RestoreOneMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneMessageRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyNoteTargets(ctx context.Context, params *RestoreManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyNoteTargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneNoteTarget(ctx context.Context, id IdPath, params *RestoreOneNoteTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneNoteTargetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyNotes(ctx context.Context, params *RestoreManyNotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyNotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneNote(ctx context.Context, id IdPath, params *RestoreOneNoteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneNoteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyOpportunities(ctx context.Context, params *RestoreManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyOpportunitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneOpportunity(ctx context.Context, id IdPath, params *RestoreOneOpportunityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneOpportunityRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyPeople(ctx context.Context, params *RestoreManyPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOnePerson(ctx context.Context, id IdPath, params *RestoreOnePersonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOnePersonRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyTaskTargets(ctx context.Context, params *RestoreManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyTaskTargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneTaskTarget(ctx context.Context, id IdPath, params *RestoreOneTaskTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneTaskTargetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyTasks(ctx context.Context, params *RestoreManyTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneTask(ctx context.Context, id IdPath, params *RestoreOneTaskParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneTaskRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyTimelineActivities(ctx context.Context, params *RestoreManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyTimelineActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneTimelineActivity(ctx context.Context, id IdPath, params *RestoreOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneTimelineActivityRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyWorkflowAutomatedTriggers(ctx context.Context, params *RestoreManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyWorkflowAutomatedTriggersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneWorkflowAutomatedTrigger(ctx context.Context, id IdPath, params *RestoreOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneWorkflowAutomatedTriggerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyWorkflowRuns(ctx context.Context, params *RestoreManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyWorkflowRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneWorkflowRun(ctx context.Context, id IdPath, params *RestoreOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneWorkflowRunRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyWorkflowVersions(ctx context.Context, params *RestoreManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyWorkflowVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneWorkflowVersion(ctx context.Context, id IdPath, params *RestoreOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneWorkflowVersionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyWorkflows(ctx context.Context, params *RestoreManyWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyWorkflowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneWorkflow(ctx context.Context, id IdPath, params *RestoreOneWorkflowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneWorkflowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreManyWorkspaceMembers(ctx context.Context, params *RestoreManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreManyWorkspaceMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreOneWorkspaceMember(ctx context.Context, id IdPath, params *RestoreOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreOneWorkspaceMemberRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyTaskTargets(ctx context.Context, params *DeleteManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyTaskTargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyTaskTargets(ctx context.Context, params *FindManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyTaskTargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyTaskTargetsWithBody(ctx context.Context, params *UpdateManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyTaskTargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyTaskTargets(ctx context.Context, params *UpdateManyTaskTargetsParams, body UpdateManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyTaskTargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneTaskTargetWithBody(ctx context.Context, params *CreateOneTaskTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneTaskTargetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneTaskTarget(ctx context.Context, params *CreateOneTaskTargetParams, body CreateOneTaskTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneTaskTargetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTaskTargetDuplicatesWithBody(ctx context.Context, params *FindTaskTargetDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTaskTargetDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTaskTargetDuplicates(ctx context.Context, params *FindTaskTargetDuplicatesParams, body FindTaskTargetDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTaskTargetDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyTaskTargetsWithBody(ctx context.Context, params *MergeManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyTaskTargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyTaskTargets(ctx context.Context, params *MergeManyTaskTargetsParams, body MergeManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyTaskTargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneTaskTarget(ctx context.Context, id IdPath, params *DeleteOneTaskTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneTaskTargetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneTaskTarget(ctx context.Context, id IdPath, params *FindOneTaskTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneTaskTargetRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneTaskTargetWithBody(ctx context.Context, id IdPath, params *UpdateOneTaskTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneTaskTargetRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneTaskTarget(ctx context.Context, id IdPath, params *UpdateOneTaskTargetParams, body UpdateOneTaskTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneTaskTargetRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyTasks(ctx context.Context, params *DeleteManyTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyTasks(ctx context.Context, params *FindManyTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyTasksWithBody(ctx context.Context, params *UpdateManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyTasksRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyTasks(ctx context.Context, params *UpdateManyTasksParams, body UpdateManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyTasksRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneTaskWithBody(ctx context.Context, params *CreateOneTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneTaskRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneTask(ctx context.Context, params *CreateOneTaskParams, body CreateOneTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneTaskRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTaskDuplicatesWithBody(ctx context.Context, params *FindTaskDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTaskDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTaskDuplicates(ctx context.Context, params *FindTaskDuplicatesParams, body FindTaskDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTaskDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyTasksWithBody(ctx context.Context, params *MergeManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyTasksRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyTasks(ctx context.Context, params *MergeManyTasksParams, body MergeManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyTasksRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneTask(ctx context.Context, id IdPath, params *DeleteOneTaskParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneTaskRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneTask(ctx context.Context, id IdPath, params *FindOneTaskParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneTaskRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneTaskWithBody(ctx context.Context, id IdPath, params *UpdateOneTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneTaskRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneTask(ctx context.Context, id IdPath, params *UpdateOneTaskParams, body UpdateOneTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneTaskRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyTimelineActivities(ctx context.Context, params *DeleteManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyTimelineActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyTimelineActivities(ctx context.Context, params *FindManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyTimelineActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyTimelineActivitiesWithBody(ctx context.Context, params *UpdateManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyTimelineActivitiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyTimelineActivities(ctx context.Context, params *UpdateManyTimelineActivitiesParams, body UpdateManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyTimelineActivitiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneTimelineActivityWithBody(ctx context.Context, params *CreateOneTimelineActivityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneTimelineActivityRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneTimelineActivity(ctx context.Context, params *CreateOneTimelineActivityParams, body CreateOneTimelineActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneTimelineActivityRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTimelineActivityDuplicatesWithBody(ctx context.Context, params *FindTimelineActivityDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTimelineActivityDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTimelineActivityDuplicates(ctx context.Context, params *FindTimelineActivityDuplicatesParams, body FindTimelineActivityDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTimelineActivityDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyTimelineActivitiesWithBody(ctx context.Context, params *MergeManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyTimelineActivitiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyTimelineActivities(ctx context.Context, params *MergeManyTimelineActivitiesParams, body MergeManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyTimelineActivitiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneTimelineActivity(ctx context.Context, id IdPath, params *DeleteOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneTimelineActivityRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneTimelineActivity(ctx context.Context, id IdPath, params *FindOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneTimelineActivityRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneTimelineActivityWithBody(ctx context.Context, id IdPath, params *UpdateOneTimelineActivityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneTimelineActivityRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneTimelineActivity(ctx context.Context, id IdPath, params *UpdateOneTimelineActivityParams, body UpdateOneTimelineActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneTimelineActivityRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyWorkflowAutomatedTriggers(ctx context.Context, params *DeleteManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyWorkflowAutomatedTriggersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyWorkflowAutomatedTriggers(ctx context.Context, params *FindManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyWorkflowAutomatedTriggersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflowAutomatedTriggersWithBody(ctx context.Context, params *UpdateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowAutomatedTriggersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflowAutomatedTriggers(ctx context.Context, params *UpdateManyWorkflowAutomatedTriggersParams, body UpdateManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowAutomatedTriggersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflowAutomatedTriggerWithBody(ctx context.Context, params *CreateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowAutomatedTriggerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflowAutomatedTrigger(ctx context.Context, params *CreateOneWorkflowAutomatedTriggerParams, body CreateOneWorkflowAutomatedTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowAutomatedTriggerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowAutomatedTriggerDuplicatesWithBody(ctx context.Context, params *FindWorkflowAutomatedTriggerDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowAutomatedTriggerDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowAutomatedTriggerDuplicates(ctx context.Context, params *FindWorkflowAutomatedTriggerDuplicatesParams, body FindWorkflowAutomatedTriggerDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowAutomatedTriggerDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflowAutomatedTriggersWithBody(ctx context.Context, params *MergeManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowAutomatedTriggersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflowAutomatedTriggers(ctx context.Context, params *MergeManyWorkflowAutomatedTriggersParams, body MergeManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowAutomatedTriggersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneWorkflowAutomatedTrigger(ctx context.Context, id IdPath, params *DeleteOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneWorkflowAutomatedTriggerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneWorkflowAutomatedTrigger(ctx context.Context, id IdPath, params *FindOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneWorkflowAutomatedTriggerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflowAutomatedTriggerWithBody(ctx context.Context, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowAutomatedTriggerRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflowAutomatedTrigger(ctx context.Context, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, body UpdateOneWorkflowAutomatedTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowAutomatedTriggerRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyWorkflowRuns(ctx context.Context, params *DeleteManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyWorkflowRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyWorkflowRuns(ctx context.Context, params *FindManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyWorkflowRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflowRunsWithBody(ctx context.Context, params *UpdateManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowRunsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflowRuns(ctx context.Context, params *UpdateManyWorkflowRunsParams, body UpdateManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowRunsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflowRunWithBody(ctx context.Context, params *CreateOneWorkflowRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowRunRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflowRun(ctx context.Context, params *CreateOneWorkflowRunParams, body CreateOneWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowRunRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowRunDuplicatesWithBody(ctx context.Context, params *FindWorkflowRunDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowRunDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowRunDuplicates(ctx context.Context, params *FindWorkflowRunDuplicatesParams, body FindWorkflowRunDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowRunDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflowRunsWithBody(ctx context.Context, params *MergeManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowRunsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflowRuns(ctx context.Context, params *MergeManyWorkflowRunsParams, body MergeManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowRunsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneWorkflowRun(ctx context.Context, id IdPath, params *DeleteOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneWorkflowRunRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneWorkflowRun(ctx context.Context, id IdPath, params *FindOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneWorkflowRunRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflowRunWithBody(ctx context.Context, id IdPath, params *UpdateOneWorkflowRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowRunRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflowRun(ctx context.Context, id IdPath, params *UpdateOneWorkflowRunParams, body UpdateOneWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowRunRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyWorkflowVersions(ctx context.Context, params *DeleteManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyWorkflowVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyWorkflowVersions(ctx context.Context, params *FindManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyWorkflowVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflowVersionsWithBody(ctx context.Context, params *UpdateManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowVersionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflowVersions(ctx context.Context, params *UpdateManyWorkflowVersionsParams, body UpdateManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowVersionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflowVersionWithBody(ctx context.Context, params *CreateOneWorkflowVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowVersionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflowVersion(ctx context.Context, params *CreateOneWorkflowVersionParams, body CreateOneWorkflowVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowVersionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowVersionDuplicatesWithBody(ctx context.Context, params *FindWorkflowVersionDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowVersionDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowVersionDuplicates(ctx context.Context, params *FindWorkflowVersionDuplicatesParams, body FindWorkflowVersionDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowVersionDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflowVersionsWithBody(ctx context.Context, params *MergeManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowVersionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflowVersions(ctx context.Context, params *MergeManyWorkflowVersionsParams, body MergeManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowVersionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneWorkflowVersion(ctx context.Context, id IdPath, params *DeleteOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneWorkflowVersionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneWorkflowVersion(ctx context.Context, id IdPath, params *FindOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneWorkflowVersionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflowVersionWithBody(ctx context.Context, id IdPath, params *UpdateOneWorkflowVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowVersionRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflowVersion(ctx context.Context, id IdPath, params *UpdateOneWorkflowVersionParams, body UpdateOneWorkflowVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowVersionRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyWorkflows(ctx context.Context, params *DeleteManyWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyWorkflowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyWorkflows(ctx context.Context, params *FindManyWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyWorkflowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflowsWithBody(ctx context.Context, params *UpdateManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkflows(ctx context.Context, params *UpdateManyWorkflowsParams, body UpdateManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkflowsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflowWithBody(ctx context.Context, params *CreateOneWorkflowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkflow(ctx context.Context, params *CreateOneWorkflowParams, body CreateOneWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkflowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowDuplicatesWithBody(ctx context.Context, params *FindWorkflowDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkflowDuplicates(ctx context.Context, params *FindWorkflowDuplicatesParams, body FindWorkflowDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkflowDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflowsWithBody(ctx context.Context, params *MergeManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkflows(ctx context.Context, params *MergeManyWorkflowsParams, body MergeManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkflowsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneWorkflow(ctx context.Context, id IdPath, params *DeleteOneWorkflowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneWorkflowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneWorkflow(ctx context.Context, id IdPath, params *FindOneWorkflowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneWorkflowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflowWithBody(ctx context.Context, id IdPath, params *UpdateOneWorkflowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkflow(ctx context.Context, id IdPath, params *UpdateOneWorkflowParams, body UpdateOneWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkflowRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManyWorkspaceMembers(ctx context.Context, params *DeleteManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManyWorkspaceMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManyWorkspaceMembers(ctx context.Context, params *FindManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManyWorkspaceMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkspaceMembersWithBody(ctx context.Context, params *UpdateManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkspaceMembersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManyWorkspaceMembers(ctx context.Context, params *UpdateManyWorkspaceMembersParams, body UpdateManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManyWorkspaceMembersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkspaceMemberWithBody(ctx context.Context, params *CreateOneWorkspaceMemberParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkspaceMemberRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOneWorkspaceMember(ctx context.Context, params *CreateOneWorkspaceMemberParams, body CreateOneWorkspaceMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOneWorkspaceMemberRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkspaceMemberDuplicatesWithBody(ctx context.Context, params *FindWorkspaceMemberDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkspaceMemberDuplicatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindWorkspaceMemberDuplicates(ctx context.Context, params *FindWorkspaceMemberDuplicatesParams, body FindWorkspaceMemberDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindWorkspaceMemberDuplicatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkspaceMembersWithBody(ctx context.Context, params *MergeManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkspaceMembersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeManyWorkspaceMembers(ctx context.Context, params *MergeManyWorkspaceMembersParams, body MergeManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeManyWorkspaceMembersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOneWorkspaceMember(ctx context.Context, id IdPath, params *DeleteOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOneWorkspaceMemberRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOneWorkspaceMember(ctx context.Context, id IdPath, params *FindOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOneWorkspaceMemberRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkspaceMemberWithBody(ctx context.Context, id IdPath, params *UpdateOneWorkspaceMemberParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkspaceMemberRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOneWorkspaceMember(ctx context.Context, id IdPath, params *UpdateOneWorkspaceMemberParams, body UpdateOneWorkspaceMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOneWorkspaceMemberRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteManyAttachmentsRequest generates requests for DeleteManyAttachments
func NewDeleteManyAttachmentsRequest(server string, params *DeleteManyAttachmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyAttachmentsRequest generates requests for FindManyAttachments
func NewFindManyAttachmentsRequest(server string, params *FindManyAttachmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyAttachmentsRequest calls the generic UpdateManyAttachments builder with application/json body
func NewUpdateManyAttachmentsRequest(server string, params *UpdateManyAttachmentsParams, body UpdateManyAttachmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyAttachmentsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyAttachmentsRequestWithBody generates requests for UpdateManyAttachments with any type of body
func NewUpdateManyAttachmentsRequestWithBody(server string, params *UpdateManyAttachmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneAttachmentRequest calls the generic CreateOneAttachment builder with application/json body
func NewCreateOneAttachmentRequest(server string, params *CreateOneAttachmentParams, body CreateOneAttachmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneAttachmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneAttachmentRequestWithBody generates requests for CreateOneAttachment with any type of body
func NewCreateOneAttachmentRequestWithBody(server string, params *CreateOneAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAttachmentDuplicatesRequest calls the generic FindAttachmentDuplicates builder with application/json body
func NewFindAttachmentDuplicatesRequest(server string, params *FindAttachmentDuplicatesParams, body FindAttachmentDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindAttachmentDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindAttachmentDuplicatesRequestWithBody generates requests for FindAttachmentDuplicates with any type of body
func NewFindAttachmentDuplicatesRequestWithBody(server string, params *FindAttachmentDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyAttachmentsRequest calls the generic MergeManyAttachments builder with application/json body
func NewMergeManyAttachmentsRequest(server string, params *MergeManyAttachmentsParams, body MergeManyAttachmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyAttachmentsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyAttachmentsRequestWithBody generates requests for MergeManyAttachments with any type of body
func NewMergeManyAttachmentsRequestWithBody(server string, params *MergeManyAttachmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneAttachmentRequest generates requests for DeleteOneAttachment
func NewDeleteOneAttachmentRequest(server string, id IdPath, params *DeleteOneAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneAttachmentRequest generates requests for FindOneAttachment
func NewFindOneAttachmentRequest(server string, id IdPath, params *FindOneAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneAttachmentRequest calls the generic UpdateOneAttachment builder with application/json body
func NewUpdateOneAttachmentRequest(server string, id IdPath, params *UpdateOneAttachmentParams, body UpdateOneAttachmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneAttachmentRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneAttachmentRequestWithBody generates requests for UpdateOneAttachment with any type of body
func NewUpdateOneAttachmentRequestWithBody(server string, id IdPath, params *UpdateOneAttachmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyAttachmentsRequest calls the generic CreateManyAttachments builder with application/json body
func NewCreateManyAttachmentsRequest(server string, params *CreateManyAttachmentsParams, body CreateManyAttachmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyAttachmentsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyAttachmentsRequestWithBody generates requests for CreateManyAttachments with any type of body
func NewCreateManyAttachmentsRequestWithBody(server string, params *CreateManyAttachmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyBlocklistsRequest calls the generic CreateManyBlocklists builder with application/json body
func NewCreateManyBlocklistsRequest(server string, params *CreateManyBlocklistsParams, body CreateManyBlocklistsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyBlocklistsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyBlocklistsRequestWithBody generates requests for CreateManyBlocklists with any type of body
func NewCreateManyBlocklistsRequestWithBody(server string, params *CreateManyBlocklistsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyCalendarChannelEventAssociationsRequest calls the generic CreateManyCalendarChannelEventAssociations builder with application/json body
func NewCreateManyCalendarChannelEventAssociationsRequest(server string, params *CreateManyCalendarChannelEventAssociationsParams, body CreateManyCalendarChannelEventAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyCalendarChannelEventAssociationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyCalendarChannelEventAssociationsRequestWithBody generates requests for CreateManyCalendarChannelEventAssociations with any type of body
func NewCreateManyCalendarChannelEventAssociationsRequestWithBody(server string, params *CreateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/calendarChannelEventAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyCalendarChannelsRequest calls the generic CreateManyCalendarChannels builder with application/json body
func NewCreateManyCalendarChannelsRequest(server string, params *CreateManyCalendarChannelsParams, body CreateManyCalendarChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyCalendarChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyCalendarChannelsRequestWithBody generates requests for CreateManyCalendarChannels with any type of body
func NewCreateManyCalendarChannelsRequestWithBody(server string, params *CreateManyCalendarChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/calendarChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyCalendarEventParticipantsRequest calls the generic CreateManyCalendarEventParticipants builder with application/json body
func NewCreateManyCalendarEventParticipantsRequest(server string, params *CreateManyCalendarEventParticipantsParams, body CreateManyCalendarEventParticipantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyCalendarEventParticipantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyCalendarEventParticipantsRequestWithBody generates requests for CreateManyCalendarEventParticipants with any type of body
func NewCreateManyCalendarEventParticipantsRequestWithBody(server string, params *CreateManyCalendarEventParticipantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/calendarEventParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyCalendarEventsRequest calls the generic CreateManyCalendarEvents builder with application/json body
func NewCreateManyCalendarEventsRequest(server string, params *CreateManyCalendarEventsParams, body CreateManyCalendarEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyCalendarEventsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyCalendarEventsRequestWithBody generates requests for CreateManyCalendarEvents with any type of body
func NewCreateManyCalendarEventsRequestWithBody(server string, params *CreateManyCalendarEventsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/calendarEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyCompaniesRequest calls the generic CreateManyCompanies builder with application/json body
func NewCreateManyCompaniesRequest(server string, params *CreateManyCompaniesParams, body CreateManyCompaniesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyCompaniesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyCompaniesRequestWithBody generates requests for CreateManyCompanies with any type of body
func NewCreateManyCompaniesRequestWithBody(server string, params *CreateManyCompaniesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyConnectedAccountsRequest calls the generic CreateManyConnectedAccounts builder with application/json body
func NewCreateManyConnectedAccountsRequest(server string, params *CreateManyConnectedAccountsParams, body CreateManyConnectedAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyConnectedAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyConnectedAccountsRequestWithBody generates requests for CreateManyConnectedAccounts with any type of body
func NewCreateManyConnectedAccountsRequestWithBody(server string, params *CreateManyConnectedAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/connectedAccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyDashboardsRequest calls the generic CreateManyDashboards builder with application/json body
func NewCreateManyDashboardsRequest(server string, params *CreateManyDashboardsParams, body CreateManyDashboardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyDashboardsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyDashboardsRequestWithBody generates requests for CreateManyDashboards with any type of body
func NewCreateManyDashboardsRequestWithBody(server string, params *CreateManyDashboardsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyFavoriteFoldersRequest calls the generic CreateManyFavoriteFolders builder with application/json body
func NewCreateManyFavoriteFoldersRequest(server string, params *CreateManyFavoriteFoldersParams, body CreateManyFavoriteFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyFavoriteFoldersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyFavoriteFoldersRequestWithBody generates requests for CreateManyFavoriteFolders with any type of body
func NewCreateManyFavoriteFoldersRequestWithBody(server string, params *CreateManyFavoriteFoldersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/favoriteFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyFavoritesRequest calls the generic CreateManyFavorites builder with application/json body
func NewCreateManyFavoritesRequest(server string, params *CreateManyFavoritesParams, body CreateManyFavoritesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyFavoritesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyFavoritesRequestWithBody generates requests for CreateManyFavorites with any type of body
func NewCreateManyFavoritesRequestWithBody(server string, params *CreateManyFavoritesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyMessageChannelMessageAssociationsRequest calls the generic CreateManyMessageChannelMessageAssociations builder with application/json body
func NewCreateManyMessageChannelMessageAssociationsRequest(server string, params *CreateManyMessageChannelMessageAssociationsParams, body CreateManyMessageChannelMessageAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyMessageChannelMessageAssociationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyMessageChannelMessageAssociationsRequestWithBody generates requests for CreateManyMessageChannelMessageAssociations with any type of body
func NewCreateManyMessageChannelMessageAssociationsRequestWithBody(server string, params *CreateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/messageChannelMessageAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyMessageChannelsRequest calls the generic CreateManyMessageChannels builder with application/json body
func NewCreateManyMessageChannelsRequest(server string, params *CreateManyMessageChannelsParams, body CreateManyMessageChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyMessageChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyMessageChannelsRequestWithBody generates requests for CreateManyMessageChannels with any type of body
func NewCreateManyMessageChannelsRequestWithBody(server string, params *CreateManyMessageChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/messageChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyMessageFoldersRequest calls the generic CreateManyMessageFolders builder with application/json body
func NewCreateManyMessageFoldersRequest(server string, params *CreateManyMessageFoldersParams, body CreateManyMessageFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyMessageFoldersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyMessageFoldersRequestWithBody generates requests for CreateManyMessageFolders with any type of body
func NewCreateManyMessageFoldersRequestWithBody(server string, params *CreateManyMessageFoldersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/messageFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyMessageParticipantsRequest calls the generic CreateManyMessageParticipants builder with application/json body
func NewCreateManyMessageParticipantsRequest(server string, params *CreateManyMessageParticipantsParams, body CreateManyMessageParticipantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyMessageParticipantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyMessageParticipantsRequestWithBody generates requests for CreateManyMessageParticipants with any type of body
func NewCreateManyMessageParticipantsRequestWithBody(server string, params *CreateManyMessageParticipantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/messageParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyMessageThreadsRequest calls the generic CreateManyMessageThreads builder with application/json body
func NewCreateManyMessageThreadsRequest(server string, params *CreateManyMessageThreadsParams, body CreateManyMessageThreadsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyMessageThreadsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyMessageThreadsRequestWithBody generates requests for CreateManyMessageThreads with any type of body
func NewCreateManyMessageThreadsRequestWithBody(server string, params *CreateManyMessageThreadsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/messageThreads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyMessagesRequest calls the generic CreateManyMessages builder with application/json body
func NewCreateManyMessagesRequest(server string, params *CreateManyMessagesParams, body CreateManyMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyMessagesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyMessagesRequestWithBody generates requests for CreateManyMessages with any type of body
func NewCreateManyMessagesRequestWithBody(server string, params *CreateManyMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyNoteTargetsRequest calls the generic CreateManyNoteTargets builder with application/json body
func NewCreateManyNoteTargetsRequest(server string, params *CreateManyNoteTargetsParams, body CreateManyNoteTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyNoteTargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyNoteTargetsRequestWithBody generates requests for CreateManyNoteTargets with any type of body
func NewCreateManyNoteTargetsRequestWithBody(server string, params *CreateManyNoteTargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/noteTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyNotesRequest calls the generic CreateManyNotes builder with application/json body
func NewCreateManyNotesRequest(server string, params *CreateManyNotesParams, body CreateManyNotesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyNotesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyNotesRequestWithBody generates requests for CreateManyNotes with any type of body
func NewCreateManyNotesRequestWithBody(server string, params *CreateManyNotesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyOpportunitiesRequest calls the generic CreateManyOpportunities builder with application/json body
func NewCreateManyOpportunitiesRequest(server string, params *CreateManyOpportunitiesParams, body CreateManyOpportunitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyOpportunitiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyOpportunitiesRequestWithBody generates requests for CreateManyOpportunities with any type of body
func NewCreateManyOpportunitiesRequestWithBody(server string, params *CreateManyOpportunitiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/opportunities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyPeopleRequest calls the generic CreateManyPeople builder with application/json body
func NewCreateManyPeopleRequest(server string, params *CreateManyPeopleParams, body CreateManyPeopleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyPeopleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyPeopleRequestWithBody generates requests for CreateManyPeople with any type of body
func NewCreateManyPeopleRequestWithBody(server string, params *CreateManyPeopleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyTaskTargetsRequest calls the generic CreateManyTaskTargets builder with application/json body
func NewCreateManyTaskTargetsRequest(server string, params *CreateManyTaskTargetsParams, body CreateManyTaskTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyTaskTargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyTaskTargetsRequestWithBody generates requests for CreateManyTaskTargets with any type of body
func NewCreateManyTaskTargetsRequestWithBody(server string, params *CreateManyTaskTargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/taskTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyTasksRequest calls the generic CreateManyTasks builder with application/json body
func NewCreateManyTasksRequest(server string, params *CreateManyTasksParams, body CreateManyTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyTasksRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyTasksRequestWithBody generates requests for CreateManyTasks with any type of body
func NewCreateManyTasksRequestWithBody(server string, params *CreateManyTasksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyTimelineActivitiesRequest calls the generic CreateManyTimelineActivities builder with application/json body
func NewCreateManyTimelineActivitiesRequest(server string, params *CreateManyTimelineActivitiesParams, body CreateManyTimelineActivitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyTimelineActivitiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyTimelineActivitiesRequestWithBody generates requests for CreateManyTimelineActivities with any type of body
func NewCreateManyTimelineActivitiesRequestWithBody(server string, params *CreateManyTimelineActivitiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/timelineActivities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyWorkflowAutomatedTriggersRequest calls the generic CreateManyWorkflowAutomatedTriggers builder with application/json body
func NewCreateManyWorkflowAutomatedTriggersRequest(server string, params *CreateManyWorkflowAutomatedTriggersParams, body CreateManyWorkflowAutomatedTriggersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyWorkflowAutomatedTriggersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyWorkflowAutomatedTriggersRequestWithBody generates requests for CreateManyWorkflowAutomatedTriggers with any type of body
func NewCreateManyWorkflowAutomatedTriggersRequestWithBody(server string, params *CreateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/workflowAutomatedTriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyWorkflowRunsRequest calls the generic CreateManyWorkflowRuns builder with application/json body
func NewCreateManyWorkflowRunsRequest(server string, params *CreateManyWorkflowRunsParams, body CreateManyWorkflowRunsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyWorkflowRunsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyWorkflowRunsRequestWithBody generates requests for CreateManyWorkflowRuns with any type of body
func NewCreateManyWorkflowRunsRequestWithBody(server string, params *CreateManyWorkflowRunsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/workflowRuns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyWorkflowVersionsRequest calls the generic CreateManyWorkflowVersions builder with application/json body
func NewCreateManyWorkflowVersionsRequest(server string, params *CreateManyWorkflowVersionsParams, body CreateManyWorkflowVersionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyWorkflowVersionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyWorkflowVersionsRequestWithBody generates requests for CreateManyWorkflowVersions with any type of body
func NewCreateManyWorkflowVersionsRequestWithBody(server string, params *CreateManyWorkflowVersionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/workflowVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyWorkflowsRequest calls the generic CreateManyWorkflows builder with application/json body
func NewCreateManyWorkflowsRequest(server string, params *CreateManyWorkflowsParams, body CreateManyWorkflowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyWorkflowsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyWorkflowsRequestWithBody generates requests for CreateManyWorkflows with any type of body
func NewCreateManyWorkflowsRequestWithBody(server string, params *CreateManyWorkflowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateManyWorkspaceMembersRequest calls the generic CreateManyWorkspaceMembers builder with application/json body
func NewCreateManyWorkspaceMembersRequest(server string, params *CreateManyWorkspaceMembersParams, body CreateManyWorkspaceMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManyWorkspaceMembersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManyWorkspaceMembersRequestWithBody generates requests for CreateManyWorkspaceMembers with any type of body
func NewCreateManyWorkspaceMembersRequestWithBody(server string, params *CreateManyWorkspaceMembersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch/workspaceMembers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyBlocklistsRequest generates requests for DeleteManyBlocklists
func NewDeleteManyBlocklistsRequest(server string, params *DeleteManyBlocklistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyBlocklistsRequest generates requests for FindManyBlocklists
func NewFindManyBlocklistsRequest(server string, params *FindManyBlocklistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyBlocklistsRequest calls the generic UpdateManyBlocklists builder with application/json body
func NewUpdateManyBlocklistsRequest(server string, params *UpdateManyBlocklistsParams, body UpdateManyBlocklistsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyBlocklistsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyBlocklistsRequestWithBody generates requests for UpdateManyBlocklists with any type of body
func NewUpdateManyBlocklistsRequestWithBody(server string, params *UpdateManyBlocklistsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneBlocklistRequest calls the generic CreateOneBlocklist builder with application/json body
func NewCreateOneBlocklistRequest(server string, params *CreateOneBlocklistParams, body CreateOneBlocklistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneBlocklistRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneBlocklistRequestWithBody generates requests for CreateOneBlocklist with any type of body
func NewCreateOneBlocklistRequestWithBody(server string, params *CreateOneBlocklistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindBlocklistDuplicatesRequest calls the generic FindBlocklistDuplicates builder with application/json body
func NewFindBlocklistDuplicatesRequest(server string, params *FindBlocklistDuplicatesParams, body FindBlocklistDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindBlocklistDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindBlocklistDuplicatesRequestWithBody generates requests for FindBlocklistDuplicates with any type of body
func NewFindBlocklistDuplicatesRequestWithBody(server string, params *FindBlocklistDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyBlocklistsRequest calls the generic MergeManyBlocklists builder with application/json body
func NewMergeManyBlocklistsRequest(server string, params *MergeManyBlocklistsParams, body MergeManyBlocklistsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyBlocklistsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyBlocklistsRequestWithBody generates requests for MergeManyBlocklists with any type of body
func NewMergeManyBlocklistsRequestWithBody(server string, params *MergeManyBlocklistsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneBlocklistRequest generates requests for DeleteOneBlocklist
func NewDeleteOneBlocklistRequest(server string, id IdPath, params *DeleteOneBlocklistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneBlocklistRequest generates requests for FindOneBlocklist
func NewFindOneBlocklistRequest(server string, id IdPath, params *FindOneBlocklistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneBlocklistRequest calls the generic UpdateOneBlocklist builder with application/json body
func NewUpdateOneBlocklistRequest(server string, id IdPath, params *UpdateOneBlocklistParams, body UpdateOneBlocklistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneBlocklistRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneBlocklistRequestWithBody generates requests for UpdateOneBlocklist with any type of body
func NewUpdateOneBlocklistRequestWithBody(server string, id IdPath, params *UpdateOneBlocklistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocklists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyCalendarChannelEventAssociationsRequest generates requests for DeleteManyCalendarChannelEventAssociations
func NewDeleteManyCalendarChannelEventAssociationsRequest(server string, params *DeleteManyCalendarChannelEventAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyCalendarChannelEventAssociationsRequest generates requests for FindManyCalendarChannelEventAssociations
func NewFindManyCalendarChannelEventAssociationsRequest(server string, params *FindManyCalendarChannelEventAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyCalendarChannelEventAssociationsRequest calls the generic UpdateManyCalendarChannelEventAssociations builder with application/json body
func NewUpdateManyCalendarChannelEventAssociationsRequest(server string, params *UpdateManyCalendarChannelEventAssociationsParams, body UpdateManyCalendarChannelEventAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyCalendarChannelEventAssociationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyCalendarChannelEventAssociationsRequestWithBody generates requests for UpdateManyCalendarChannelEventAssociations with any type of body
func NewUpdateManyCalendarChannelEventAssociationsRequestWithBody(server string, params *UpdateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneCalendarChannelEventAssociationRequest calls the generic CreateOneCalendarChannelEventAssociation builder with application/json body
func NewCreateOneCalendarChannelEventAssociationRequest(server string, params *CreateOneCalendarChannelEventAssociationParams, body CreateOneCalendarChannelEventAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneCalendarChannelEventAssociationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneCalendarChannelEventAssociationRequestWithBody generates requests for CreateOneCalendarChannelEventAssociation with any type of body
func NewCreateOneCalendarChannelEventAssociationRequestWithBody(server string, params *CreateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindCalendarChannelEventAssociationDuplicatesRequest calls the generic FindCalendarChannelEventAssociationDuplicates builder with application/json body
func NewFindCalendarChannelEventAssociationDuplicatesRequest(server string, params *FindCalendarChannelEventAssociationDuplicatesParams, body FindCalendarChannelEventAssociationDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindCalendarChannelEventAssociationDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindCalendarChannelEventAssociationDuplicatesRequestWithBody generates requests for FindCalendarChannelEventAssociationDuplicates with any type of body
func NewFindCalendarChannelEventAssociationDuplicatesRequestWithBody(server string, params *FindCalendarChannelEventAssociationDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyCalendarChannelEventAssociationsRequest calls the generic MergeManyCalendarChannelEventAssociations builder with application/json body
func NewMergeManyCalendarChannelEventAssociationsRequest(server string, params *MergeManyCalendarChannelEventAssociationsParams, body MergeManyCalendarChannelEventAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyCalendarChannelEventAssociationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyCalendarChannelEventAssociationsRequestWithBody generates requests for MergeManyCalendarChannelEventAssociations with any type of body
func NewMergeManyCalendarChannelEventAssociationsRequestWithBody(server string, params *MergeManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneCalendarChannelEventAssociationRequest generates requests for DeleteOneCalendarChannelEventAssociation
func NewDeleteOneCalendarChannelEventAssociationRequest(server string, id IdPath, params *DeleteOneCalendarChannelEventAssociationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneCalendarChannelEventAssociationRequest generates requests for FindOneCalendarChannelEventAssociation
func NewFindOneCalendarChannelEventAssociationRequest(server string, id IdPath, params *FindOneCalendarChannelEventAssociationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneCalendarChannelEventAssociationRequest calls the generic UpdateOneCalendarChannelEventAssociation builder with application/json body
func NewUpdateOneCalendarChannelEventAssociationRequest(server string, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, body UpdateOneCalendarChannelEventAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneCalendarChannelEventAssociationRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneCalendarChannelEventAssociationRequestWithBody generates requests for UpdateOneCalendarChannelEventAssociation with any type of body
func NewUpdateOneCalendarChannelEventAssociationRequestWithBody(server string, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannelEventAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyCalendarChannelsRequest generates requests for DeleteManyCalendarChannels
func NewDeleteManyCalendarChannelsRequest(server string, params *DeleteManyCalendarChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyCalendarChannelsRequest generates requests for FindManyCalendarChannels
func NewFindManyCalendarChannelsRequest(server string, params *FindManyCalendarChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyCalendarChannelsRequest calls the generic UpdateManyCalendarChannels builder with application/json body
func NewUpdateManyCalendarChannelsRequest(server string, params *UpdateManyCalendarChannelsParams, body UpdateManyCalendarChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyCalendarChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyCalendarChannelsRequestWithBody generates requests for UpdateManyCalendarChannels with any type of body
func NewUpdateManyCalendarChannelsRequestWithBody(server string, params *UpdateManyCalendarChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneCalendarChannelRequest calls the generic CreateOneCalendarChannel builder with application/json body
func NewCreateOneCalendarChannelRequest(server string, params *CreateOneCalendarChannelParams, body CreateOneCalendarChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneCalendarChannelRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneCalendarChannelRequestWithBody generates requests for CreateOneCalendarChannel with any type of body
func NewCreateOneCalendarChannelRequestWithBody(server string, params *CreateOneCalendarChannelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindCalendarChannelDuplicatesRequest calls the generic FindCalendarChannelDuplicates builder with application/json body
func NewFindCalendarChannelDuplicatesRequest(server string, params *FindCalendarChannelDuplicatesParams, body FindCalendarChannelDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindCalendarChannelDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindCalendarChannelDuplicatesRequestWithBody generates requests for FindCalendarChannelDuplicates with any type of body
func NewFindCalendarChannelDuplicatesRequestWithBody(server string, params *FindCalendarChannelDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyCalendarChannelsRequest calls the generic MergeManyCalendarChannels builder with application/json body
func NewMergeManyCalendarChannelsRequest(server string, params *MergeManyCalendarChannelsParams, body MergeManyCalendarChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyCalendarChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyCalendarChannelsRequestWithBody generates requests for MergeManyCalendarChannels with any type of body
func NewMergeManyCalendarChannelsRequestWithBody(server string, params *MergeManyCalendarChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneCalendarChannelRequest generates requests for DeleteOneCalendarChannel
func NewDeleteOneCalendarChannelRequest(server string, id IdPath, params *DeleteOneCalendarChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneCalendarChannelRequest generates requests for FindOneCalendarChannel
func NewFindOneCalendarChannelRequest(server string, id IdPath, params *FindOneCalendarChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneCalendarChannelRequest calls the generic UpdateOneCalendarChannel builder with application/json body
func NewUpdateOneCalendarChannelRequest(server string, id IdPath, params *UpdateOneCalendarChannelParams, body UpdateOneCalendarChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneCalendarChannelRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneCalendarChannelRequestWithBody generates requests for UpdateOneCalendarChannel with any type of body
func NewUpdateOneCalendarChannelRequestWithBody(server string, id IdPath, params *UpdateOneCalendarChannelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyCalendarEventParticipantsRequest generates requests for DeleteManyCalendarEventParticipants
func NewDeleteManyCalendarEventParticipantsRequest(server string, params *DeleteManyCalendarEventParticipantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyCalendarEventParticipantsRequest generates requests for FindManyCalendarEventParticipants
func NewFindManyCalendarEventParticipantsRequest(server string, params *FindManyCalendarEventParticipantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyCalendarEventParticipantsRequest calls the generic UpdateManyCalendarEventParticipants builder with application/json body
func NewUpdateManyCalendarEventParticipantsRequest(server string, params *UpdateManyCalendarEventParticipantsParams, body UpdateManyCalendarEventParticipantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyCalendarEventParticipantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyCalendarEventParticipantsRequestWithBody generates requests for UpdateManyCalendarEventParticipants with any type of body
func NewUpdateManyCalendarEventParticipantsRequestWithBody(server string, params *UpdateManyCalendarEventParticipantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneCalendarEventParticipantRequest calls the generic CreateOneCalendarEventParticipant builder with application/json body
func NewCreateOneCalendarEventParticipantRequest(server string, params *CreateOneCalendarEventParticipantParams, body CreateOneCalendarEventParticipantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneCalendarEventParticipantRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneCalendarEventParticipantRequestWithBody generates requests for CreateOneCalendarEventParticipant with any type of body
func NewCreateOneCalendarEventParticipantRequestWithBody(server string, params *CreateOneCalendarEventParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindCalendarEventParticipantDuplicatesRequest calls the generic FindCalendarEventParticipantDuplicates builder with application/json body
func NewFindCalendarEventParticipantDuplicatesRequest(server string, params *FindCalendarEventParticipantDuplicatesParams, body FindCalendarEventParticipantDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindCalendarEventParticipantDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindCalendarEventParticipantDuplicatesRequestWithBody generates requests for FindCalendarEventParticipantDuplicates with any type of body
func NewFindCalendarEventParticipantDuplicatesRequestWithBody(server string, params *FindCalendarEventParticipantDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyCalendarEventParticipantsRequest calls the generic MergeManyCalendarEventParticipants builder with application/json body
func NewMergeManyCalendarEventParticipantsRequest(server string, params *MergeManyCalendarEventParticipantsParams, body MergeManyCalendarEventParticipantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyCalendarEventParticipantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyCalendarEventParticipantsRequestWithBody generates requests for MergeManyCalendarEventParticipants with any type of body
func NewMergeManyCalendarEventParticipantsRequestWithBody(server string, params *MergeManyCalendarEventParticipantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneCalendarEventParticipantRequest generates requests for DeleteOneCalendarEventParticipant
func NewDeleteOneCalendarEventParticipantRequest(server string, id IdPath, params *DeleteOneCalendarEventParticipantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneCalendarEventParticipantRequest generates requests for FindOneCalendarEventParticipant
func NewFindOneCalendarEventParticipantRequest(server string, id IdPath, params *FindOneCalendarEventParticipantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneCalendarEventParticipantRequest calls the generic UpdateOneCalendarEventParticipant builder with application/json body
func NewUpdateOneCalendarEventParticipantRequest(server string, id IdPath, params *UpdateOneCalendarEventParticipantParams, body UpdateOneCalendarEventParticipantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneCalendarEventParticipantRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneCalendarEventParticipantRequestWithBody generates requests for UpdateOneCalendarEventParticipant with any type of body
func NewUpdateOneCalendarEventParticipantRequestWithBody(server string, id IdPath, params *UpdateOneCalendarEventParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEventParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyCalendarEventsRequest generates requests for DeleteManyCalendarEvents
func NewDeleteManyCalendarEventsRequest(server string, params *DeleteManyCalendarEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyCalendarEventsRequest generates requests for FindManyCalendarEvents
func NewFindManyCalendarEventsRequest(server string, params *FindManyCalendarEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyCalendarEventsRequest calls the generic UpdateManyCalendarEvents builder with application/json body
func NewUpdateManyCalendarEventsRequest(server string, params *UpdateManyCalendarEventsParams, body UpdateManyCalendarEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyCalendarEventsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyCalendarEventsRequestWithBody generates requests for UpdateManyCalendarEvents with any type of body
func NewUpdateManyCalendarEventsRequestWithBody(server string, params *UpdateManyCalendarEventsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneCalendarEventRequest calls the generic CreateOneCalendarEvent builder with application/json body
func NewCreateOneCalendarEventRequest(server string, params *CreateOneCalendarEventParams, body CreateOneCalendarEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneCalendarEventRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneCalendarEventRequestWithBody generates requests for CreateOneCalendarEvent with any type of body
func NewCreateOneCalendarEventRequestWithBody(server string, params *CreateOneCalendarEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindCalendarEventDuplicatesRequest calls the generic FindCalendarEventDuplicates builder with application/json body
func NewFindCalendarEventDuplicatesRequest(server string, params *FindCalendarEventDuplicatesParams, body FindCalendarEventDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindCalendarEventDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindCalendarEventDuplicatesRequestWithBody generates requests for FindCalendarEventDuplicates with any type of body
func NewFindCalendarEventDuplicatesRequestWithBody(server string, params *FindCalendarEventDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyCalendarEventsRequest calls the generic MergeManyCalendarEvents builder with application/json body
func NewMergeManyCalendarEventsRequest(server string, params *MergeManyCalendarEventsParams, body MergeManyCalendarEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyCalendarEventsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyCalendarEventsRequestWithBody generates requests for MergeManyCalendarEvents with any type of body
func NewMergeManyCalendarEventsRequestWithBody(server string, params *MergeManyCalendarEventsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneCalendarEventRequest generates requests for DeleteOneCalendarEvent
func NewDeleteOneCalendarEventRequest(server string, id IdPath, params *DeleteOneCalendarEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneCalendarEventRequest generates requests for FindOneCalendarEvent
func NewFindOneCalendarEventRequest(server string, id IdPath, params *FindOneCalendarEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneCalendarEventRequest calls the generic UpdateOneCalendarEvent builder with application/json body
func NewUpdateOneCalendarEventRequest(server string, id IdPath, params *UpdateOneCalendarEventParams, body UpdateOneCalendarEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneCalendarEventRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneCalendarEventRequestWithBody generates requests for UpdateOneCalendarEvent with any type of body
func NewUpdateOneCalendarEventRequestWithBody(server string, id IdPath, params *UpdateOneCalendarEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/calendarEvents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyCompaniesRequest generates requests for DeleteManyCompanies
func NewDeleteManyCompaniesRequest(server string, params *DeleteManyCompaniesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyCompaniesRequest generates requests for FindManyCompanies
func NewFindManyCompaniesRequest(server string, params *FindManyCompaniesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyCompaniesRequest calls the generic UpdateManyCompanies builder with application/json body
func NewUpdateManyCompaniesRequest(server string, params *UpdateManyCompaniesParams, body UpdateManyCompaniesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyCompaniesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyCompaniesRequestWithBody generates requests for UpdateManyCompanies with any type of body
func NewUpdateManyCompaniesRequestWithBody(server string, params *UpdateManyCompaniesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneCompanyRequest calls the generic CreateOneCompany builder with application/json body
func NewCreateOneCompanyRequest(server string, params *CreateOneCompanyParams, body CreateOneCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneCompanyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneCompanyRequestWithBody generates requests for CreateOneCompany with any type of body
func NewCreateOneCompanyRequestWithBody(server string, params *CreateOneCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindCompanyDuplicatesRequest calls the generic FindCompanyDuplicates builder with application/json body
func NewFindCompanyDuplicatesRequest(server string, params *FindCompanyDuplicatesParams, body FindCompanyDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindCompanyDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindCompanyDuplicatesRequestWithBody generates requests for FindCompanyDuplicates with any type of body
func NewFindCompanyDuplicatesRequestWithBody(server string, params *FindCompanyDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyCompaniesRequest calls the generic MergeManyCompanies builder with application/json body
func NewMergeManyCompaniesRequest(server string, params *MergeManyCompaniesParams, body MergeManyCompaniesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyCompaniesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyCompaniesRequestWithBody generates requests for MergeManyCompanies with any type of body
func NewMergeManyCompaniesRequestWithBody(server string, params *MergeManyCompaniesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneCompanyRequest generates requests for DeleteOneCompany
func NewDeleteOneCompanyRequest(server string, id IdPath, params *DeleteOneCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneCompanyRequest generates requests for FindOneCompany
func NewFindOneCompanyRequest(server string, id IdPath, params *FindOneCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneCompanyRequest calls the generic UpdateOneCompany builder with application/json body
func NewUpdateOneCompanyRequest(server string, id IdPath, params *UpdateOneCompanyParams, body UpdateOneCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneCompanyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneCompanyRequestWithBody generates requests for UpdateOneCompany with any type of body
func NewUpdateOneCompanyRequestWithBody(server string, id IdPath, params *UpdateOneCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyConnectedAccountsRequest generates requests for DeleteManyConnectedAccounts
func NewDeleteManyConnectedAccountsRequest(server string, params *DeleteManyConnectedAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyConnectedAccountsRequest generates requests for FindManyConnectedAccounts
func NewFindManyConnectedAccountsRequest(server string, params *FindManyConnectedAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyConnectedAccountsRequest calls the generic UpdateManyConnectedAccounts builder with application/json body
func NewUpdateManyConnectedAccountsRequest(server string, params *UpdateManyConnectedAccountsParams, body UpdateManyConnectedAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyConnectedAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyConnectedAccountsRequestWithBody generates requests for UpdateManyConnectedAccounts with any type of body
func NewUpdateManyConnectedAccountsRequestWithBody(server string, params *UpdateManyConnectedAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneConnectedAccountRequest calls the generic CreateOneConnectedAccount builder with application/json body
func NewCreateOneConnectedAccountRequest(server string, params *CreateOneConnectedAccountParams, body CreateOneConnectedAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneConnectedAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneConnectedAccountRequestWithBody generates requests for CreateOneConnectedAccount with any type of body
func NewCreateOneConnectedAccountRequestWithBody(server string, params *CreateOneConnectedAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindConnectedAccountDuplicatesRequest calls the generic FindConnectedAccountDuplicates builder with application/json body
func NewFindConnectedAccountDuplicatesRequest(server string, params *FindConnectedAccountDuplicatesParams, body FindConnectedAccountDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindConnectedAccountDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindConnectedAccountDuplicatesRequestWithBody generates requests for FindConnectedAccountDuplicates with any type of body
func NewFindConnectedAccountDuplicatesRequestWithBody(server string, params *FindConnectedAccountDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyConnectedAccountsRequest calls the generic MergeManyConnectedAccounts builder with application/json body
func NewMergeManyConnectedAccountsRequest(server string, params *MergeManyConnectedAccountsParams, body MergeManyConnectedAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyConnectedAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyConnectedAccountsRequestWithBody generates requests for MergeManyConnectedAccounts with any type of body
func NewMergeManyConnectedAccountsRequestWithBody(server string, params *MergeManyConnectedAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneConnectedAccountRequest generates requests for DeleteOneConnectedAccount
func NewDeleteOneConnectedAccountRequest(server string, id IdPath, params *DeleteOneConnectedAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneConnectedAccountRequest generates requests for FindOneConnectedAccount
func NewFindOneConnectedAccountRequest(server string, id IdPath, params *FindOneConnectedAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneConnectedAccountRequest calls the generic UpdateOneConnectedAccount builder with application/json body
func NewUpdateOneConnectedAccountRequest(server string, id IdPath, params *UpdateOneConnectedAccountParams, body UpdateOneConnectedAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneConnectedAccountRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneConnectedAccountRequestWithBody generates requests for UpdateOneConnectedAccount with any type of body
func NewUpdateOneConnectedAccountRequestWithBody(server string, id IdPath, params *UpdateOneConnectedAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectedAccounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyDashboardsRequest generates requests for DeleteManyDashboards
func NewDeleteManyDashboardsRequest(server string, params *DeleteManyDashboardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyDashboardsRequest generates requests for FindManyDashboards
func NewFindManyDashboardsRequest(server string, params *FindManyDashboardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyDashboardsRequest calls the generic UpdateManyDashboards builder with application/json body
func NewUpdateManyDashboardsRequest(server string, params *UpdateManyDashboardsParams, body UpdateManyDashboardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyDashboardsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyDashboardsRequestWithBody generates requests for UpdateManyDashboards with any type of body
func NewUpdateManyDashboardsRequestWithBody(server string, params *UpdateManyDashboardsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneDashboardRequest calls the generic CreateOneDashboard builder with application/json body
func NewCreateOneDashboardRequest(server string, params *CreateOneDashboardParams, body CreateOneDashboardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneDashboardRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneDashboardRequestWithBody generates requests for CreateOneDashboard with any type of body
func NewCreateOneDashboardRequestWithBody(server string, params *CreateOneDashboardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindDashboardDuplicatesRequest calls the generic FindDashboardDuplicates builder with application/json body
func NewFindDashboardDuplicatesRequest(server string, params *FindDashboardDuplicatesParams, body FindDashboardDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindDashboardDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindDashboardDuplicatesRequestWithBody generates requests for FindDashboardDuplicates with any type of body
func NewFindDashboardDuplicatesRequestWithBody(server string, params *FindDashboardDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyDashboardsRequest calls the generic MergeManyDashboards builder with application/json body
func NewMergeManyDashboardsRequest(server string, params *MergeManyDashboardsParams, body MergeManyDashboardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyDashboardsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyDashboardsRequestWithBody generates requests for MergeManyDashboards with any type of body
func NewMergeManyDashboardsRequestWithBody(server string, params *MergeManyDashboardsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneDashboardRequest generates requests for DeleteOneDashboard
func NewDeleteOneDashboardRequest(server string, id IdPath, params *DeleteOneDashboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneDashboardRequest generates requests for FindOneDashboard
func NewFindOneDashboardRequest(server string, id IdPath, params *FindOneDashboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneDashboardRequest calls the generic UpdateOneDashboard builder with application/json body
func NewUpdateOneDashboardRequest(server string, id IdPath, params *UpdateOneDashboardParams, body UpdateOneDashboardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneDashboardRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneDashboardRequestWithBody generates requests for UpdateOneDashboard with any type of body
func NewUpdateOneDashboardRequestWithBody(server string, id IdPath, params *UpdateOneDashboardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDuplicateDashboardRequest generates requests for DuplicateDashboard
func NewDuplicateDashboardRequest(server string, id IdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/%s/duplicate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteManyFavoriteFoldersRequest generates requests for DeleteManyFavoriteFolders
func NewDeleteManyFavoriteFoldersRequest(server string, params *DeleteManyFavoriteFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyFavoriteFoldersRequest generates requests for FindManyFavoriteFolders
func NewFindManyFavoriteFoldersRequest(server string, params *FindManyFavoriteFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyFavoriteFoldersRequest calls the generic UpdateManyFavoriteFolders builder with application/json body
func NewUpdateManyFavoriteFoldersRequest(server string, params *UpdateManyFavoriteFoldersParams, body UpdateManyFavoriteFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyFavoriteFoldersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyFavoriteFoldersRequestWithBody generates requests for UpdateManyFavoriteFolders with any type of body
func NewUpdateManyFavoriteFoldersRequestWithBody(server string, params *UpdateManyFavoriteFoldersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneFavoriteFolderRequest calls the generic CreateOneFavoriteFolder builder with application/json body
func NewCreateOneFavoriteFolderRequest(server string, params *CreateOneFavoriteFolderParams, body CreateOneFavoriteFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneFavoriteFolderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneFavoriteFolderRequestWithBody generates requests for CreateOneFavoriteFolder with any type of body
func NewCreateOneFavoriteFolderRequestWithBody(server string, params *CreateOneFavoriteFolderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindFavoriteFolderDuplicatesRequest calls the generic FindFavoriteFolderDuplicates builder with application/json body
func NewFindFavoriteFolderDuplicatesRequest(server string, params *FindFavoriteFolderDuplicatesParams, body FindFavoriteFolderDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindFavoriteFolderDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindFavoriteFolderDuplicatesRequestWithBody generates requests for FindFavoriteFolderDuplicates with any type of body
func NewFindFavoriteFolderDuplicatesRequestWithBody(server string, params *FindFavoriteFolderDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyFavoriteFoldersRequest calls the generic MergeManyFavoriteFolders builder with application/json body
func NewMergeManyFavoriteFoldersRequest(server string, params *MergeManyFavoriteFoldersParams, body MergeManyFavoriteFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyFavoriteFoldersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyFavoriteFoldersRequestWithBody generates requests for MergeManyFavoriteFolders with any type of body
func NewMergeManyFavoriteFoldersRequestWithBody(server string, params *MergeManyFavoriteFoldersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneFavoriteFolderRequest generates requests for DeleteOneFavoriteFolder
func NewDeleteOneFavoriteFolderRequest(server string, id IdPath, params *DeleteOneFavoriteFolderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneFavoriteFolderRequest generates requests for FindOneFavoriteFolder
func NewFindOneFavoriteFolderRequest(server string, id IdPath, params *FindOneFavoriteFolderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneFavoriteFolderRequest calls the generic UpdateOneFavoriteFolder builder with application/json body
func NewUpdateOneFavoriteFolderRequest(server string, id IdPath, params *UpdateOneFavoriteFolderParams, body UpdateOneFavoriteFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneFavoriteFolderRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneFavoriteFolderRequestWithBody generates requests for UpdateOneFavoriteFolder with any type of body
func NewUpdateOneFavoriteFolderRequestWithBody(server string, id IdPath, params *UpdateOneFavoriteFolderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favoriteFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyFavoritesRequest generates requests for DeleteManyFavorites
func NewDeleteManyFavoritesRequest(server string, params *DeleteManyFavoritesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyFavoritesRequest generates requests for FindManyFavorites
func NewFindManyFavoritesRequest(server string, params *FindManyFavoritesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyFavoritesRequest calls the generic UpdateManyFavorites builder with application/json body
func NewUpdateManyFavoritesRequest(server string, params *UpdateManyFavoritesParams, body UpdateManyFavoritesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyFavoritesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyFavoritesRequestWithBody generates requests for UpdateManyFavorites with any type of body
func NewUpdateManyFavoritesRequestWithBody(server string, params *UpdateManyFavoritesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneFavoriteRequest calls the generic CreateOneFavorite builder with application/json body
func NewCreateOneFavoriteRequest(server string, params *CreateOneFavoriteParams, body CreateOneFavoriteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneFavoriteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneFavoriteRequestWithBody generates requests for CreateOneFavorite with any type of body
func NewCreateOneFavoriteRequestWithBody(server string, params *CreateOneFavoriteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindFavoriteDuplicatesRequest calls the generic FindFavoriteDuplicates builder with application/json body
func NewFindFavoriteDuplicatesRequest(server string, params *FindFavoriteDuplicatesParams, body FindFavoriteDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindFavoriteDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindFavoriteDuplicatesRequestWithBody generates requests for FindFavoriteDuplicates with any type of body
func NewFindFavoriteDuplicatesRequestWithBody(server string, params *FindFavoriteDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyFavoritesRequest calls the generic MergeManyFavorites builder with application/json body
func NewMergeManyFavoritesRequest(server string, params *MergeManyFavoritesParams, body MergeManyFavoritesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyFavoritesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyFavoritesRequestWithBody generates requests for MergeManyFavorites with any type of body
func NewMergeManyFavoritesRequestWithBody(server string, params *MergeManyFavoritesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneFavoriteRequest generates requests for DeleteOneFavorite
func NewDeleteOneFavoriteRequest(server string, id IdPath, params *DeleteOneFavoriteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneFavoriteRequest generates requests for FindOneFavorite
func NewFindOneFavoriteRequest(server string, id IdPath, params *FindOneFavoriteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneFavoriteRequest calls the generic UpdateOneFavorite builder with application/json body
func NewUpdateOneFavoriteRequest(server string, id IdPath, params *UpdateOneFavoriteParams, body UpdateOneFavoriteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneFavoriteRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneFavoriteRequestWithBody generates requests for UpdateOneFavorite with any type of body
func NewUpdateOneFavoriteRequestWithBody(server string, id IdPath, params *UpdateOneFavoriteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/favorites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyMessageChannelMessageAssociationsRequest generates requests for DeleteManyMessageChannelMessageAssociations
func NewDeleteManyMessageChannelMessageAssociationsRequest(server string, params *DeleteManyMessageChannelMessageAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyMessageChannelMessageAssociationsRequest generates requests for FindManyMessageChannelMessageAssociations
func NewFindManyMessageChannelMessageAssociationsRequest(server string, params *FindManyMessageChannelMessageAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyMessageChannelMessageAssociationsRequest calls the generic UpdateManyMessageChannelMessageAssociations builder with application/json body
func NewUpdateManyMessageChannelMessageAssociationsRequest(server string, params *UpdateManyMessageChannelMessageAssociationsParams, body UpdateManyMessageChannelMessageAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyMessageChannelMessageAssociationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyMessageChannelMessageAssociationsRequestWithBody generates requests for UpdateManyMessageChannelMessageAssociations with any type of body
func NewUpdateManyMessageChannelMessageAssociationsRequestWithBody(server string, params *UpdateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneMessageChannelMessageAssociationRequest calls the generic CreateOneMessageChannelMessageAssociation builder with application/json body
func NewCreateOneMessageChannelMessageAssociationRequest(server string, params *CreateOneMessageChannelMessageAssociationParams, body CreateOneMessageChannelMessageAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneMessageChannelMessageAssociationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneMessageChannelMessageAssociationRequestWithBody generates requests for CreateOneMessageChannelMessageAssociation with any type of body
func NewCreateOneMessageChannelMessageAssociationRequestWithBody(server string, params *CreateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindMessageChannelMessageAssociationDuplicatesRequest calls the generic FindMessageChannelMessageAssociationDuplicates builder with application/json body
func NewFindMessageChannelMessageAssociationDuplicatesRequest(server string, params *FindMessageChannelMessageAssociationDuplicatesParams, body FindMessageChannelMessageAssociationDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindMessageChannelMessageAssociationDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindMessageChannelMessageAssociationDuplicatesRequestWithBody generates requests for FindMessageChannelMessageAssociationDuplicates with any type of body
func NewFindMessageChannelMessageAssociationDuplicatesRequestWithBody(server string, params *FindMessageChannelMessageAssociationDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyMessageChannelMessageAssociationsRequest calls the generic MergeManyMessageChannelMessageAssociations builder with application/json body
func NewMergeManyMessageChannelMessageAssociationsRequest(server string, params *MergeManyMessageChannelMessageAssociationsParams, body MergeManyMessageChannelMessageAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyMessageChannelMessageAssociationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyMessageChannelMessageAssociationsRequestWithBody generates requests for MergeManyMessageChannelMessageAssociations with any type of body
func NewMergeManyMessageChannelMessageAssociationsRequestWithBody(server string, params *MergeManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneMessageChannelMessageAssociationRequest generates requests for DeleteOneMessageChannelMessageAssociation
func NewDeleteOneMessageChannelMessageAssociationRequest(server string, id IdPath, params *DeleteOneMessageChannelMessageAssociationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneMessageChannelMessageAssociationRequest generates requests for FindOneMessageChannelMessageAssociation
func NewFindOneMessageChannelMessageAssociationRequest(server string, id IdPath, params *FindOneMessageChannelMessageAssociationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneMessageChannelMessageAssociationRequest calls the generic UpdateOneMessageChannelMessageAssociation builder with application/json body
func NewUpdateOneMessageChannelMessageAssociationRequest(server string, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, body UpdateOneMessageChannelMessageAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneMessageChannelMessageAssociationRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneMessageChannelMessageAssociationRequestWithBody generates requests for UpdateOneMessageChannelMessageAssociation with any type of body
func NewUpdateOneMessageChannelMessageAssociationRequestWithBody(server string, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannelMessageAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyMessageChannelsRequest generates requests for DeleteManyMessageChannels
func NewDeleteManyMessageChannelsRequest(server string, params *DeleteManyMessageChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyMessageChannelsRequest generates requests for FindManyMessageChannels
func NewFindManyMessageChannelsRequest(server string, params *FindManyMessageChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyMessageChannelsRequest calls the generic UpdateManyMessageChannels builder with application/json body
func NewUpdateManyMessageChannelsRequest(server string, params *UpdateManyMessageChannelsParams, body UpdateManyMessageChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyMessageChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyMessageChannelsRequestWithBody generates requests for UpdateManyMessageChannels with any type of body
func NewUpdateManyMessageChannelsRequestWithBody(server string, params *UpdateManyMessageChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneMessageChannelRequest calls the generic CreateOneMessageChannel builder with application/json body
func NewCreateOneMessageChannelRequest(server string, params *CreateOneMessageChannelParams, body CreateOneMessageChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneMessageChannelRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneMessageChannelRequestWithBody generates requests for CreateOneMessageChannel with any type of body
func NewCreateOneMessageChannelRequestWithBody(server string, params *CreateOneMessageChannelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindMessageChannelDuplicatesRequest calls the generic FindMessageChannelDuplicates builder with application/json body
func NewFindMessageChannelDuplicatesRequest(server string, params *FindMessageChannelDuplicatesParams, body FindMessageChannelDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindMessageChannelDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindMessageChannelDuplicatesRequestWithBody generates requests for FindMessageChannelDuplicates with any type of body
func NewFindMessageChannelDuplicatesRequestWithBody(server string, params *FindMessageChannelDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyMessageChannelsRequest calls the generic MergeManyMessageChannels builder with application/json body
func NewMergeManyMessageChannelsRequest(server string, params *MergeManyMessageChannelsParams, body MergeManyMessageChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyMessageChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyMessageChannelsRequestWithBody generates requests for MergeManyMessageChannels with any type of body
func NewMergeManyMessageChannelsRequestWithBody(server string, params *MergeManyMessageChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneMessageChannelRequest generates requests for DeleteOneMessageChannel
func NewDeleteOneMessageChannelRequest(server string, id IdPath, params *DeleteOneMessageChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneMessageChannelRequest generates requests for FindOneMessageChannel
func NewFindOneMessageChannelRequest(server string, id IdPath, params *FindOneMessageChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneMessageChannelRequest calls the generic UpdateOneMessageChannel builder with application/json body
func NewUpdateOneMessageChannelRequest(server string, id IdPath, params *UpdateOneMessageChannelParams, body UpdateOneMessageChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneMessageChannelRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneMessageChannelRequestWithBody generates requests for UpdateOneMessageChannel with any type of body
func NewUpdateOneMessageChannelRequestWithBody(server string, id IdPath, params *UpdateOneMessageChannelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyMessageFoldersRequest generates requests for DeleteManyMessageFolders
func NewDeleteManyMessageFoldersRequest(server string, params *DeleteManyMessageFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyMessageFoldersRequest generates requests for FindManyMessageFolders
func NewFindManyMessageFoldersRequest(server string, params *FindManyMessageFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyMessageFoldersRequest calls the generic UpdateManyMessageFolders builder with application/json body
func NewUpdateManyMessageFoldersRequest(server string, params *UpdateManyMessageFoldersParams, body UpdateManyMessageFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyMessageFoldersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyMessageFoldersRequestWithBody generates requests for UpdateManyMessageFolders with any type of body
func NewUpdateManyMessageFoldersRequestWithBody(server string, params *UpdateManyMessageFoldersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneMessageFolderRequest calls the generic CreateOneMessageFolder builder with application/json body
func NewCreateOneMessageFolderRequest(server string, params *CreateOneMessageFolderParams, body CreateOneMessageFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneMessageFolderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneMessageFolderRequestWithBody generates requests for CreateOneMessageFolder with any type of body
func NewCreateOneMessageFolderRequestWithBody(server string, params *CreateOneMessageFolderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindMessageFolderDuplicatesRequest calls the generic FindMessageFolderDuplicates builder with application/json body
func NewFindMessageFolderDuplicatesRequest(server string, params *FindMessageFolderDuplicatesParams, body FindMessageFolderDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindMessageFolderDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindMessageFolderDuplicatesRequestWithBody generates requests for FindMessageFolderDuplicates with any type of body
func NewFindMessageFolderDuplicatesRequestWithBody(server string, params *FindMessageFolderDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyMessageFoldersRequest calls the generic MergeManyMessageFolders builder with application/json body
func NewMergeManyMessageFoldersRequest(server string, params *MergeManyMessageFoldersParams, body MergeManyMessageFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyMessageFoldersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyMessageFoldersRequestWithBody generates requests for MergeManyMessageFolders with any type of body
func NewMergeManyMessageFoldersRequestWithBody(server string, params *MergeManyMessageFoldersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneMessageFolderRequest generates requests for DeleteOneMessageFolder
func NewDeleteOneMessageFolderRequest(server string, id IdPath, params *DeleteOneMessageFolderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneMessageFolderRequest generates requests for FindOneMessageFolder
func NewFindOneMessageFolderRequest(server string, id IdPath, params *FindOneMessageFolderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneMessageFolderRequest calls the generic UpdateOneMessageFolder builder with application/json body
func NewUpdateOneMessageFolderRequest(server string, id IdPath, params *UpdateOneMessageFolderParams, body UpdateOneMessageFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneMessageFolderRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneMessageFolderRequestWithBody generates requests for UpdateOneMessageFolder with any type of body
func NewUpdateOneMessageFolderRequestWithBody(server string, id IdPath, params *UpdateOneMessageFolderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyMessageParticipantsRequest generates requests for DeleteManyMessageParticipants
func NewDeleteManyMessageParticipantsRequest(server string, params *DeleteManyMessageParticipantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyMessageParticipantsRequest generates requests for FindManyMessageParticipants
func NewFindManyMessageParticipantsRequest(server string, params *FindManyMessageParticipantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyMessageParticipantsRequest calls the generic UpdateManyMessageParticipants builder with application/json body
func NewUpdateManyMessageParticipantsRequest(server string, params *UpdateManyMessageParticipantsParams, body UpdateManyMessageParticipantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyMessageParticipantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyMessageParticipantsRequestWithBody generates requests for UpdateManyMessageParticipants with any type of body
func NewUpdateManyMessageParticipantsRequestWithBody(server string, params *UpdateManyMessageParticipantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneMessageParticipantRequest calls the generic CreateOneMessageParticipant builder with application/json body
func NewCreateOneMessageParticipantRequest(server string, params *CreateOneMessageParticipantParams, body CreateOneMessageParticipantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneMessageParticipantRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneMessageParticipantRequestWithBody generates requests for CreateOneMessageParticipant with any type of body
func NewCreateOneMessageParticipantRequestWithBody(server string, params *CreateOneMessageParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindMessageParticipantDuplicatesRequest calls the generic FindMessageParticipantDuplicates builder with application/json body
func NewFindMessageParticipantDuplicatesRequest(server string, params *FindMessageParticipantDuplicatesParams, body FindMessageParticipantDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindMessageParticipantDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindMessageParticipantDuplicatesRequestWithBody generates requests for FindMessageParticipantDuplicates with any type of body
func NewFindMessageParticipantDuplicatesRequestWithBody(server string, params *FindMessageParticipantDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyMessageParticipantsRequest calls the generic MergeManyMessageParticipants builder with application/json body
func NewMergeManyMessageParticipantsRequest(server string, params *MergeManyMessageParticipantsParams, body MergeManyMessageParticipantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyMessageParticipantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyMessageParticipantsRequestWithBody generates requests for MergeManyMessageParticipants with any type of body
func NewMergeManyMessageParticipantsRequestWithBody(server string, params *MergeManyMessageParticipantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneMessageParticipantRequest generates requests for DeleteOneMessageParticipant
func NewDeleteOneMessageParticipantRequest(server string, id IdPath, params *DeleteOneMessageParticipantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneMessageParticipantRequest generates requests for FindOneMessageParticipant
func NewFindOneMessageParticipantRequest(server string, id IdPath, params *FindOneMessageParticipantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneMessageParticipantRequest calls the generic UpdateOneMessageParticipant builder with application/json body
func NewUpdateOneMessageParticipantRequest(server string, id IdPath, params *UpdateOneMessageParticipantParams, body UpdateOneMessageParticipantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneMessageParticipantRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneMessageParticipantRequestWithBody generates requests for UpdateOneMessageParticipant with any type of body
func NewUpdateOneMessageParticipantRequestWithBody(server string, id IdPath, params *UpdateOneMessageParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyMessageThreadsRequest generates requests for DeleteManyMessageThreads
func NewDeleteManyMessageThreadsRequest(server string, params *DeleteManyMessageThreadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyMessageThreadsRequest generates requests for FindManyMessageThreads
func NewFindManyMessageThreadsRequest(server string, params *FindManyMessageThreadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyMessageThreadsRequest calls the generic UpdateManyMessageThreads builder with application/json body
func NewUpdateManyMessageThreadsRequest(server string, params *UpdateManyMessageThreadsParams, body UpdateManyMessageThreadsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyMessageThreadsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyMessageThreadsRequestWithBody generates requests for UpdateManyMessageThreads with any type of body
func NewUpdateManyMessageThreadsRequestWithBody(server string, params *UpdateManyMessageThreadsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneMessageThreadRequest calls the generic CreateOneMessageThread builder with application/json body
func NewCreateOneMessageThreadRequest(server string, params *CreateOneMessageThreadParams, body CreateOneMessageThreadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneMessageThreadRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneMessageThreadRequestWithBody generates requests for CreateOneMessageThread with any type of body
func NewCreateOneMessageThreadRequestWithBody(server string, params *CreateOneMessageThreadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindMessageThreadDuplicatesRequest calls the generic FindMessageThreadDuplicates builder with application/json body
func NewFindMessageThreadDuplicatesRequest(server string, params *FindMessageThreadDuplicatesParams, body FindMessageThreadDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindMessageThreadDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindMessageThreadDuplicatesRequestWithBody generates requests for FindMessageThreadDuplicates with any type of body
func NewFindMessageThreadDuplicatesRequestWithBody(server string, params *FindMessageThreadDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyMessageThreadsRequest calls the generic MergeManyMessageThreads builder with application/json body
func NewMergeManyMessageThreadsRequest(server string, params *MergeManyMessageThreadsParams, body MergeManyMessageThreadsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyMessageThreadsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyMessageThreadsRequestWithBody generates requests for MergeManyMessageThreads with any type of body
func NewMergeManyMessageThreadsRequestWithBody(server string, params *MergeManyMessageThreadsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneMessageThreadRequest generates requests for DeleteOneMessageThread
func NewDeleteOneMessageThreadRequest(server string, id IdPath, params *DeleteOneMessageThreadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneMessageThreadRequest generates requests for FindOneMessageThread
func NewFindOneMessageThreadRequest(server string, id IdPath, params *FindOneMessageThreadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneMessageThreadRequest calls the generic UpdateOneMessageThread builder with application/json body
func NewUpdateOneMessageThreadRequest(server string, id IdPath, params *UpdateOneMessageThreadParams, body UpdateOneMessageThreadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneMessageThreadRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneMessageThreadRequestWithBody generates requests for UpdateOneMessageThread with any type of body
func NewUpdateOneMessageThreadRequestWithBody(server string, id IdPath, params *UpdateOneMessageThreadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messageThreads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyMessagesRequest generates requests for DeleteManyMessages
func NewDeleteManyMessagesRequest(server string, params *DeleteManyMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyMessagesRequest generates requests for FindManyMessages
func NewFindManyMessagesRequest(server string, params *FindManyMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyMessagesRequest calls the generic UpdateManyMessages builder with application/json body
func NewUpdateManyMessagesRequest(server string, params *UpdateManyMessagesParams, body UpdateManyMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyMessagesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyMessagesRequestWithBody generates requests for UpdateManyMessages with any type of body
func NewUpdateManyMessagesRequestWithBody(server string, params *UpdateManyMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneMessageRequest calls the generic CreateOneMessage builder with application/json body
func NewCreateOneMessageRequest(server string, params *CreateOneMessageParams, body CreateOneMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneMessageRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneMessageRequestWithBody generates requests for CreateOneMessage with any type of body
func NewCreateOneMessageRequestWithBody(server string, params *CreateOneMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindMessageDuplicatesRequest calls the generic FindMessageDuplicates builder with application/json body
func NewFindMessageDuplicatesRequest(server string, params *FindMessageDuplicatesParams, body FindMessageDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindMessageDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindMessageDuplicatesRequestWithBody generates requests for FindMessageDuplicates with any type of body
func NewFindMessageDuplicatesRequestWithBody(server string, params *FindMessageDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyMessagesRequest calls the generic MergeManyMessages builder with application/json body
func NewMergeManyMessagesRequest(server string, params *MergeManyMessagesParams, body MergeManyMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyMessagesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyMessagesRequestWithBody generates requests for MergeManyMessages with any type of body
func NewMergeManyMessagesRequestWithBody(server string, params *MergeManyMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneMessageRequest generates requests for DeleteOneMessage
func NewDeleteOneMessageRequest(server string, id IdPath, params *DeleteOneMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneMessageRequest generates requests for FindOneMessage
func NewFindOneMessageRequest(server string, id IdPath, params *FindOneMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneMessageRequest calls the generic UpdateOneMessage builder with application/json body
func NewUpdateOneMessageRequest(server string, id IdPath, params *UpdateOneMessageParams, body UpdateOneMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneMessageRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneMessageRequestWithBody generates requests for UpdateOneMessage with any type of body
func NewUpdateOneMessageRequestWithBody(server string, id IdPath, params *UpdateOneMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyNoteTargetsRequest generates requests for DeleteManyNoteTargets
func NewDeleteManyNoteTargetsRequest(server string, params *DeleteManyNoteTargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyNoteTargetsRequest generates requests for FindManyNoteTargets
func NewFindManyNoteTargetsRequest(server string, params *FindManyNoteTargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyNoteTargetsRequest calls the generic UpdateManyNoteTargets builder with application/json body
func NewUpdateManyNoteTargetsRequest(server string, params *UpdateManyNoteTargetsParams, body UpdateManyNoteTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyNoteTargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyNoteTargetsRequestWithBody generates requests for UpdateManyNoteTargets with any type of body
func NewUpdateManyNoteTargetsRequestWithBody(server string, params *UpdateManyNoteTargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneNoteTargetRequest calls the generic CreateOneNoteTarget builder with application/json body
func NewCreateOneNoteTargetRequest(server string, params *CreateOneNoteTargetParams, body CreateOneNoteTargetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneNoteTargetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneNoteTargetRequestWithBody generates requests for CreateOneNoteTarget with any type of body
func NewCreateOneNoteTargetRequestWithBody(server string, params *CreateOneNoteTargetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindNoteTargetDuplicatesRequest calls the generic FindNoteTargetDuplicates builder with application/json body
func NewFindNoteTargetDuplicatesRequest(server string, params *FindNoteTargetDuplicatesParams, body FindNoteTargetDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindNoteTargetDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindNoteTargetDuplicatesRequestWithBody generates requests for FindNoteTargetDuplicates with any type of body
func NewFindNoteTargetDuplicatesRequestWithBody(server string, params *FindNoteTargetDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyNoteTargetsRequest calls the generic MergeManyNoteTargets builder with application/json body
func NewMergeManyNoteTargetsRequest(server string, params *MergeManyNoteTargetsParams, body MergeManyNoteTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyNoteTargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyNoteTargetsRequestWithBody generates requests for MergeManyNoteTargets with any type of body
func NewMergeManyNoteTargetsRequestWithBody(server string, params *MergeManyNoteTargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneNoteTargetRequest generates requests for DeleteOneNoteTarget
func NewDeleteOneNoteTargetRequest(server string, id IdPath, params *DeleteOneNoteTargetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneNoteTargetRequest generates requests for FindOneNoteTarget
func NewFindOneNoteTargetRequest(server string, id IdPath, params *FindOneNoteTargetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneNoteTargetRequest calls the generic UpdateOneNoteTarget builder with application/json body
func NewUpdateOneNoteTargetRequest(server string, id IdPath, params *UpdateOneNoteTargetParams, body UpdateOneNoteTargetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneNoteTargetRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneNoteTargetRequestWithBody generates requests for UpdateOneNoteTarget with any type of body
func NewUpdateOneNoteTargetRequestWithBody(server string, id IdPath, params *UpdateOneNoteTargetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/noteTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyNotesRequest generates requests for DeleteManyNotes
func NewDeleteManyNotesRequest(server string, params *DeleteManyNotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyNotesRequest generates requests for FindManyNotes
func NewFindManyNotesRequest(server string, params *FindManyNotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyNotesRequest calls the generic UpdateManyNotes builder with application/json body
func NewUpdateManyNotesRequest(server string, params *UpdateManyNotesParams, body UpdateManyNotesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyNotesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyNotesRequestWithBody generates requests for UpdateManyNotes with any type of body
func NewUpdateManyNotesRequestWithBody(server string, params *UpdateManyNotesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneNoteRequest calls the generic CreateOneNote builder with application/json body
func NewCreateOneNoteRequest(server string, params *CreateOneNoteParams, body CreateOneNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneNoteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneNoteRequestWithBody generates requests for CreateOneNote with any type of body
func NewCreateOneNoteRequestWithBody(server string, params *CreateOneNoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindNoteDuplicatesRequest calls the generic FindNoteDuplicates builder with application/json body
func NewFindNoteDuplicatesRequest(server string, params *FindNoteDuplicatesParams, body FindNoteDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindNoteDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindNoteDuplicatesRequestWithBody generates requests for FindNoteDuplicates with any type of body
func NewFindNoteDuplicatesRequestWithBody(server string, params *FindNoteDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyNotesRequest calls the generic MergeManyNotes builder with application/json body
func NewMergeManyNotesRequest(server string, params *MergeManyNotesParams, body MergeManyNotesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyNotesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyNotesRequestWithBody generates requests for MergeManyNotes with any type of body
func NewMergeManyNotesRequestWithBody(server string, params *MergeManyNotesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneNoteRequest generates requests for DeleteOneNote
func NewDeleteOneNoteRequest(server string, id IdPath, params *DeleteOneNoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneNoteRequest generates requests for FindOneNote
func NewFindOneNoteRequest(server string, id IdPath, params *FindOneNoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneNoteRequest calls the generic UpdateOneNote builder with application/json body
func NewUpdateOneNoteRequest(server string, id IdPath, params *UpdateOneNoteParams, body UpdateOneNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneNoteRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneNoteRequestWithBody generates requests for UpdateOneNote with any type of body
func NewUpdateOneNoteRequestWithBody(server string, id IdPath, params *UpdateOneNoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenApiSchemaRequest generates requests for GetOpenApiSchema
func NewGetOpenApiSchemaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/open-api/core")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteManyOpportunitiesRequest generates requests for DeleteManyOpportunities
func NewDeleteManyOpportunitiesRequest(server string, params *DeleteManyOpportunitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyOpportunitiesRequest generates requests for FindManyOpportunities
func NewFindManyOpportunitiesRequest(server string, params *FindManyOpportunitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyOpportunitiesRequest calls the generic UpdateManyOpportunities builder with application/json body
func NewUpdateManyOpportunitiesRequest(server string, params *UpdateManyOpportunitiesParams, body UpdateManyOpportunitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyOpportunitiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyOpportunitiesRequestWithBody generates requests for UpdateManyOpportunities with any type of body
func NewUpdateManyOpportunitiesRequestWithBody(server string, params *UpdateManyOpportunitiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneOpportunityRequest calls the generic CreateOneOpportunity builder with application/json body
func NewCreateOneOpportunityRequest(server string, params *CreateOneOpportunityParams, body CreateOneOpportunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneOpportunityRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneOpportunityRequestWithBody generates requests for CreateOneOpportunity with any type of body
func NewCreateOneOpportunityRequestWithBody(server string, params *CreateOneOpportunityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindOpportunityDuplicatesRequest calls the generic FindOpportunityDuplicates builder with application/json body
func NewFindOpportunityDuplicatesRequest(server string, params *FindOpportunityDuplicatesParams, body FindOpportunityDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindOpportunityDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindOpportunityDuplicatesRequestWithBody generates requests for FindOpportunityDuplicates with any type of body
func NewFindOpportunityDuplicatesRequestWithBody(server string, params *FindOpportunityDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyOpportunitiesRequest calls the generic MergeManyOpportunities builder with application/json body
func NewMergeManyOpportunitiesRequest(server string, params *MergeManyOpportunitiesParams, body MergeManyOpportunitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyOpportunitiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyOpportunitiesRequestWithBody generates requests for MergeManyOpportunities with any type of body
func NewMergeManyOpportunitiesRequestWithBody(server string, params *MergeManyOpportunitiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneOpportunityRequest generates requests for DeleteOneOpportunity
func NewDeleteOneOpportunityRequest(server string, id IdPath, params *DeleteOneOpportunityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneOpportunityRequest generates requests for FindOneOpportunity
func NewFindOneOpportunityRequest(server string, id IdPath, params *FindOneOpportunityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneOpportunityRequest calls the generic UpdateOneOpportunity builder with application/json body
func NewUpdateOneOpportunityRequest(server string, id IdPath, params *UpdateOneOpportunityParams, body UpdateOneOpportunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneOpportunityRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneOpportunityRequestWithBody generates requests for UpdateOneOpportunity with any type of body
func NewUpdateOneOpportunityRequestWithBody(server string, id IdPath, params *UpdateOneOpportunityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/opportunities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyPeopleRequest generates requests for DeleteManyPeople
func NewDeleteManyPeopleRequest(server string, params *DeleteManyPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyPeopleRequest generates requests for FindManyPeople
func NewFindManyPeopleRequest(server string, params *FindManyPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyPeopleRequest calls the generic UpdateManyPeople builder with application/json body
func NewUpdateManyPeopleRequest(server string, params *UpdateManyPeopleParams, body UpdateManyPeopleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyPeopleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyPeopleRequestWithBody generates requests for UpdateManyPeople with any type of body
func NewUpdateManyPeopleRequestWithBody(server string, params *UpdateManyPeopleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOnePersonRequest calls the generic CreateOnePerson builder with application/json body
func NewCreateOnePersonRequest(server string, params *CreateOnePersonParams, body CreateOnePersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOnePersonRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOnePersonRequestWithBody generates requests for CreateOnePerson with any type of body
func NewCreateOnePersonRequestWithBody(server string, params *CreateOnePersonParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindPersonDuplicatesRequest calls the generic FindPersonDuplicates builder with application/json body
func NewFindPersonDuplicatesRequest(server string, params *FindPersonDuplicatesParams, body FindPersonDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindPersonDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindPersonDuplicatesRequestWithBody generates requests for FindPersonDuplicates with any type of body
func NewFindPersonDuplicatesRequestWithBody(server string, params *FindPersonDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyPeopleRequest calls the generic MergeManyPeople builder with application/json body
func NewMergeManyPeopleRequest(server string, params *MergeManyPeopleParams, body MergeManyPeopleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyPeopleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyPeopleRequestWithBody generates requests for MergeManyPeople with any type of body
func NewMergeManyPeopleRequestWithBody(server string, params *MergeManyPeopleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOnePersonRequest generates requests for DeleteOnePerson
func NewDeleteOnePersonRequest(server string, id IdPath, params *DeleteOnePersonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOnePersonRequest generates requests for FindOnePerson
func NewFindOnePersonRequest(server string, id IdPath, params *FindOnePersonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOnePersonRequest calls the generic UpdateOnePerson builder with application/json body
func NewUpdateOnePersonRequest(server string, id IdPath, params *UpdateOnePersonParams, body UpdateOnePersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOnePersonRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOnePersonRequestWithBody generates requests for UpdateOnePerson with any type of body
func NewUpdateOnePersonRequestWithBody(server string, id IdPath, params *UpdateOnePersonParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreManyAttachmentsRequest generates requests for RestoreManyAttachments
func NewRestoreManyAttachmentsRequest(server string, params *RestoreManyAttachmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneAttachmentRequest generates requests for RestoreOneAttachment
func NewRestoreOneAttachmentRequest(server string, id IdPath, params *RestoreOneAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyBlocklistsRequest generates requests for RestoreManyBlocklists
func NewRestoreManyBlocklistsRequest(server string, params *RestoreManyBlocklistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/blocklists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneBlocklistRequest generates requests for RestoreOneBlocklist
func NewRestoreOneBlocklistRequest(server string, id IdPath, params *RestoreOneBlocklistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/blocklists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyCalendarChannelEventAssociationsRequest generates requests for RestoreManyCalendarChannelEventAssociations
func NewRestoreManyCalendarChannelEventAssociationsRequest(server string, params *RestoreManyCalendarChannelEventAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarChannelEventAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneCalendarChannelEventAssociationRequest generates requests for RestoreOneCalendarChannelEventAssociation
func NewRestoreOneCalendarChannelEventAssociationRequest(server string, id IdPath, params *RestoreOneCalendarChannelEventAssociationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarChannelEventAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyCalendarChannelsRequest generates requests for RestoreManyCalendarChannels
func NewRestoreManyCalendarChannelsRequest(server string, params *RestoreManyCalendarChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneCalendarChannelRequest generates requests for RestoreOneCalendarChannel
func NewRestoreOneCalendarChannelRequest(server string, id IdPath, params *RestoreOneCalendarChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyCalendarEventParticipantsRequest generates requests for RestoreManyCalendarEventParticipants
func NewRestoreManyCalendarEventParticipantsRequest(server string, params *RestoreManyCalendarEventParticipantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarEventParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneCalendarEventParticipantRequest generates requests for RestoreOneCalendarEventParticipant
func NewRestoreOneCalendarEventParticipantRequest(server string, id IdPath, params *RestoreOneCalendarEventParticipantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarEventParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyCalendarEventsRequest generates requests for RestoreManyCalendarEvents
func NewRestoreManyCalendarEventsRequest(server string, params *RestoreManyCalendarEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarEvents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneCalendarEventRequest generates requests for RestoreOneCalendarEvent
func NewRestoreOneCalendarEventRequest(server string, id IdPath, params *RestoreOneCalendarEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/calendarEvents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyCompaniesRequest generates requests for RestoreManyCompanies
func NewRestoreManyCompaniesRequest(server string, params *RestoreManyCompaniesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneCompanyRequest generates requests for RestoreOneCompany
func NewRestoreOneCompanyRequest(server string, id IdPath, params *RestoreOneCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyConnectedAccountsRequest generates requests for RestoreManyConnectedAccounts
func NewRestoreManyConnectedAccountsRequest(server string, params *RestoreManyConnectedAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/connectedAccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneConnectedAccountRequest generates requests for RestoreOneConnectedAccount
func NewRestoreOneConnectedAccountRequest(server string, id IdPath, params *RestoreOneConnectedAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/connectedAccounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyDashboardsRequest generates requests for RestoreManyDashboards
func NewRestoreManyDashboardsRequest(server string, params *RestoreManyDashboardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneDashboardRequest generates requests for RestoreOneDashboard
func NewRestoreOneDashboardRequest(server string, id IdPath, params *RestoreOneDashboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyFavoriteFoldersRequest generates requests for RestoreManyFavoriteFolders
func NewRestoreManyFavoriteFoldersRequest(server string, params *RestoreManyFavoriteFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/favoriteFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneFavoriteFolderRequest generates requests for RestoreOneFavoriteFolder
func NewRestoreOneFavoriteFolderRequest(server string, id IdPath, params *RestoreOneFavoriteFolderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/favoriteFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyFavoritesRequest generates requests for RestoreManyFavorites
func NewRestoreManyFavoritesRequest(server string, params *RestoreManyFavoritesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneFavoriteRequest generates requests for RestoreOneFavorite
func NewRestoreOneFavoriteRequest(server string, id IdPath, params *RestoreOneFavoriteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/favorites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyMessageChannelMessageAssociationsRequest generates requests for RestoreManyMessageChannelMessageAssociations
func NewRestoreManyMessageChannelMessageAssociationsRequest(server string, params *RestoreManyMessageChannelMessageAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageChannelMessageAssociations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneMessageChannelMessageAssociationRequest generates requests for RestoreOneMessageChannelMessageAssociation
func NewRestoreOneMessageChannelMessageAssociationRequest(server string, id IdPath, params *RestoreOneMessageChannelMessageAssociationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageChannelMessageAssociations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyMessageChannelsRequest generates requests for RestoreManyMessageChannels
func NewRestoreManyMessageChannelsRequest(server string, params *RestoreManyMessageChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageChannels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneMessageChannelRequest generates requests for RestoreOneMessageChannel
func NewRestoreOneMessageChannelRequest(server string, id IdPath, params *RestoreOneMessageChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageChannels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyMessageFoldersRequest generates requests for RestoreManyMessageFolders
func NewRestoreManyMessageFoldersRequest(server string, params *RestoreManyMessageFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneMessageFolderRequest generates requests for RestoreOneMessageFolder
func NewRestoreOneMessageFolderRequest(server string, id IdPath, params *RestoreOneMessageFolderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageFolders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyMessageParticipantsRequest generates requests for RestoreManyMessageParticipants
func NewRestoreManyMessageParticipantsRequest(server string, params *RestoreManyMessageParticipantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageParticipants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneMessageParticipantRequest generates requests for RestoreOneMessageParticipant
func NewRestoreOneMessageParticipantRequest(server string, id IdPath, params *RestoreOneMessageParticipantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageParticipants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyMessageThreadsRequest generates requests for RestoreManyMessageThreads
func NewRestoreManyMessageThreadsRequest(server string, params *RestoreManyMessageThreadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageThreads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneMessageThreadRequest generates requests for RestoreOneMessageThread
func NewRestoreOneMessageThreadRequest(server string, id IdPath, params *RestoreOneMessageThreadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messageThreads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyMessagesRequest generates requests for RestoreManyMessages
func NewRestoreManyMessagesRequest(server string, params *RestoreManyMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneMessageRequest generates requests for RestoreOneMessage
func NewRestoreOneMessageRequest(server string, id IdPath, params *RestoreOneMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyNoteTargetsRequest generates requests for RestoreManyNoteTargets
func NewRestoreManyNoteTargetsRequest(server string, params *RestoreManyNoteTargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/noteTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneNoteTargetRequest generates requests for RestoreOneNoteTarget
func NewRestoreOneNoteTargetRequest(server string, id IdPath, params *RestoreOneNoteTargetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/noteTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyNotesRequest generates requests for RestoreManyNotes
func NewRestoreManyNotesRequest(server string, params *RestoreManyNotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneNoteRequest generates requests for RestoreOneNote
func NewRestoreOneNoteRequest(server string, id IdPath, params *RestoreOneNoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyOpportunitiesRequest generates requests for RestoreManyOpportunities
func NewRestoreManyOpportunitiesRequest(server string, params *RestoreManyOpportunitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/opportunities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneOpportunityRequest generates requests for RestoreOneOpportunity
func NewRestoreOneOpportunityRequest(server string, id IdPath, params *RestoreOneOpportunityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/opportunities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyPeopleRequest generates requests for RestoreManyPeople
func NewRestoreManyPeopleRequest(server string, params *RestoreManyPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOnePersonRequest generates requests for RestoreOnePerson
func NewRestoreOnePersonRequest(server string, id IdPath, params *RestoreOnePersonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/people/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyTaskTargetsRequest generates requests for RestoreManyTaskTargets
func NewRestoreManyTaskTargetsRequest(server string, params *RestoreManyTaskTargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/taskTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneTaskTargetRequest generates requests for RestoreOneTaskTarget
func NewRestoreOneTaskTargetRequest(server string, id IdPath, params *RestoreOneTaskTargetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/taskTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyTasksRequest generates requests for RestoreManyTasks
func NewRestoreManyTasksRequest(server string, params *RestoreManyTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneTaskRequest generates requests for RestoreOneTask
func NewRestoreOneTaskRequest(server string, id IdPath, params *RestoreOneTaskParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyTimelineActivitiesRequest generates requests for RestoreManyTimelineActivities
func NewRestoreManyTimelineActivitiesRequest(server string, params *RestoreManyTimelineActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/timelineActivities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneTimelineActivityRequest generates requests for RestoreOneTimelineActivity
func NewRestoreOneTimelineActivityRequest(server string, id IdPath, params *RestoreOneTimelineActivityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/timelineActivities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyWorkflowAutomatedTriggersRequest generates requests for RestoreManyWorkflowAutomatedTriggers
func NewRestoreManyWorkflowAutomatedTriggersRequest(server string, params *RestoreManyWorkflowAutomatedTriggersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflowAutomatedTriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneWorkflowAutomatedTriggerRequest generates requests for RestoreOneWorkflowAutomatedTrigger
func NewRestoreOneWorkflowAutomatedTriggerRequest(server string, id IdPath, params *RestoreOneWorkflowAutomatedTriggerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflowAutomatedTriggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyWorkflowRunsRequest generates requests for RestoreManyWorkflowRuns
func NewRestoreManyWorkflowRunsRequest(server string, params *RestoreManyWorkflowRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflowRuns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneWorkflowRunRequest generates requests for RestoreOneWorkflowRun
func NewRestoreOneWorkflowRunRequest(server string, id IdPath, params *RestoreOneWorkflowRunParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflowRuns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyWorkflowVersionsRequest generates requests for RestoreManyWorkflowVersions
func NewRestoreManyWorkflowVersionsRequest(server string, params *RestoreManyWorkflowVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflowVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneWorkflowVersionRequest generates requests for RestoreOneWorkflowVersion
func NewRestoreOneWorkflowVersionRequest(server string, id IdPath, params *RestoreOneWorkflowVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflowVersions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyWorkflowsRequest generates requests for RestoreManyWorkflows
func NewRestoreManyWorkflowsRequest(server string, params *RestoreManyWorkflowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneWorkflowRequest generates requests for RestoreOneWorkflow
func NewRestoreOneWorkflowRequest(server string, id IdPath, params *RestoreOneWorkflowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreManyWorkspaceMembersRequest generates requests for RestoreManyWorkspaceMembers
func NewRestoreManyWorkspaceMembersRequest(server string, params *RestoreManyWorkspaceMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workspaceMembers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreOneWorkspaceMemberRequest generates requests for RestoreOneWorkspaceMember
func NewRestoreOneWorkspaceMemberRequest(server string, id IdPath, params *RestoreOneWorkspaceMemberParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore/workspaceMembers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteManyTaskTargetsRequest generates requests for DeleteManyTaskTargets
func NewDeleteManyTaskTargetsRequest(server string, params *DeleteManyTaskTargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyTaskTargetsRequest generates requests for FindManyTaskTargets
func NewFindManyTaskTargetsRequest(server string, params *FindManyTaskTargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyTaskTargetsRequest calls the generic UpdateManyTaskTargets builder with application/json body
func NewUpdateManyTaskTargetsRequest(server string, params *UpdateManyTaskTargetsParams, body UpdateManyTaskTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyTaskTargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyTaskTargetsRequestWithBody generates requests for UpdateManyTaskTargets with any type of body
func NewUpdateManyTaskTargetsRequestWithBody(server string, params *UpdateManyTaskTargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneTaskTargetRequest calls the generic CreateOneTaskTarget builder with application/json body
func NewCreateOneTaskTargetRequest(server string, params *CreateOneTaskTargetParams, body CreateOneTaskTargetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneTaskTargetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneTaskTargetRequestWithBody generates requests for CreateOneTaskTarget with any type of body
func NewCreateOneTaskTargetRequestWithBody(server string, params *CreateOneTaskTargetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindTaskTargetDuplicatesRequest calls the generic FindTaskTargetDuplicates builder with application/json body
func NewFindTaskTargetDuplicatesRequest(server string, params *FindTaskTargetDuplicatesParams, body FindTaskTargetDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindTaskTargetDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindTaskTargetDuplicatesRequestWithBody generates requests for FindTaskTargetDuplicates with any type of body
func NewFindTaskTargetDuplicatesRequestWithBody(server string, params *FindTaskTargetDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyTaskTargetsRequest calls the generic MergeManyTaskTargets builder with application/json body
func NewMergeManyTaskTargetsRequest(server string, params *MergeManyTaskTargetsParams, body MergeManyTaskTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyTaskTargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyTaskTargetsRequestWithBody generates requests for MergeManyTaskTargets with any type of body
func NewMergeManyTaskTargetsRequestWithBody(server string, params *MergeManyTaskTargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneTaskTargetRequest generates requests for DeleteOneTaskTarget
func NewDeleteOneTaskTargetRequest(server string, id IdPath, params *DeleteOneTaskTargetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneTaskTargetRequest generates requests for FindOneTaskTarget
func NewFindOneTaskTargetRequest(server string, id IdPath, params *FindOneTaskTargetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneTaskTargetRequest calls the generic UpdateOneTaskTarget builder with application/json body
func NewUpdateOneTaskTargetRequest(server string, id IdPath, params *UpdateOneTaskTargetParams, body UpdateOneTaskTargetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneTaskTargetRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneTaskTargetRequestWithBody generates requests for UpdateOneTaskTarget with any type of body
func NewUpdateOneTaskTargetRequestWithBody(server string, id IdPath, params *UpdateOneTaskTargetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/taskTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyTasksRequest generates requests for DeleteManyTasks
func NewDeleteManyTasksRequest(server string, params *DeleteManyTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyTasksRequest generates requests for FindManyTasks
func NewFindManyTasksRequest(server string, params *FindManyTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyTasksRequest calls the generic UpdateManyTasks builder with application/json body
func NewUpdateManyTasksRequest(server string, params *UpdateManyTasksParams, body UpdateManyTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyTasksRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyTasksRequestWithBody generates requests for UpdateManyTasks with any type of body
func NewUpdateManyTasksRequestWithBody(server string, params *UpdateManyTasksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneTaskRequest calls the generic CreateOneTask builder with application/json body
func NewCreateOneTaskRequest(server string, params *CreateOneTaskParams, body CreateOneTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneTaskRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneTaskRequestWithBody generates requests for CreateOneTask with any type of body
func NewCreateOneTaskRequestWithBody(server string, params *CreateOneTaskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindTaskDuplicatesRequest calls the generic FindTaskDuplicates builder with application/json body
func NewFindTaskDuplicatesRequest(server string, params *FindTaskDuplicatesParams, body FindTaskDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindTaskDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindTaskDuplicatesRequestWithBody generates requests for FindTaskDuplicates with any type of body
func NewFindTaskDuplicatesRequestWithBody(server string, params *FindTaskDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyTasksRequest calls the generic MergeManyTasks builder with application/json body
func NewMergeManyTasksRequest(server string, params *MergeManyTasksParams, body MergeManyTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyTasksRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyTasksRequestWithBody generates requests for MergeManyTasks with any type of body
func NewMergeManyTasksRequestWithBody(server string, params *MergeManyTasksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneTaskRequest generates requests for DeleteOneTask
func NewDeleteOneTaskRequest(server string, id IdPath, params *DeleteOneTaskParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneTaskRequest generates requests for FindOneTask
func NewFindOneTaskRequest(server string, id IdPath, params *FindOneTaskParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneTaskRequest calls the generic UpdateOneTask builder with application/json body
func NewUpdateOneTaskRequest(server string, id IdPath, params *UpdateOneTaskParams, body UpdateOneTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneTaskRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneTaskRequestWithBody generates requests for UpdateOneTask with any type of body
func NewUpdateOneTaskRequestWithBody(server string, id IdPath, params *UpdateOneTaskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyTimelineActivitiesRequest generates requests for DeleteManyTimelineActivities
func NewDeleteManyTimelineActivitiesRequest(server string, params *DeleteManyTimelineActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyTimelineActivitiesRequest generates requests for FindManyTimelineActivities
func NewFindManyTimelineActivitiesRequest(server string, params *FindManyTimelineActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyTimelineActivitiesRequest calls the generic UpdateManyTimelineActivities builder with application/json body
func NewUpdateManyTimelineActivitiesRequest(server string, params *UpdateManyTimelineActivitiesParams, body UpdateManyTimelineActivitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyTimelineActivitiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyTimelineActivitiesRequestWithBody generates requests for UpdateManyTimelineActivities with any type of body
func NewUpdateManyTimelineActivitiesRequestWithBody(server string, params *UpdateManyTimelineActivitiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneTimelineActivityRequest calls the generic CreateOneTimelineActivity builder with application/json body
func NewCreateOneTimelineActivityRequest(server string, params *CreateOneTimelineActivityParams, body CreateOneTimelineActivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneTimelineActivityRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneTimelineActivityRequestWithBody generates requests for CreateOneTimelineActivity with any type of body
func NewCreateOneTimelineActivityRequestWithBody(server string, params *CreateOneTimelineActivityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindTimelineActivityDuplicatesRequest calls the generic FindTimelineActivityDuplicates builder with application/json body
func NewFindTimelineActivityDuplicatesRequest(server string, params *FindTimelineActivityDuplicatesParams, body FindTimelineActivityDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindTimelineActivityDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindTimelineActivityDuplicatesRequestWithBody generates requests for FindTimelineActivityDuplicates with any type of body
func NewFindTimelineActivityDuplicatesRequestWithBody(server string, params *FindTimelineActivityDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyTimelineActivitiesRequest calls the generic MergeManyTimelineActivities builder with application/json body
func NewMergeManyTimelineActivitiesRequest(server string, params *MergeManyTimelineActivitiesParams, body MergeManyTimelineActivitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyTimelineActivitiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyTimelineActivitiesRequestWithBody generates requests for MergeManyTimelineActivities with any type of body
func NewMergeManyTimelineActivitiesRequestWithBody(server string, params *MergeManyTimelineActivitiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneTimelineActivityRequest generates requests for DeleteOneTimelineActivity
func NewDeleteOneTimelineActivityRequest(server string, id IdPath, params *DeleteOneTimelineActivityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneTimelineActivityRequest generates requests for FindOneTimelineActivity
func NewFindOneTimelineActivityRequest(server string, id IdPath, params *FindOneTimelineActivityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneTimelineActivityRequest calls the generic UpdateOneTimelineActivity builder with application/json body
func NewUpdateOneTimelineActivityRequest(server string, id IdPath, params *UpdateOneTimelineActivityParams, body UpdateOneTimelineActivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneTimelineActivityRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneTimelineActivityRequestWithBody generates requests for UpdateOneTimelineActivity with any type of body
func NewUpdateOneTimelineActivityRequestWithBody(server string, id IdPath, params *UpdateOneTimelineActivityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timelineActivities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyWorkflowAutomatedTriggersRequest generates requests for DeleteManyWorkflowAutomatedTriggers
func NewDeleteManyWorkflowAutomatedTriggersRequest(server string, params *DeleteManyWorkflowAutomatedTriggersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyWorkflowAutomatedTriggersRequest generates requests for FindManyWorkflowAutomatedTriggers
func NewFindManyWorkflowAutomatedTriggersRequest(server string, params *FindManyWorkflowAutomatedTriggersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyWorkflowAutomatedTriggersRequest calls the generic UpdateManyWorkflowAutomatedTriggers builder with application/json body
func NewUpdateManyWorkflowAutomatedTriggersRequest(server string, params *UpdateManyWorkflowAutomatedTriggersParams, body UpdateManyWorkflowAutomatedTriggersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyWorkflowAutomatedTriggersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyWorkflowAutomatedTriggersRequestWithBody generates requests for UpdateManyWorkflowAutomatedTriggers with any type of body
func NewUpdateManyWorkflowAutomatedTriggersRequestWithBody(server string, params *UpdateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneWorkflowAutomatedTriggerRequest calls the generic CreateOneWorkflowAutomatedTrigger builder with application/json body
func NewCreateOneWorkflowAutomatedTriggerRequest(server string, params *CreateOneWorkflowAutomatedTriggerParams, body CreateOneWorkflowAutomatedTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneWorkflowAutomatedTriggerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneWorkflowAutomatedTriggerRequestWithBody generates requests for CreateOneWorkflowAutomatedTrigger with any type of body
func NewCreateOneWorkflowAutomatedTriggerRequestWithBody(server string, params *CreateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindWorkflowAutomatedTriggerDuplicatesRequest calls the generic FindWorkflowAutomatedTriggerDuplicates builder with application/json body
func NewFindWorkflowAutomatedTriggerDuplicatesRequest(server string, params *FindWorkflowAutomatedTriggerDuplicatesParams, body FindWorkflowAutomatedTriggerDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindWorkflowAutomatedTriggerDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindWorkflowAutomatedTriggerDuplicatesRequestWithBody generates requests for FindWorkflowAutomatedTriggerDuplicates with any type of body
func NewFindWorkflowAutomatedTriggerDuplicatesRequestWithBody(server string, params *FindWorkflowAutomatedTriggerDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyWorkflowAutomatedTriggersRequest calls the generic MergeManyWorkflowAutomatedTriggers builder with application/json body
func NewMergeManyWorkflowAutomatedTriggersRequest(server string, params *MergeManyWorkflowAutomatedTriggersParams, body MergeManyWorkflowAutomatedTriggersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyWorkflowAutomatedTriggersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyWorkflowAutomatedTriggersRequestWithBody generates requests for MergeManyWorkflowAutomatedTriggers with any type of body
func NewMergeManyWorkflowAutomatedTriggersRequestWithBody(server string, params *MergeManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneWorkflowAutomatedTriggerRequest generates requests for DeleteOneWorkflowAutomatedTrigger
func NewDeleteOneWorkflowAutomatedTriggerRequest(server string, id IdPath, params *DeleteOneWorkflowAutomatedTriggerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneWorkflowAutomatedTriggerRequest generates requests for FindOneWorkflowAutomatedTrigger
func NewFindOneWorkflowAutomatedTriggerRequest(server string, id IdPath, params *FindOneWorkflowAutomatedTriggerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneWorkflowAutomatedTriggerRequest calls the generic UpdateOneWorkflowAutomatedTrigger builder with application/json body
func NewUpdateOneWorkflowAutomatedTriggerRequest(server string, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, body UpdateOneWorkflowAutomatedTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneWorkflowAutomatedTriggerRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneWorkflowAutomatedTriggerRequestWithBody generates requests for UpdateOneWorkflowAutomatedTrigger with any type of body
func NewUpdateOneWorkflowAutomatedTriggerRequestWithBody(server string, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowAutomatedTriggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyWorkflowRunsRequest generates requests for DeleteManyWorkflowRuns
func NewDeleteManyWorkflowRunsRequest(server string, params *DeleteManyWorkflowRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyWorkflowRunsRequest generates requests for FindManyWorkflowRuns
func NewFindManyWorkflowRunsRequest(server string, params *FindManyWorkflowRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyWorkflowRunsRequest calls the generic UpdateManyWorkflowRuns builder with application/json body
func NewUpdateManyWorkflowRunsRequest(server string, params *UpdateManyWorkflowRunsParams, body UpdateManyWorkflowRunsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyWorkflowRunsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyWorkflowRunsRequestWithBody generates requests for UpdateManyWorkflowRuns with any type of body
func NewUpdateManyWorkflowRunsRequestWithBody(server string, params *UpdateManyWorkflowRunsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneWorkflowRunRequest calls the generic CreateOneWorkflowRun builder with application/json body
func NewCreateOneWorkflowRunRequest(server string, params *CreateOneWorkflowRunParams, body CreateOneWorkflowRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneWorkflowRunRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneWorkflowRunRequestWithBody generates requests for CreateOneWorkflowRun with any type of body
func NewCreateOneWorkflowRunRequestWithBody(server string, params *CreateOneWorkflowRunParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindWorkflowRunDuplicatesRequest calls the generic FindWorkflowRunDuplicates builder with application/json body
func NewFindWorkflowRunDuplicatesRequest(server string, params *FindWorkflowRunDuplicatesParams, body FindWorkflowRunDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindWorkflowRunDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindWorkflowRunDuplicatesRequestWithBody generates requests for FindWorkflowRunDuplicates with any type of body
func NewFindWorkflowRunDuplicatesRequestWithBody(server string, params *FindWorkflowRunDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyWorkflowRunsRequest calls the generic MergeManyWorkflowRuns builder with application/json body
func NewMergeManyWorkflowRunsRequest(server string, params *MergeManyWorkflowRunsParams, body MergeManyWorkflowRunsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyWorkflowRunsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyWorkflowRunsRequestWithBody generates requests for MergeManyWorkflowRuns with any type of body
func NewMergeManyWorkflowRunsRequestWithBody(server string, params *MergeManyWorkflowRunsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneWorkflowRunRequest generates requests for DeleteOneWorkflowRun
func NewDeleteOneWorkflowRunRequest(server string, id IdPath, params *DeleteOneWorkflowRunParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneWorkflowRunRequest generates requests for FindOneWorkflowRun
func NewFindOneWorkflowRunRequest(server string, id IdPath, params *FindOneWorkflowRunParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneWorkflowRunRequest calls the generic UpdateOneWorkflowRun builder with application/json body
func NewUpdateOneWorkflowRunRequest(server string, id IdPath, params *UpdateOneWorkflowRunParams, body UpdateOneWorkflowRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneWorkflowRunRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneWorkflowRunRequestWithBody generates requests for UpdateOneWorkflowRun with any type of body
func NewUpdateOneWorkflowRunRequestWithBody(server string, id IdPath, params *UpdateOneWorkflowRunParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowRuns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyWorkflowVersionsRequest generates requests for DeleteManyWorkflowVersions
func NewDeleteManyWorkflowVersionsRequest(server string, params *DeleteManyWorkflowVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyWorkflowVersionsRequest generates requests for FindManyWorkflowVersions
func NewFindManyWorkflowVersionsRequest(server string, params *FindManyWorkflowVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyWorkflowVersionsRequest calls the generic UpdateManyWorkflowVersions builder with application/json body
func NewUpdateManyWorkflowVersionsRequest(server string, params *UpdateManyWorkflowVersionsParams, body UpdateManyWorkflowVersionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyWorkflowVersionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyWorkflowVersionsRequestWithBody generates requests for UpdateManyWorkflowVersions with any type of body
func NewUpdateManyWorkflowVersionsRequestWithBody(server string, params *UpdateManyWorkflowVersionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneWorkflowVersionRequest calls the generic CreateOneWorkflowVersion builder with application/json body
func NewCreateOneWorkflowVersionRequest(server string, params *CreateOneWorkflowVersionParams, body CreateOneWorkflowVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneWorkflowVersionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneWorkflowVersionRequestWithBody generates requests for CreateOneWorkflowVersion with any type of body
func NewCreateOneWorkflowVersionRequestWithBody(server string, params *CreateOneWorkflowVersionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindWorkflowVersionDuplicatesRequest calls the generic FindWorkflowVersionDuplicates builder with application/json body
func NewFindWorkflowVersionDuplicatesRequest(server string, params *FindWorkflowVersionDuplicatesParams, body FindWorkflowVersionDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindWorkflowVersionDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindWorkflowVersionDuplicatesRequestWithBody generates requests for FindWorkflowVersionDuplicates with any type of body
func NewFindWorkflowVersionDuplicatesRequestWithBody(server string, params *FindWorkflowVersionDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyWorkflowVersionsRequest calls the generic MergeManyWorkflowVersions builder with application/json body
func NewMergeManyWorkflowVersionsRequest(server string, params *MergeManyWorkflowVersionsParams, body MergeManyWorkflowVersionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyWorkflowVersionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyWorkflowVersionsRequestWithBody generates requests for MergeManyWorkflowVersions with any type of body
func NewMergeManyWorkflowVersionsRequestWithBody(server string, params *MergeManyWorkflowVersionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneWorkflowVersionRequest generates requests for DeleteOneWorkflowVersion
func NewDeleteOneWorkflowVersionRequest(server string, id IdPath, params *DeleteOneWorkflowVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneWorkflowVersionRequest generates requests for FindOneWorkflowVersion
func NewFindOneWorkflowVersionRequest(server string, id IdPath, params *FindOneWorkflowVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneWorkflowVersionRequest calls the generic UpdateOneWorkflowVersion builder with application/json body
func NewUpdateOneWorkflowVersionRequest(server string, id IdPath, params *UpdateOneWorkflowVersionParams, body UpdateOneWorkflowVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneWorkflowVersionRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneWorkflowVersionRequestWithBody generates requests for UpdateOneWorkflowVersion with any type of body
func NewUpdateOneWorkflowVersionRequestWithBody(server string, id IdPath, params *UpdateOneWorkflowVersionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflowVersions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyWorkflowsRequest generates requests for DeleteManyWorkflows
func NewDeleteManyWorkflowsRequest(server string, params *DeleteManyWorkflowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyWorkflowsRequest generates requests for FindManyWorkflows
func NewFindManyWorkflowsRequest(server string, params *FindManyWorkflowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyWorkflowsRequest calls the generic UpdateManyWorkflows builder with application/json body
func NewUpdateManyWorkflowsRequest(server string, params *UpdateManyWorkflowsParams, body UpdateManyWorkflowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyWorkflowsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyWorkflowsRequestWithBody generates requests for UpdateManyWorkflows with any type of body
func NewUpdateManyWorkflowsRequestWithBody(server string, params *UpdateManyWorkflowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneWorkflowRequest calls the generic CreateOneWorkflow builder with application/json body
func NewCreateOneWorkflowRequest(server string, params *CreateOneWorkflowParams, body CreateOneWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneWorkflowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneWorkflowRequestWithBody generates requests for CreateOneWorkflow with any type of body
func NewCreateOneWorkflowRequestWithBody(server string, params *CreateOneWorkflowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindWorkflowDuplicatesRequest calls the generic FindWorkflowDuplicates builder with application/json body
func NewFindWorkflowDuplicatesRequest(server string, params *FindWorkflowDuplicatesParams, body FindWorkflowDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindWorkflowDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindWorkflowDuplicatesRequestWithBody generates requests for FindWorkflowDuplicates with any type of body
func NewFindWorkflowDuplicatesRequestWithBody(server string, params *FindWorkflowDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyWorkflowsRequest calls the generic MergeManyWorkflows builder with application/json body
func NewMergeManyWorkflowsRequest(server string, params *MergeManyWorkflowsParams, body MergeManyWorkflowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyWorkflowsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyWorkflowsRequestWithBody generates requests for MergeManyWorkflows with any type of body
func NewMergeManyWorkflowsRequestWithBody(server string, params *MergeManyWorkflowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneWorkflowRequest generates requests for DeleteOneWorkflow
func NewDeleteOneWorkflowRequest(server string, id IdPath, params *DeleteOneWorkflowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneWorkflowRequest generates requests for FindOneWorkflow
func NewFindOneWorkflowRequest(server string, id IdPath, params *FindOneWorkflowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneWorkflowRequest calls the generic UpdateOneWorkflow builder with application/json body
func NewUpdateOneWorkflowRequest(server string, id IdPath, params *UpdateOneWorkflowParams, body UpdateOneWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneWorkflowRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneWorkflowRequestWithBody generates requests for UpdateOneWorkflow with any type of body
func NewUpdateOneWorkflowRequestWithBody(server string, id IdPath, params *UpdateOneWorkflowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManyWorkspaceMembersRequest generates requests for DeleteManyWorkspaceMembers
func NewDeleteManyWorkspaceMembersRequest(server string, params *DeleteManyWorkspaceMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManyWorkspaceMembersRequest generates requests for FindManyWorkspaceMembers
func NewFindManyWorkspaceMembersRequest(server string, params *FindManyWorkspaceMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManyWorkspaceMembersRequest calls the generic UpdateManyWorkspaceMembers builder with application/json body
func NewUpdateManyWorkspaceMembersRequest(server string, params *UpdateManyWorkspaceMembersParams, body UpdateManyWorkspaceMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManyWorkspaceMembersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateManyWorkspaceMembersRequestWithBody generates requests for UpdateManyWorkspaceMembers with any type of body
func NewUpdateManyWorkspaceMembersRequestWithBody(server string, params *UpdateManyWorkspaceMembersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOneWorkspaceMemberRequest calls the generic CreateOneWorkspaceMember builder with application/json body
func NewCreateOneWorkspaceMemberRequest(server string, params *CreateOneWorkspaceMemberParams, body CreateOneWorkspaceMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOneWorkspaceMemberRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOneWorkspaceMemberRequestWithBody generates requests for CreateOneWorkspaceMember with any type of body
func NewCreateOneWorkspaceMemberRequestWithBody(server string, params *CreateOneWorkspaceMemberParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upsert != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upsert", runtime.ParamLocationQuery, *params.Upsert); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindWorkspaceMemberDuplicatesRequest calls the generic FindWorkspaceMemberDuplicates builder with application/json body
func NewFindWorkspaceMemberDuplicatesRequest(server string, params *FindWorkspaceMemberDuplicatesParams, body FindWorkspaceMemberDuplicatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindWorkspaceMemberDuplicatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFindWorkspaceMemberDuplicatesRequestWithBody generates requests for FindWorkspaceMemberDuplicates with any type of body
func NewFindWorkspaceMemberDuplicatesRequestWithBody(server string, params *FindWorkspaceMemberDuplicatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers/duplicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMergeManyWorkspaceMembersRequest calls the generic MergeManyWorkspaceMembers builder with application/json body
func NewMergeManyWorkspaceMembersRequest(server string, params *MergeManyWorkspaceMembersParams, body MergeManyWorkspaceMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeManyWorkspaceMembersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMergeManyWorkspaceMembersRequestWithBody generates requests for MergeManyWorkspaceMembers with any type of body
func NewMergeManyWorkspaceMembersRequestWithBody(server string, params *MergeManyWorkspaceMembersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers/merge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOneWorkspaceMemberRequest generates requests for DeleteOneWorkspaceMember
func NewDeleteOneWorkspaceMemberRequest(server string, id IdPath, params *DeleteOneWorkspaceMemberParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "soft_delete", runtime.ParamLocationQuery, *params.SoftDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOneWorkspaceMemberRequest generates requests for FindOneWorkspaceMember
func NewFindOneWorkspaceMemberRequest(server string, id IdPath, params *FindOneWorkspaceMemberParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOneWorkspaceMemberRequest calls the generic UpdateOneWorkspaceMember builder with application/json body
func NewUpdateOneWorkspaceMemberRequest(server string, id IdPath, params *UpdateOneWorkspaceMemberParams, body UpdateOneWorkspaceMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOneWorkspaceMemberRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateOneWorkspaceMemberRequestWithBody generates requests for UpdateOneWorkspaceMember with any type of body
func NewUpdateOneWorkspaceMemberRequestWithBody(server string, id IdPath, params *UpdateOneWorkspaceMemberParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaceMembers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteManyAttachmentsWithResponse request
	DeleteManyAttachmentsWithResponse(ctx context.Context, params *DeleteManyAttachmentsParams, reqEditors ...RequestEditorFn) (*DeleteManyAttachmentsResponse, error)

	// FindManyAttachmentsWithResponse request
	FindManyAttachmentsWithResponse(ctx context.Context, params *FindManyAttachmentsParams, reqEditors ...RequestEditorFn) (*FindManyAttachmentsResponse, error)

	// UpdateManyAttachmentsWithBodyWithResponse request with any body
	UpdateManyAttachmentsWithBodyWithResponse(ctx context.Context, params *UpdateManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyAttachmentsResponse, error)

	UpdateManyAttachmentsWithResponse(ctx context.Context, params *UpdateManyAttachmentsParams, body UpdateManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyAttachmentsResponse, error)

	// CreateOneAttachmentWithBodyWithResponse request with any body
	CreateOneAttachmentWithBodyWithResponse(ctx context.Context, params *CreateOneAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneAttachmentResponse, error)

	CreateOneAttachmentWithResponse(ctx context.Context, params *CreateOneAttachmentParams, body CreateOneAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneAttachmentResponse, error)

	// FindAttachmentDuplicatesWithBodyWithResponse request with any body
	FindAttachmentDuplicatesWithBodyWithResponse(ctx context.Context, params *FindAttachmentDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindAttachmentDuplicatesResponse, error)

	FindAttachmentDuplicatesWithResponse(ctx context.Context, params *FindAttachmentDuplicatesParams, body FindAttachmentDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindAttachmentDuplicatesResponse, error)

	// MergeManyAttachmentsWithBodyWithResponse request with any body
	MergeManyAttachmentsWithBodyWithResponse(ctx context.Context, params *MergeManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyAttachmentsResponse, error)

	MergeManyAttachmentsWithResponse(ctx context.Context, params *MergeManyAttachmentsParams, body MergeManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyAttachmentsResponse, error)

	// DeleteOneAttachmentWithResponse request
	DeleteOneAttachmentWithResponse(ctx context.Context, id IdPath, params *DeleteOneAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteOneAttachmentResponse, error)

	// FindOneAttachmentWithResponse request
	FindOneAttachmentWithResponse(ctx context.Context, id IdPath, params *FindOneAttachmentParams, reqEditors ...RequestEditorFn) (*FindOneAttachmentResponse, error)

	// UpdateOneAttachmentWithBodyWithResponse request with any body
	UpdateOneAttachmentWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneAttachmentResponse, error)

	UpdateOneAttachmentWithResponse(ctx context.Context, id IdPath, params *UpdateOneAttachmentParams, body UpdateOneAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneAttachmentResponse, error)

	// CreateManyAttachmentsWithBodyWithResponse request with any body
	CreateManyAttachmentsWithBodyWithResponse(ctx context.Context, params *CreateManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyAttachmentsResponse, error)

	CreateManyAttachmentsWithResponse(ctx context.Context, params *CreateManyAttachmentsParams, body CreateManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyAttachmentsResponse, error)

	// CreateManyBlocklistsWithBodyWithResponse request with any body
	CreateManyBlocklistsWithBodyWithResponse(ctx context.Context, params *CreateManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyBlocklistsResponse, error)

	CreateManyBlocklistsWithResponse(ctx context.Context, params *CreateManyBlocklistsParams, body CreateManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyBlocklistsResponse, error)

	// CreateManyCalendarChannelEventAssociationsWithBodyWithResponse request with any body
	CreateManyCalendarChannelEventAssociationsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelEventAssociationsResponse, error)

	CreateManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *CreateManyCalendarChannelEventAssociationsParams, body CreateManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelEventAssociationsResponse, error)

	// CreateManyCalendarChannelsWithBodyWithResponse request with any body
	CreateManyCalendarChannelsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelsResponse, error)

	CreateManyCalendarChannelsWithResponse(ctx context.Context, params *CreateManyCalendarChannelsParams, body CreateManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelsResponse, error)

	// CreateManyCalendarEventParticipantsWithBodyWithResponse request with any body
	CreateManyCalendarEventParticipantsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventParticipantsResponse, error)

	CreateManyCalendarEventParticipantsWithResponse(ctx context.Context, params *CreateManyCalendarEventParticipantsParams, body CreateManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventParticipantsResponse, error)

	// CreateManyCalendarEventsWithBodyWithResponse request with any body
	CreateManyCalendarEventsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventsResponse, error)

	CreateManyCalendarEventsWithResponse(ctx context.Context, params *CreateManyCalendarEventsParams, body CreateManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventsResponse, error)

	// CreateManyCompaniesWithBodyWithResponse request with any body
	CreateManyCompaniesWithBodyWithResponse(ctx context.Context, params *CreateManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCompaniesResponse, error)

	CreateManyCompaniesWithResponse(ctx context.Context, params *CreateManyCompaniesParams, body CreateManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCompaniesResponse, error)

	// CreateManyConnectedAccountsWithBodyWithResponse request with any body
	CreateManyConnectedAccountsWithBodyWithResponse(ctx context.Context, params *CreateManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyConnectedAccountsResponse, error)

	CreateManyConnectedAccountsWithResponse(ctx context.Context, params *CreateManyConnectedAccountsParams, body CreateManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyConnectedAccountsResponse, error)

	// CreateManyDashboardsWithBodyWithResponse request with any body
	CreateManyDashboardsWithBodyWithResponse(ctx context.Context, params *CreateManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyDashboardsResponse, error)

	CreateManyDashboardsWithResponse(ctx context.Context, params *CreateManyDashboardsParams, body CreateManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyDashboardsResponse, error)

	// CreateManyFavoriteFoldersWithBodyWithResponse request with any body
	CreateManyFavoriteFoldersWithBodyWithResponse(ctx context.Context, params *CreateManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyFavoriteFoldersResponse, error)

	CreateManyFavoriteFoldersWithResponse(ctx context.Context, params *CreateManyFavoriteFoldersParams, body CreateManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyFavoriteFoldersResponse, error)

	// CreateManyFavoritesWithBodyWithResponse request with any body
	CreateManyFavoritesWithBodyWithResponse(ctx context.Context, params *CreateManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyFavoritesResponse, error)

	CreateManyFavoritesWithResponse(ctx context.Context, params *CreateManyFavoritesParams, body CreateManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyFavoritesResponse, error)

	// CreateManyMessageChannelMessageAssociationsWithBodyWithResponse request with any body
	CreateManyMessageChannelMessageAssociationsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelMessageAssociationsResponse, error)

	CreateManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *CreateManyMessageChannelMessageAssociationsParams, body CreateManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelMessageAssociationsResponse, error)

	// CreateManyMessageChannelsWithBodyWithResponse request with any body
	CreateManyMessageChannelsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelsResponse, error)

	CreateManyMessageChannelsWithResponse(ctx context.Context, params *CreateManyMessageChannelsParams, body CreateManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelsResponse, error)

	// CreateManyMessageFoldersWithBodyWithResponse request with any body
	CreateManyMessageFoldersWithBodyWithResponse(ctx context.Context, params *CreateManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageFoldersResponse, error)

	CreateManyMessageFoldersWithResponse(ctx context.Context, params *CreateManyMessageFoldersParams, body CreateManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageFoldersResponse, error)

	// CreateManyMessageParticipantsWithBodyWithResponse request with any body
	CreateManyMessageParticipantsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageParticipantsResponse, error)

	CreateManyMessageParticipantsWithResponse(ctx context.Context, params *CreateManyMessageParticipantsParams, body CreateManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageParticipantsResponse, error)

	// CreateManyMessageThreadsWithBodyWithResponse request with any body
	CreateManyMessageThreadsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageThreadsResponse, error)

	CreateManyMessageThreadsWithResponse(ctx context.Context, params *CreateManyMessageThreadsParams, body CreateManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageThreadsResponse, error)

	// CreateManyMessagesWithBodyWithResponse request with any body
	CreateManyMessagesWithBodyWithResponse(ctx context.Context, params *CreateManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessagesResponse, error)

	CreateManyMessagesWithResponse(ctx context.Context, params *CreateManyMessagesParams, body CreateManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessagesResponse, error)

	// CreateManyNoteTargetsWithBodyWithResponse request with any body
	CreateManyNoteTargetsWithBodyWithResponse(ctx context.Context, params *CreateManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyNoteTargetsResponse, error)

	CreateManyNoteTargetsWithResponse(ctx context.Context, params *CreateManyNoteTargetsParams, body CreateManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyNoteTargetsResponse, error)

	// CreateManyNotesWithBodyWithResponse request with any body
	CreateManyNotesWithBodyWithResponse(ctx context.Context, params *CreateManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyNotesResponse, error)

	CreateManyNotesWithResponse(ctx context.Context, params *CreateManyNotesParams, body CreateManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyNotesResponse, error)

	// CreateManyOpportunitiesWithBodyWithResponse request with any body
	CreateManyOpportunitiesWithBodyWithResponse(ctx context.Context, params *CreateManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyOpportunitiesResponse, error)

	CreateManyOpportunitiesWithResponse(ctx context.Context, params *CreateManyOpportunitiesParams, body CreateManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyOpportunitiesResponse, error)

	// CreateManyPeopleWithBodyWithResponse request with any body
	CreateManyPeopleWithBodyWithResponse(ctx context.Context, params *CreateManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyPeopleResponse, error)

	CreateManyPeopleWithResponse(ctx context.Context, params *CreateManyPeopleParams, body CreateManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyPeopleResponse, error)

	// CreateManyTaskTargetsWithBodyWithResponse request with any body
	CreateManyTaskTargetsWithBodyWithResponse(ctx context.Context, params *CreateManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyTaskTargetsResponse, error)

	CreateManyTaskTargetsWithResponse(ctx context.Context, params *CreateManyTaskTargetsParams, body CreateManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyTaskTargetsResponse, error)

	// CreateManyTasksWithBodyWithResponse request with any body
	CreateManyTasksWithBodyWithResponse(ctx context.Context, params *CreateManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyTasksResponse, error)

	CreateManyTasksWithResponse(ctx context.Context, params *CreateManyTasksParams, body CreateManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyTasksResponse, error)

	// CreateManyTimelineActivitiesWithBodyWithResponse request with any body
	CreateManyTimelineActivitiesWithBodyWithResponse(ctx context.Context, params *CreateManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyTimelineActivitiesResponse, error)

	CreateManyTimelineActivitiesWithResponse(ctx context.Context, params *CreateManyTimelineActivitiesParams, body CreateManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyTimelineActivitiesResponse, error)

	// CreateManyWorkflowAutomatedTriggersWithBodyWithResponse request with any body
	CreateManyWorkflowAutomatedTriggersWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowAutomatedTriggersResponse, error)

	CreateManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *CreateManyWorkflowAutomatedTriggersParams, body CreateManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowAutomatedTriggersResponse, error)

	// CreateManyWorkflowRunsWithBodyWithResponse request with any body
	CreateManyWorkflowRunsWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowRunsResponse, error)

	CreateManyWorkflowRunsWithResponse(ctx context.Context, params *CreateManyWorkflowRunsParams, body CreateManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowRunsResponse, error)

	// CreateManyWorkflowVersionsWithBodyWithResponse request with any body
	CreateManyWorkflowVersionsWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowVersionsResponse, error)

	CreateManyWorkflowVersionsWithResponse(ctx context.Context, params *CreateManyWorkflowVersionsParams, body CreateManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowVersionsResponse, error)

	// CreateManyWorkflowsWithBodyWithResponse request with any body
	CreateManyWorkflowsWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowsResponse, error)

	CreateManyWorkflowsWithResponse(ctx context.Context, params *CreateManyWorkflowsParams, body CreateManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowsResponse, error)

	// CreateManyWorkspaceMembersWithBodyWithResponse request with any body
	CreateManyWorkspaceMembersWithBodyWithResponse(ctx context.Context, params *CreateManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkspaceMembersResponse, error)

	CreateManyWorkspaceMembersWithResponse(ctx context.Context, params *CreateManyWorkspaceMembersParams, body CreateManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkspaceMembersResponse, error)

	// DeleteManyBlocklistsWithResponse request
	DeleteManyBlocklistsWithResponse(ctx context.Context, params *DeleteManyBlocklistsParams, reqEditors ...RequestEditorFn) (*DeleteManyBlocklistsResponse, error)

	// FindManyBlocklistsWithResponse request
	FindManyBlocklistsWithResponse(ctx context.Context, params *FindManyBlocklistsParams, reqEditors ...RequestEditorFn) (*FindManyBlocklistsResponse, error)

	// UpdateManyBlocklistsWithBodyWithResponse request with any body
	UpdateManyBlocklistsWithBodyWithResponse(ctx context.Context, params *UpdateManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyBlocklistsResponse, error)

	UpdateManyBlocklistsWithResponse(ctx context.Context, params *UpdateManyBlocklistsParams, body UpdateManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyBlocklistsResponse, error)

	// CreateOneBlocklistWithBodyWithResponse request with any body
	CreateOneBlocklistWithBodyWithResponse(ctx context.Context, params *CreateOneBlocklistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneBlocklistResponse, error)

	CreateOneBlocklistWithResponse(ctx context.Context, params *CreateOneBlocklistParams, body CreateOneBlocklistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneBlocklistResponse, error)

	// FindBlocklistDuplicatesWithBodyWithResponse request with any body
	FindBlocklistDuplicatesWithBodyWithResponse(ctx context.Context, params *FindBlocklistDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindBlocklistDuplicatesResponse, error)

	FindBlocklistDuplicatesWithResponse(ctx context.Context, params *FindBlocklistDuplicatesParams, body FindBlocklistDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindBlocklistDuplicatesResponse, error)

	// MergeManyBlocklistsWithBodyWithResponse request with any body
	MergeManyBlocklistsWithBodyWithResponse(ctx context.Context, params *MergeManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyBlocklistsResponse, error)

	MergeManyBlocklistsWithResponse(ctx context.Context, params *MergeManyBlocklistsParams, body MergeManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyBlocklistsResponse, error)

	// DeleteOneBlocklistWithResponse request
	DeleteOneBlocklistWithResponse(ctx context.Context, id IdPath, params *DeleteOneBlocklistParams, reqEditors ...RequestEditorFn) (*DeleteOneBlocklistResponse, error)

	// FindOneBlocklistWithResponse request
	FindOneBlocklistWithResponse(ctx context.Context, id IdPath, params *FindOneBlocklistParams, reqEditors ...RequestEditorFn) (*FindOneBlocklistResponse, error)

	// UpdateOneBlocklistWithBodyWithResponse request with any body
	UpdateOneBlocklistWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneBlocklistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneBlocklistResponse, error)

	UpdateOneBlocklistWithResponse(ctx context.Context, id IdPath, params *UpdateOneBlocklistParams, body UpdateOneBlocklistJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneBlocklistResponse, error)

	// DeleteManyCalendarChannelEventAssociationsWithResponse request
	DeleteManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *DeleteManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarChannelEventAssociationsResponse, error)

	// FindManyCalendarChannelEventAssociationsWithResponse request
	FindManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *FindManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarChannelEventAssociationsResponse, error)

	// UpdateManyCalendarChannelEventAssociationsWithBodyWithResponse request with any body
	UpdateManyCalendarChannelEventAssociationsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelEventAssociationsResponse, error)

	UpdateManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *UpdateManyCalendarChannelEventAssociationsParams, body UpdateManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelEventAssociationsResponse, error)

	// CreateOneCalendarChannelEventAssociationWithBodyWithResponse request with any body
	CreateOneCalendarChannelEventAssociationWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelEventAssociationResponse, error)

	CreateOneCalendarChannelEventAssociationWithResponse(ctx context.Context, params *CreateOneCalendarChannelEventAssociationParams, body CreateOneCalendarChannelEventAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelEventAssociationResponse, error)

	// FindCalendarChannelEventAssociationDuplicatesWithBodyWithResponse request with any body
	FindCalendarChannelEventAssociationDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarChannelEventAssociationDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarChannelEventAssociationDuplicatesResponse, error)

	FindCalendarChannelEventAssociationDuplicatesWithResponse(ctx context.Context, params *FindCalendarChannelEventAssociationDuplicatesParams, body FindCalendarChannelEventAssociationDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarChannelEventAssociationDuplicatesResponse, error)

	// MergeManyCalendarChannelEventAssociationsWithBodyWithResponse request with any body
	MergeManyCalendarChannelEventAssociationsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelEventAssociationsResponse, error)

	MergeManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *MergeManyCalendarChannelEventAssociationsParams, body MergeManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelEventAssociationsResponse, error)

	// DeleteOneCalendarChannelEventAssociationWithResponse request
	DeleteOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarChannelEventAssociationResponse, error)

	// FindOneCalendarChannelEventAssociationWithResponse request
	FindOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*FindOneCalendarChannelEventAssociationResponse, error)

	// UpdateOneCalendarChannelEventAssociationWithBodyWithResponse request with any body
	UpdateOneCalendarChannelEventAssociationWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelEventAssociationResponse, error)

	UpdateOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, body UpdateOneCalendarChannelEventAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelEventAssociationResponse, error)

	// DeleteManyCalendarChannelsWithResponse request
	DeleteManyCalendarChannelsWithResponse(ctx context.Context, params *DeleteManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarChannelsResponse, error)

	// FindManyCalendarChannelsWithResponse request
	FindManyCalendarChannelsWithResponse(ctx context.Context, params *FindManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarChannelsResponse, error)

	// UpdateManyCalendarChannelsWithBodyWithResponse request with any body
	UpdateManyCalendarChannelsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelsResponse, error)

	UpdateManyCalendarChannelsWithResponse(ctx context.Context, params *UpdateManyCalendarChannelsParams, body UpdateManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelsResponse, error)

	// CreateOneCalendarChannelWithBodyWithResponse request with any body
	CreateOneCalendarChannelWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelResponse, error)

	CreateOneCalendarChannelWithResponse(ctx context.Context, params *CreateOneCalendarChannelParams, body CreateOneCalendarChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelResponse, error)

	// FindCalendarChannelDuplicatesWithBodyWithResponse request with any body
	FindCalendarChannelDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarChannelDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarChannelDuplicatesResponse, error)

	FindCalendarChannelDuplicatesWithResponse(ctx context.Context, params *FindCalendarChannelDuplicatesParams, body FindCalendarChannelDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarChannelDuplicatesResponse, error)

	// MergeManyCalendarChannelsWithBodyWithResponse request with any body
	MergeManyCalendarChannelsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelsResponse, error)

	MergeManyCalendarChannelsWithResponse(ctx context.Context, params *MergeManyCalendarChannelsParams, body MergeManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelsResponse, error)

	// DeleteOneCalendarChannelWithResponse request
	DeleteOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarChannelResponse, error)

	// FindOneCalendarChannelWithResponse request
	FindOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*FindOneCalendarChannelResponse, error)

	// UpdateOneCalendarChannelWithBodyWithResponse request with any body
	UpdateOneCalendarChannelWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelResponse, error)

	UpdateOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelParams, body UpdateOneCalendarChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelResponse, error)

	// DeleteManyCalendarEventParticipantsWithResponse request
	DeleteManyCalendarEventParticipantsWithResponse(ctx context.Context, params *DeleteManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarEventParticipantsResponse, error)

	// FindManyCalendarEventParticipantsWithResponse request
	FindManyCalendarEventParticipantsWithResponse(ctx context.Context, params *FindManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarEventParticipantsResponse, error)

	// UpdateManyCalendarEventParticipantsWithBodyWithResponse request with any body
	UpdateManyCalendarEventParticipantsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventParticipantsResponse, error)

	UpdateManyCalendarEventParticipantsWithResponse(ctx context.Context, params *UpdateManyCalendarEventParticipantsParams, body UpdateManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventParticipantsResponse, error)

	// CreateOneCalendarEventParticipantWithBodyWithResponse request with any body
	CreateOneCalendarEventParticipantWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarEventParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventParticipantResponse, error)

	CreateOneCalendarEventParticipantWithResponse(ctx context.Context, params *CreateOneCalendarEventParticipantParams, body CreateOneCalendarEventParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventParticipantResponse, error)

	// FindCalendarEventParticipantDuplicatesWithBodyWithResponse request with any body
	FindCalendarEventParticipantDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarEventParticipantDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarEventParticipantDuplicatesResponse, error)

	FindCalendarEventParticipantDuplicatesWithResponse(ctx context.Context, params *FindCalendarEventParticipantDuplicatesParams, body FindCalendarEventParticipantDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarEventParticipantDuplicatesResponse, error)

	// MergeManyCalendarEventParticipantsWithBodyWithResponse request with any body
	MergeManyCalendarEventParticipantsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventParticipantsResponse, error)

	MergeManyCalendarEventParticipantsWithResponse(ctx context.Context, params *MergeManyCalendarEventParticipantsParams, body MergeManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventParticipantsResponse, error)

	// DeleteOneCalendarEventParticipantWithResponse request
	DeleteOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarEventParticipantResponse, error)

	// FindOneCalendarEventParticipantWithResponse request
	FindOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*FindOneCalendarEventParticipantResponse, error)

	// UpdateOneCalendarEventParticipantWithBodyWithResponse request with any body
	UpdateOneCalendarEventParticipantWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventParticipantResponse, error)

	UpdateOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParticipantParams, body UpdateOneCalendarEventParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventParticipantResponse, error)

	// DeleteManyCalendarEventsWithResponse request
	DeleteManyCalendarEventsWithResponse(ctx context.Context, params *DeleteManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarEventsResponse, error)

	// FindManyCalendarEventsWithResponse request
	FindManyCalendarEventsWithResponse(ctx context.Context, params *FindManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarEventsResponse, error)

	// UpdateManyCalendarEventsWithBodyWithResponse request with any body
	UpdateManyCalendarEventsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventsResponse, error)

	UpdateManyCalendarEventsWithResponse(ctx context.Context, params *UpdateManyCalendarEventsParams, body UpdateManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventsResponse, error)

	// CreateOneCalendarEventWithBodyWithResponse request with any body
	CreateOneCalendarEventWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventResponse, error)

	CreateOneCalendarEventWithResponse(ctx context.Context, params *CreateOneCalendarEventParams, body CreateOneCalendarEventJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventResponse, error)

	// FindCalendarEventDuplicatesWithBodyWithResponse request with any body
	FindCalendarEventDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarEventDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarEventDuplicatesResponse, error)

	FindCalendarEventDuplicatesWithResponse(ctx context.Context, params *FindCalendarEventDuplicatesParams, body FindCalendarEventDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarEventDuplicatesResponse, error)

	// MergeManyCalendarEventsWithBodyWithResponse request with any body
	MergeManyCalendarEventsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventsResponse, error)

	MergeManyCalendarEventsWithResponse(ctx context.Context, params *MergeManyCalendarEventsParams, body MergeManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventsResponse, error)

	// DeleteOneCalendarEventWithResponse request
	DeleteOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarEventParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarEventResponse, error)

	// FindOneCalendarEventWithResponse request
	FindOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarEventParams, reqEditors ...RequestEditorFn) (*FindOneCalendarEventResponse, error)

	// UpdateOneCalendarEventWithBodyWithResponse request with any body
	UpdateOneCalendarEventWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventResponse, error)

	UpdateOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParams, body UpdateOneCalendarEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventResponse, error)

	// DeleteManyCompaniesWithResponse request
	DeleteManyCompaniesWithResponse(ctx context.Context, params *DeleteManyCompaniesParams, reqEditors ...RequestEditorFn) (*DeleteManyCompaniesResponse, error)

	// FindManyCompaniesWithResponse request
	FindManyCompaniesWithResponse(ctx context.Context, params *FindManyCompaniesParams, reqEditors ...RequestEditorFn) (*FindManyCompaniesResponse, error)

	// UpdateManyCompaniesWithBodyWithResponse request with any body
	UpdateManyCompaniesWithBodyWithResponse(ctx context.Context, params *UpdateManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCompaniesResponse, error)

	UpdateManyCompaniesWithResponse(ctx context.Context, params *UpdateManyCompaniesParams, body UpdateManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCompaniesResponse, error)

	// CreateOneCompanyWithBodyWithResponse request with any body
	CreateOneCompanyWithBodyWithResponse(ctx context.Context, params *CreateOneCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCompanyResponse, error)

	CreateOneCompanyWithResponse(ctx context.Context, params *CreateOneCompanyParams, body CreateOneCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCompanyResponse, error)

	// FindCompanyDuplicatesWithBodyWithResponse request with any body
	FindCompanyDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCompanyDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCompanyDuplicatesResponse, error)

	FindCompanyDuplicatesWithResponse(ctx context.Context, params *FindCompanyDuplicatesParams, body FindCompanyDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCompanyDuplicatesResponse, error)

	// MergeManyCompaniesWithBodyWithResponse request with any body
	MergeManyCompaniesWithBodyWithResponse(ctx context.Context, params *MergeManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCompaniesResponse, error)

	MergeManyCompaniesWithResponse(ctx context.Context, params *MergeManyCompaniesParams, body MergeManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCompaniesResponse, error)

	// DeleteOneCompanyWithResponse request
	DeleteOneCompanyWithResponse(ctx context.Context, id IdPath, params *DeleteOneCompanyParams, reqEditors ...RequestEditorFn) (*DeleteOneCompanyResponse, error)

	// FindOneCompanyWithResponse request
	FindOneCompanyWithResponse(ctx context.Context, id IdPath, params *FindOneCompanyParams, reqEditors ...RequestEditorFn) (*FindOneCompanyResponse, error)

	// UpdateOneCompanyWithBodyWithResponse request with any body
	UpdateOneCompanyWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCompanyResponse, error)

	UpdateOneCompanyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCompanyParams, body UpdateOneCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCompanyResponse, error)

	// DeleteManyConnectedAccountsWithResponse request
	DeleteManyConnectedAccountsWithResponse(ctx context.Context, params *DeleteManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*DeleteManyConnectedAccountsResponse, error)

	// FindManyConnectedAccountsWithResponse request
	FindManyConnectedAccountsWithResponse(ctx context.Context, params *FindManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*FindManyConnectedAccountsResponse, error)

	// UpdateManyConnectedAccountsWithBodyWithResponse request with any body
	UpdateManyConnectedAccountsWithBodyWithResponse(ctx context.Context, params *UpdateManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyConnectedAccountsResponse, error)

	UpdateManyConnectedAccountsWithResponse(ctx context.Context, params *UpdateManyConnectedAccountsParams, body UpdateManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyConnectedAccountsResponse, error)

	// CreateOneConnectedAccountWithBodyWithResponse request with any body
	CreateOneConnectedAccountWithBodyWithResponse(ctx context.Context, params *CreateOneConnectedAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneConnectedAccountResponse, error)

	CreateOneConnectedAccountWithResponse(ctx context.Context, params *CreateOneConnectedAccountParams, body CreateOneConnectedAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneConnectedAccountResponse, error)

	// FindConnectedAccountDuplicatesWithBodyWithResponse request with any body
	FindConnectedAccountDuplicatesWithBodyWithResponse(ctx context.Context, params *FindConnectedAccountDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindConnectedAccountDuplicatesResponse, error)

	FindConnectedAccountDuplicatesWithResponse(ctx context.Context, params *FindConnectedAccountDuplicatesParams, body FindConnectedAccountDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindConnectedAccountDuplicatesResponse, error)

	// MergeManyConnectedAccountsWithBodyWithResponse request with any body
	MergeManyConnectedAccountsWithBodyWithResponse(ctx context.Context, params *MergeManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyConnectedAccountsResponse, error)

	MergeManyConnectedAccountsWithResponse(ctx context.Context, params *MergeManyConnectedAccountsParams, body MergeManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyConnectedAccountsResponse, error)

	// DeleteOneConnectedAccountWithResponse request
	DeleteOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *DeleteOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*DeleteOneConnectedAccountResponse, error)

	// FindOneConnectedAccountWithResponse request
	FindOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *FindOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*FindOneConnectedAccountResponse, error)

	// UpdateOneConnectedAccountWithBodyWithResponse request with any body
	UpdateOneConnectedAccountWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneConnectedAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneConnectedAccountResponse, error)

	UpdateOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *UpdateOneConnectedAccountParams, body UpdateOneConnectedAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneConnectedAccountResponse, error)

	// DeleteManyDashboardsWithResponse request
	DeleteManyDashboardsWithResponse(ctx context.Context, params *DeleteManyDashboardsParams, reqEditors ...RequestEditorFn) (*DeleteManyDashboardsResponse, error)

	// FindManyDashboardsWithResponse request
	FindManyDashboardsWithResponse(ctx context.Context, params *FindManyDashboardsParams, reqEditors ...RequestEditorFn) (*FindManyDashboardsResponse, error)

	// UpdateManyDashboardsWithBodyWithResponse request with any body
	UpdateManyDashboardsWithBodyWithResponse(ctx context.Context, params *UpdateManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyDashboardsResponse, error)

	UpdateManyDashboardsWithResponse(ctx context.Context, params *UpdateManyDashboardsParams, body UpdateManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyDashboardsResponse, error)

	// CreateOneDashboardWithBodyWithResponse request with any body
	CreateOneDashboardWithBodyWithResponse(ctx context.Context, params *CreateOneDashboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneDashboardResponse, error)

	CreateOneDashboardWithResponse(ctx context.Context, params *CreateOneDashboardParams, body CreateOneDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneDashboardResponse, error)

	// FindDashboardDuplicatesWithBodyWithResponse request with any body
	FindDashboardDuplicatesWithBodyWithResponse(ctx context.Context, params *FindDashboardDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindDashboardDuplicatesResponse, error)

	FindDashboardDuplicatesWithResponse(ctx context.Context, params *FindDashboardDuplicatesParams, body FindDashboardDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindDashboardDuplicatesResponse, error)

	// MergeManyDashboardsWithBodyWithResponse request with any body
	MergeManyDashboardsWithBodyWithResponse(ctx context.Context, params *MergeManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyDashboardsResponse, error)

	MergeManyDashboardsWithResponse(ctx context.Context, params *MergeManyDashboardsParams, body MergeManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyDashboardsResponse, error)

	// DeleteOneDashboardWithResponse request
	DeleteOneDashboardWithResponse(ctx context.Context, id IdPath, params *DeleteOneDashboardParams, reqEditors ...RequestEditorFn) (*DeleteOneDashboardResponse, error)

	// FindOneDashboardWithResponse request
	FindOneDashboardWithResponse(ctx context.Context, id IdPath, params *FindOneDashboardParams, reqEditors ...RequestEditorFn) (*FindOneDashboardResponse, error)

	// UpdateOneDashboardWithBodyWithResponse request with any body
	UpdateOneDashboardWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneDashboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneDashboardResponse, error)

	UpdateOneDashboardWithResponse(ctx context.Context, id IdPath, params *UpdateOneDashboardParams, body UpdateOneDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneDashboardResponse, error)

	// DuplicateDashboardWithResponse request
	DuplicateDashboardWithResponse(ctx context.Context, id IdPath, reqEditors ...RequestEditorFn) (*DuplicateDashboardResponse, error)

	// DeleteManyFavoriteFoldersWithResponse request
	DeleteManyFavoriteFoldersWithResponse(ctx context.Context, params *DeleteManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*DeleteManyFavoriteFoldersResponse, error)

	// FindManyFavoriteFoldersWithResponse request
	FindManyFavoriteFoldersWithResponse(ctx context.Context, params *FindManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*FindManyFavoriteFoldersResponse, error)

	// UpdateManyFavoriteFoldersWithBodyWithResponse request with any body
	UpdateManyFavoriteFoldersWithBodyWithResponse(ctx context.Context, params *UpdateManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyFavoriteFoldersResponse, error)

	UpdateManyFavoriteFoldersWithResponse(ctx context.Context, params *UpdateManyFavoriteFoldersParams, body UpdateManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyFavoriteFoldersResponse, error)

	// CreateOneFavoriteFolderWithBodyWithResponse request with any body
	CreateOneFavoriteFolderWithBodyWithResponse(ctx context.Context, params *CreateOneFavoriteFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneFavoriteFolderResponse, error)

	CreateOneFavoriteFolderWithResponse(ctx context.Context, params *CreateOneFavoriteFolderParams, body CreateOneFavoriteFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneFavoriteFolderResponse, error)

	// FindFavoriteFolderDuplicatesWithBodyWithResponse request with any body
	FindFavoriteFolderDuplicatesWithBodyWithResponse(ctx context.Context, params *FindFavoriteFolderDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindFavoriteFolderDuplicatesResponse, error)

	FindFavoriteFolderDuplicatesWithResponse(ctx context.Context, params *FindFavoriteFolderDuplicatesParams, body FindFavoriteFolderDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindFavoriteFolderDuplicatesResponse, error)

	// MergeManyFavoriteFoldersWithBodyWithResponse request with any body
	MergeManyFavoriteFoldersWithBodyWithResponse(ctx context.Context, params *MergeManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyFavoriteFoldersResponse, error)

	MergeManyFavoriteFoldersWithResponse(ctx context.Context, params *MergeManyFavoriteFoldersParams, body MergeManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyFavoriteFoldersResponse, error)

	// DeleteOneFavoriteFolderWithResponse request
	DeleteOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *DeleteOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*DeleteOneFavoriteFolderResponse, error)

	// FindOneFavoriteFolderWithResponse request
	FindOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *FindOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*FindOneFavoriteFolderResponse, error)

	// UpdateOneFavoriteFolderWithBodyWithResponse request with any body
	UpdateOneFavoriteFolderWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteFolderResponse, error)

	UpdateOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteFolderParams, body UpdateOneFavoriteFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteFolderResponse, error)

	// DeleteManyFavoritesWithResponse request
	DeleteManyFavoritesWithResponse(ctx context.Context, params *DeleteManyFavoritesParams, reqEditors ...RequestEditorFn) (*DeleteManyFavoritesResponse, error)

	// FindManyFavoritesWithResponse request
	FindManyFavoritesWithResponse(ctx context.Context, params *FindManyFavoritesParams, reqEditors ...RequestEditorFn) (*FindManyFavoritesResponse, error)

	// UpdateManyFavoritesWithBodyWithResponse request with any body
	UpdateManyFavoritesWithBodyWithResponse(ctx context.Context, params *UpdateManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyFavoritesResponse, error)

	UpdateManyFavoritesWithResponse(ctx context.Context, params *UpdateManyFavoritesParams, body UpdateManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyFavoritesResponse, error)

	// CreateOneFavoriteWithBodyWithResponse request with any body
	CreateOneFavoriteWithBodyWithResponse(ctx context.Context, params *CreateOneFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneFavoriteResponse, error)

	CreateOneFavoriteWithResponse(ctx context.Context, params *CreateOneFavoriteParams, body CreateOneFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneFavoriteResponse, error)

	// FindFavoriteDuplicatesWithBodyWithResponse request with any body
	FindFavoriteDuplicatesWithBodyWithResponse(ctx context.Context, params *FindFavoriteDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindFavoriteDuplicatesResponse, error)

	FindFavoriteDuplicatesWithResponse(ctx context.Context, params *FindFavoriteDuplicatesParams, body FindFavoriteDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindFavoriteDuplicatesResponse, error)

	// MergeManyFavoritesWithBodyWithResponse request with any body
	MergeManyFavoritesWithBodyWithResponse(ctx context.Context, params *MergeManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyFavoritesResponse, error)

	MergeManyFavoritesWithResponse(ctx context.Context, params *MergeManyFavoritesParams, body MergeManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyFavoritesResponse, error)

	// DeleteOneFavoriteWithResponse request
	DeleteOneFavoriteWithResponse(ctx context.Context, id IdPath, params *DeleteOneFavoriteParams, reqEditors ...RequestEditorFn) (*DeleteOneFavoriteResponse, error)

	// FindOneFavoriteWithResponse request
	FindOneFavoriteWithResponse(ctx context.Context, id IdPath, params *FindOneFavoriteParams, reqEditors ...RequestEditorFn) (*FindOneFavoriteResponse, error)

	// UpdateOneFavoriteWithBodyWithResponse request with any body
	UpdateOneFavoriteWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteResponse, error)

	UpdateOneFavoriteWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteParams, body UpdateOneFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteResponse, error)

	// DeleteManyMessageChannelMessageAssociationsWithResponse request
	DeleteManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *DeleteManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageChannelMessageAssociationsResponse, error)

	// FindManyMessageChannelMessageAssociationsWithResponse request
	FindManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *FindManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*FindManyMessageChannelMessageAssociationsResponse, error)

	// UpdateManyMessageChannelMessageAssociationsWithBodyWithResponse request with any body
	UpdateManyMessageChannelMessageAssociationsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelMessageAssociationsResponse, error)

	UpdateManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *UpdateManyMessageChannelMessageAssociationsParams, body UpdateManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelMessageAssociationsResponse, error)

	// CreateOneMessageChannelMessageAssociationWithBodyWithResponse request with any body
	CreateOneMessageChannelMessageAssociationWithBodyWithResponse(ctx context.Context, params *CreateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelMessageAssociationResponse, error)

	CreateOneMessageChannelMessageAssociationWithResponse(ctx context.Context, params *CreateOneMessageChannelMessageAssociationParams, body CreateOneMessageChannelMessageAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelMessageAssociationResponse, error)

	// FindMessageChannelMessageAssociationDuplicatesWithBodyWithResponse request with any body
	FindMessageChannelMessageAssociationDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageChannelMessageAssociationDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageChannelMessageAssociationDuplicatesResponse, error)

	FindMessageChannelMessageAssociationDuplicatesWithResponse(ctx context.Context, params *FindMessageChannelMessageAssociationDuplicatesParams, body FindMessageChannelMessageAssociationDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageChannelMessageAssociationDuplicatesResponse, error)

	// MergeManyMessageChannelMessageAssociationsWithBodyWithResponse request with any body
	MergeManyMessageChannelMessageAssociationsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelMessageAssociationsResponse, error)

	MergeManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *MergeManyMessageChannelMessageAssociationsParams, body MergeManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelMessageAssociationsResponse, error)

	// DeleteOneMessageChannelMessageAssociationWithResponse request
	DeleteOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageChannelMessageAssociationResponse, error)

	// FindOneMessageChannelMessageAssociationWithResponse request
	FindOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *FindOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*FindOneMessageChannelMessageAssociationResponse, error)

	// UpdateOneMessageChannelMessageAssociationWithBodyWithResponse request with any body
	UpdateOneMessageChannelMessageAssociationWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelMessageAssociationResponse, error)

	UpdateOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, body UpdateOneMessageChannelMessageAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelMessageAssociationResponse, error)

	// DeleteManyMessageChannelsWithResponse request
	DeleteManyMessageChannelsWithResponse(ctx context.Context, params *DeleteManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageChannelsResponse, error)

	// FindManyMessageChannelsWithResponse request
	FindManyMessageChannelsWithResponse(ctx context.Context, params *FindManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*FindManyMessageChannelsResponse, error)

	// UpdateManyMessageChannelsWithBodyWithResponse request with any body
	UpdateManyMessageChannelsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelsResponse, error)

	UpdateManyMessageChannelsWithResponse(ctx context.Context, params *UpdateManyMessageChannelsParams, body UpdateManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelsResponse, error)

	// CreateOneMessageChannelWithBodyWithResponse request with any body
	CreateOneMessageChannelWithBodyWithResponse(ctx context.Context, params *CreateOneMessageChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelResponse, error)

	CreateOneMessageChannelWithResponse(ctx context.Context, params *CreateOneMessageChannelParams, body CreateOneMessageChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelResponse, error)

	// FindMessageChannelDuplicatesWithBodyWithResponse request with any body
	FindMessageChannelDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageChannelDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageChannelDuplicatesResponse, error)

	FindMessageChannelDuplicatesWithResponse(ctx context.Context, params *FindMessageChannelDuplicatesParams, body FindMessageChannelDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageChannelDuplicatesResponse, error)

	// MergeManyMessageChannelsWithBodyWithResponse request with any body
	MergeManyMessageChannelsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelsResponse, error)

	MergeManyMessageChannelsWithResponse(ctx context.Context, params *MergeManyMessageChannelsParams, body MergeManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelsResponse, error)

	// DeleteOneMessageChannelWithResponse request
	DeleteOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageChannelParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageChannelResponse, error)

	// FindOneMessageChannelWithResponse request
	FindOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *FindOneMessageChannelParams, reqEditors ...RequestEditorFn) (*FindOneMessageChannelResponse, error)

	// UpdateOneMessageChannelWithBodyWithResponse request with any body
	UpdateOneMessageChannelWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelResponse, error)

	UpdateOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelParams, body UpdateOneMessageChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelResponse, error)

	// DeleteManyMessageFoldersWithResponse request
	DeleteManyMessageFoldersWithResponse(ctx context.Context, params *DeleteManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageFoldersResponse, error)

	// FindManyMessageFoldersWithResponse request
	FindManyMessageFoldersWithResponse(ctx context.Context, params *FindManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*FindManyMessageFoldersResponse, error)

	// UpdateManyMessageFoldersWithBodyWithResponse request with any body
	UpdateManyMessageFoldersWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageFoldersResponse, error)

	UpdateManyMessageFoldersWithResponse(ctx context.Context, params *UpdateManyMessageFoldersParams, body UpdateManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageFoldersResponse, error)

	// CreateOneMessageFolderWithBodyWithResponse request with any body
	CreateOneMessageFolderWithBodyWithResponse(ctx context.Context, params *CreateOneMessageFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageFolderResponse, error)

	CreateOneMessageFolderWithResponse(ctx context.Context, params *CreateOneMessageFolderParams, body CreateOneMessageFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageFolderResponse, error)

	// FindMessageFolderDuplicatesWithBodyWithResponse request with any body
	FindMessageFolderDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageFolderDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageFolderDuplicatesResponse, error)

	FindMessageFolderDuplicatesWithResponse(ctx context.Context, params *FindMessageFolderDuplicatesParams, body FindMessageFolderDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageFolderDuplicatesResponse, error)

	// MergeManyMessageFoldersWithBodyWithResponse request with any body
	MergeManyMessageFoldersWithBodyWithResponse(ctx context.Context, params *MergeManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageFoldersResponse, error)

	MergeManyMessageFoldersWithResponse(ctx context.Context, params *MergeManyMessageFoldersParams, body MergeManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageFoldersResponse, error)

	// DeleteOneMessageFolderWithResponse request
	DeleteOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageFolderParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageFolderResponse, error)

	// FindOneMessageFolderWithResponse request
	FindOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *FindOneMessageFolderParams, reqEditors ...RequestEditorFn) (*FindOneMessageFolderResponse, error)

	// UpdateOneMessageFolderWithBodyWithResponse request with any body
	UpdateOneMessageFolderWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageFolderResponse, error)

	UpdateOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageFolderParams, body UpdateOneMessageFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageFolderResponse, error)

	// DeleteManyMessageParticipantsWithResponse request
	DeleteManyMessageParticipantsWithResponse(ctx context.Context, params *DeleteManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageParticipantsResponse, error)

	// FindManyMessageParticipantsWithResponse request
	FindManyMessageParticipantsWithResponse(ctx context.Context, params *FindManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*FindManyMessageParticipantsResponse, error)

	// UpdateManyMessageParticipantsWithBodyWithResponse request with any body
	UpdateManyMessageParticipantsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageParticipantsResponse, error)

	UpdateManyMessageParticipantsWithResponse(ctx context.Context, params *UpdateManyMessageParticipantsParams, body UpdateManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageParticipantsResponse, error)

	// CreateOneMessageParticipantWithBodyWithResponse request with any body
	CreateOneMessageParticipantWithBodyWithResponse(ctx context.Context, params *CreateOneMessageParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageParticipantResponse, error)

	CreateOneMessageParticipantWithResponse(ctx context.Context, params *CreateOneMessageParticipantParams, body CreateOneMessageParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageParticipantResponse, error)

	// FindMessageParticipantDuplicatesWithBodyWithResponse request with any body
	FindMessageParticipantDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageParticipantDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageParticipantDuplicatesResponse, error)

	FindMessageParticipantDuplicatesWithResponse(ctx context.Context, params *FindMessageParticipantDuplicatesParams, body FindMessageParticipantDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageParticipantDuplicatesResponse, error)

	// MergeManyMessageParticipantsWithBodyWithResponse request with any body
	MergeManyMessageParticipantsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageParticipantsResponse, error)

	MergeManyMessageParticipantsWithResponse(ctx context.Context, params *MergeManyMessageParticipantsParams, body MergeManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageParticipantsResponse, error)

	// DeleteOneMessageParticipantWithResponse request
	DeleteOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageParticipantResponse, error)

	// FindOneMessageParticipantWithResponse request
	FindOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *FindOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*FindOneMessageParticipantResponse, error)

	// UpdateOneMessageParticipantWithBodyWithResponse request with any body
	UpdateOneMessageParticipantWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageParticipantResponse, error)

	UpdateOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParticipantParams, body UpdateOneMessageParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageParticipantResponse, error)

	// DeleteManyMessageThreadsWithResponse request
	DeleteManyMessageThreadsWithResponse(ctx context.Context, params *DeleteManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageThreadsResponse, error)

	// FindManyMessageThreadsWithResponse request
	FindManyMessageThreadsWithResponse(ctx context.Context, params *FindManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*FindManyMessageThreadsResponse, error)

	// UpdateManyMessageThreadsWithBodyWithResponse request with any body
	UpdateManyMessageThreadsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageThreadsResponse, error)

	UpdateManyMessageThreadsWithResponse(ctx context.Context, params *UpdateManyMessageThreadsParams, body UpdateManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageThreadsResponse, error)

	// CreateOneMessageThreadWithBodyWithResponse request with any body
	CreateOneMessageThreadWithBodyWithResponse(ctx context.Context, params *CreateOneMessageThreadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageThreadResponse, error)

	CreateOneMessageThreadWithResponse(ctx context.Context, params *CreateOneMessageThreadParams, body CreateOneMessageThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageThreadResponse, error)

	// FindMessageThreadDuplicatesWithBodyWithResponse request with any body
	FindMessageThreadDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageThreadDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageThreadDuplicatesResponse, error)

	FindMessageThreadDuplicatesWithResponse(ctx context.Context, params *FindMessageThreadDuplicatesParams, body FindMessageThreadDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageThreadDuplicatesResponse, error)

	// MergeManyMessageThreadsWithBodyWithResponse request with any body
	MergeManyMessageThreadsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageThreadsResponse, error)

	MergeManyMessageThreadsWithResponse(ctx context.Context, params *MergeManyMessageThreadsParams, body MergeManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageThreadsResponse, error)

	// DeleteOneMessageThreadWithResponse request
	DeleteOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageThreadParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageThreadResponse, error)

	// FindOneMessageThreadWithResponse request
	FindOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *FindOneMessageThreadParams, reqEditors ...RequestEditorFn) (*FindOneMessageThreadResponse, error)

	// UpdateOneMessageThreadWithBodyWithResponse request with any body
	UpdateOneMessageThreadWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageThreadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageThreadResponse, error)

	UpdateOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageThreadParams, body UpdateOneMessageThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageThreadResponse, error)

	// DeleteManyMessagesWithResponse request
	DeleteManyMessagesWithResponse(ctx context.Context, params *DeleteManyMessagesParams, reqEditors ...RequestEditorFn) (*DeleteManyMessagesResponse, error)

	// FindManyMessagesWithResponse request
	FindManyMessagesWithResponse(ctx context.Context, params *FindManyMessagesParams, reqEditors ...RequestEditorFn) (*FindManyMessagesResponse, error)

	// UpdateManyMessagesWithBodyWithResponse request with any body
	UpdateManyMessagesWithBodyWithResponse(ctx context.Context, params *UpdateManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessagesResponse, error)

	UpdateManyMessagesWithResponse(ctx context.Context, params *UpdateManyMessagesParams, body UpdateManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessagesResponse, error)

	// CreateOneMessageWithBodyWithResponse request with any body
	CreateOneMessageWithBodyWithResponse(ctx context.Context, params *CreateOneMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageResponse, error)

	CreateOneMessageWithResponse(ctx context.Context, params *CreateOneMessageParams, body CreateOneMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageResponse, error)

	// FindMessageDuplicatesWithBodyWithResponse request with any body
	FindMessageDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageDuplicatesResponse, error)

	FindMessageDuplicatesWithResponse(ctx context.Context, params *FindMessageDuplicatesParams, body FindMessageDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageDuplicatesResponse, error)

	// MergeManyMessagesWithBodyWithResponse request with any body
	MergeManyMessagesWithBodyWithResponse(ctx context.Context, params *MergeManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessagesResponse, error)

	MergeManyMessagesWithResponse(ctx context.Context, params *MergeManyMessagesParams, body MergeManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessagesResponse, error)

	// DeleteOneMessageWithResponse request
	DeleteOneMessageWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageResponse, error)

	// FindOneMessageWithResponse request
	FindOneMessageWithResponse(ctx context.Context, id IdPath, params *FindOneMessageParams, reqEditors ...RequestEditorFn) (*FindOneMessageResponse, error)

	// UpdateOneMessageWithBodyWithResponse request with any body
	UpdateOneMessageWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageResponse, error)

	UpdateOneMessageWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParams, body UpdateOneMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageResponse, error)

	// DeleteManyNoteTargetsWithResponse request
	DeleteManyNoteTargetsWithResponse(ctx context.Context, params *DeleteManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*DeleteManyNoteTargetsResponse, error)

	// FindManyNoteTargetsWithResponse request
	FindManyNoteTargetsWithResponse(ctx context.Context, params *FindManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*FindManyNoteTargetsResponse, error)

	// UpdateManyNoteTargetsWithBodyWithResponse request with any body
	UpdateManyNoteTargetsWithBodyWithResponse(ctx context.Context, params *UpdateManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyNoteTargetsResponse, error)

	UpdateManyNoteTargetsWithResponse(ctx context.Context, params *UpdateManyNoteTargetsParams, body UpdateManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyNoteTargetsResponse, error)

	// CreateOneNoteTargetWithBodyWithResponse request with any body
	CreateOneNoteTargetWithBodyWithResponse(ctx context.Context, params *CreateOneNoteTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneNoteTargetResponse, error)

	CreateOneNoteTargetWithResponse(ctx context.Context, params *CreateOneNoteTargetParams, body CreateOneNoteTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneNoteTargetResponse, error)

	// FindNoteTargetDuplicatesWithBodyWithResponse request with any body
	FindNoteTargetDuplicatesWithBodyWithResponse(ctx context.Context, params *FindNoteTargetDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindNoteTargetDuplicatesResponse, error)

	FindNoteTargetDuplicatesWithResponse(ctx context.Context, params *FindNoteTargetDuplicatesParams, body FindNoteTargetDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindNoteTargetDuplicatesResponse, error)

	// MergeManyNoteTargetsWithBodyWithResponse request with any body
	MergeManyNoteTargetsWithBodyWithResponse(ctx context.Context, params *MergeManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyNoteTargetsResponse, error)

	MergeManyNoteTargetsWithResponse(ctx context.Context, params *MergeManyNoteTargetsParams, body MergeManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyNoteTargetsResponse, error)

	// DeleteOneNoteTargetWithResponse request
	DeleteOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *DeleteOneNoteTargetParams, reqEditors ...RequestEditorFn) (*DeleteOneNoteTargetResponse, error)

	// FindOneNoteTargetWithResponse request
	FindOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *FindOneNoteTargetParams, reqEditors ...RequestEditorFn) (*FindOneNoteTargetResponse, error)

	// UpdateOneNoteTargetWithBodyWithResponse request with any body
	UpdateOneNoteTargetWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneNoteTargetResponse, error)

	UpdateOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteTargetParams, body UpdateOneNoteTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneNoteTargetResponse, error)

	// DeleteManyNotesWithResponse request
	DeleteManyNotesWithResponse(ctx context.Context, params *DeleteManyNotesParams, reqEditors ...RequestEditorFn) (*DeleteManyNotesResponse, error)

	// FindManyNotesWithResponse request
	FindManyNotesWithResponse(ctx context.Context, params *FindManyNotesParams, reqEditors ...RequestEditorFn) (*FindManyNotesResponse, error)

	// UpdateManyNotesWithBodyWithResponse request with any body
	UpdateManyNotesWithBodyWithResponse(ctx context.Context, params *UpdateManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyNotesResponse, error)

	UpdateManyNotesWithResponse(ctx context.Context, params *UpdateManyNotesParams, body UpdateManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyNotesResponse, error)

	// CreateOneNoteWithBodyWithResponse request with any body
	CreateOneNoteWithBodyWithResponse(ctx context.Context, params *CreateOneNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneNoteResponse, error)

	CreateOneNoteWithResponse(ctx context.Context, params *CreateOneNoteParams, body CreateOneNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneNoteResponse, error)

	// FindNoteDuplicatesWithBodyWithResponse request with any body
	FindNoteDuplicatesWithBodyWithResponse(ctx context.Context, params *FindNoteDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindNoteDuplicatesResponse, error)

	FindNoteDuplicatesWithResponse(ctx context.Context, params *FindNoteDuplicatesParams, body FindNoteDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindNoteDuplicatesResponse, error)

	// MergeManyNotesWithBodyWithResponse request with any body
	MergeManyNotesWithBodyWithResponse(ctx context.Context, params *MergeManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyNotesResponse, error)

	MergeManyNotesWithResponse(ctx context.Context, params *MergeManyNotesParams, body MergeManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyNotesResponse, error)

	// DeleteOneNoteWithResponse request
	DeleteOneNoteWithResponse(ctx context.Context, id IdPath, params *DeleteOneNoteParams, reqEditors ...RequestEditorFn) (*DeleteOneNoteResponse, error)

	// FindOneNoteWithResponse request
	FindOneNoteWithResponse(ctx context.Context, id IdPath, params *FindOneNoteParams, reqEditors ...RequestEditorFn) (*FindOneNoteResponse, error)

	// UpdateOneNoteWithBodyWithResponse request with any body
	UpdateOneNoteWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneNoteResponse, error)

	UpdateOneNoteWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteParams, body UpdateOneNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneNoteResponse, error)

	// GetOpenApiSchemaWithResponse request
	GetOpenApiSchemaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiSchemaResponse, error)

	// DeleteManyOpportunitiesWithResponse request
	DeleteManyOpportunitiesWithResponse(ctx context.Context, params *DeleteManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*DeleteManyOpportunitiesResponse, error)

	// FindManyOpportunitiesWithResponse request
	FindManyOpportunitiesWithResponse(ctx context.Context, params *FindManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*FindManyOpportunitiesResponse, error)

	// UpdateManyOpportunitiesWithBodyWithResponse request with any body
	UpdateManyOpportunitiesWithBodyWithResponse(ctx context.Context, params *UpdateManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyOpportunitiesResponse, error)

	UpdateManyOpportunitiesWithResponse(ctx context.Context, params *UpdateManyOpportunitiesParams, body UpdateManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyOpportunitiesResponse, error)

	// CreateOneOpportunityWithBodyWithResponse request with any body
	CreateOneOpportunityWithBodyWithResponse(ctx context.Context, params *CreateOneOpportunityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneOpportunityResponse, error)

	CreateOneOpportunityWithResponse(ctx context.Context, params *CreateOneOpportunityParams, body CreateOneOpportunityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneOpportunityResponse, error)

	// FindOpportunityDuplicatesWithBodyWithResponse request with any body
	FindOpportunityDuplicatesWithBodyWithResponse(ctx context.Context, params *FindOpportunityDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindOpportunityDuplicatesResponse, error)

	FindOpportunityDuplicatesWithResponse(ctx context.Context, params *FindOpportunityDuplicatesParams, body FindOpportunityDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindOpportunityDuplicatesResponse, error)

	// MergeManyOpportunitiesWithBodyWithResponse request with any body
	MergeManyOpportunitiesWithBodyWithResponse(ctx context.Context, params *MergeManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyOpportunitiesResponse, error)

	MergeManyOpportunitiesWithResponse(ctx context.Context, params *MergeManyOpportunitiesParams, body MergeManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyOpportunitiesResponse, error)

	// DeleteOneOpportunityWithResponse request
	DeleteOneOpportunityWithResponse(ctx context.Context, id IdPath, params *DeleteOneOpportunityParams, reqEditors ...RequestEditorFn) (*DeleteOneOpportunityResponse, error)

	// FindOneOpportunityWithResponse request
	FindOneOpportunityWithResponse(ctx context.Context, id IdPath, params *FindOneOpportunityParams, reqEditors ...RequestEditorFn) (*FindOneOpportunityResponse, error)

	// UpdateOneOpportunityWithBodyWithResponse request with any body
	UpdateOneOpportunityWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneOpportunityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneOpportunityResponse, error)

	UpdateOneOpportunityWithResponse(ctx context.Context, id IdPath, params *UpdateOneOpportunityParams, body UpdateOneOpportunityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneOpportunityResponse, error)

	// DeleteManyPeopleWithResponse request
	DeleteManyPeopleWithResponse(ctx context.Context, params *DeleteManyPeopleParams, reqEditors ...RequestEditorFn) (*DeleteManyPeopleResponse, error)

	// FindManyPeopleWithResponse request
	FindManyPeopleWithResponse(ctx context.Context, params *FindManyPeopleParams, reqEditors ...RequestEditorFn) (*FindManyPeopleResponse, error)

	// UpdateManyPeopleWithBodyWithResponse request with any body
	UpdateManyPeopleWithBodyWithResponse(ctx context.Context, params *UpdateManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyPeopleResponse, error)

	UpdateManyPeopleWithResponse(ctx context.Context, params *UpdateManyPeopleParams, body UpdateManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyPeopleResponse, error)

	// CreateOnePersonWithBodyWithResponse request with any body
	CreateOnePersonWithBodyWithResponse(ctx context.Context, params *CreateOnePersonParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnePersonResponse, error)

	CreateOnePersonWithResponse(ctx context.Context, params *CreateOnePersonParams, body CreateOnePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnePersonResponse, error)

	// FindPersonDuplicatesWithBodyWithResponse request with any body
	FindPersonDuplicatesWithBodyWithResponse(ctx context.Context, params *FindPersonDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindPersonDuplicatesResponse, error)

	FindPersonDuplicatesWithResponse(ctx context.Context, params *FindPersonDuplicatesParams, body FindPersonDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindPersonDuplicatesResponse, error)

	// MergeManyPeopleWithBodyWithResponse request with any body
	MergeManyPeopleWithBodyWithResponse(ctx context.Context, params *MergeManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyPeopleResponse, error)

	MergeManyPeopleWithResponse(ctx context.Context, params *MergeManyPeopleParams, body MergeManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyPeopleResponse, error)

	// DeleteOnePersonWithResponse request
	DeleteOnePersonWithResponse(ctx context.Context, id IdPath, params *DeleteOnePersonParams, reqEditors ...RequestEditorFn) (*DeleteOnePersonResponse, error)

	// FindOnePersonWithResponse request
	FindOnePersonWithResponse(ctx context.Context, id IdPath, params *FindOnePersonParams, reqEditors ...RequestEditorFn) (*FindOnePersonResponse, error)

	// UpdateOnePersonWithBodyWithResponse request with any body
	UpdateOnePersonWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOnePersonParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOnePersonResponse, error)

	UpdateOnePersonWithResponse(ctx context.Context, id IdPath, params *UpdateOnePersonParams, body UpdateOnePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOnePersonResponse, error)

	// RestoreManyAttachmentsWithResponse request
	RestoreManyAttachmentsWithResponse(ctx context.Context, params *RestoreManyAttachmentsParams, reqEditors ...RequestEditorFn) (*RestoreManyAttachmentsResponse, error)

	// RestoreOneAttachmentWithResponse request
	RestoreOneAttachmentWithResponse(ctx context.Context, id IdPath, params *RestoreOneAttachmentParams, reqEditors ...RequestEditorFn) (*RestoreOneAttachmentResponse, error)

	// RestoreManyBlocklistsWithResponse request
	RestoreManyBlocklistsWithResponse(ctx context.Context, params *RestoreManyBlocklistsParams, reqEditors ...RequestEditorFn) (*RestoreManyBlocklistsResponse, error)

	// RestoreOneBlocklistWithResponse request
	RestoreOneBlocklistWithResponse(ctx context.Context, id IdPath, params *RestoreOneBlocklistParams, reqEditors ...RequestEditorFn) (*RestoreOneBlocklistResponse, error)

	// RestoreManyCalendarChannelEventAssociationsWithResponse request
	RestoreManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *RestoreManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarChannelEventAssociationsResponse, error)

	// RestoreOneCalendarChannelEventAssociationWithResponse request
	RestoreOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarChannelEventAssociationResponse, error)

	// RestoreManyCalendarChannelsWithResponse request
	RestoreManyCalendarChannelsWithResponse(ctx context.Context, params *RestoreManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarChannelsResponse, error)

	// RestoreOneCalendarChannelWithResponse request
	RestoreOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarChannelResponse, error)

	// RestoreManyCalendarEventParticipantsWithResponse request
	RestoreManyCalendarEventParticipantsWithResponse(ctx context.Context, params *RestoreManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarEventParticipantsResponse, error)

	// RestoreOneCalendarEventParticipantWithResponse request
	RestoreOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarEventParticipantResponse, error)

	// RestoreManyCalendarEventsWithResponse request
	RestoreManyCalendarEventsWithResponse(ctx context.Context, params *RestoreManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarEventsResponse, error)

	// RestoreOneCalendarEventWithResponse request
	RestoreOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarEventParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarEventResponse, error)

	// RestoreManyCompaniesWithResponse request
	RestoreManyCompaniesWithResponse(ctx context.Context, params *RestoreManyCompaniesParams, reqEditors ...RequestEditorFn) (*RestoreManyCompaniesResponse, error)

	// RestoreOneCompanyWithResponse request
	RestoreOneCompanyWithResponse(ctx context.Context, id IdPath, params *RestoreOneCompanyParams, reqEditors ...RequestEditorFn) (*RestoreOneCompanyResponse, error)

	// RestoreManyConnectedAccountsWithResponse request
	RestoreManyConnectedAccountsWithResponse(ctx context.Context, params *RestoreManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*RestoreManyConnectedAccountsResponse, error)

	// RestoreOneConnectedAccountWithResponse request
	RestoreOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *RestoreOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*RestoreOneConnectedAccountResponse, error)

	// RestoreManyDashboardsWithResponse request
	RestoreManyDashboardsWithResponse(ctx context.Context, params *RestoreManyDashboardsParams, reqEditors ...RequestEditorFn) (*RestoreManyDashboardsResponse, error)

	// RestoreOneDashboardWithResponse request
	RestoreOneDashboardWithResponse(ctx context.Context, id IdPath, params *RestoreOneDashboardParams, reqEditors ...RequestEditorFn) (*RestoreOneDashboardResponse, error)

	// RestoreManyFavoriteFoldersWithResponse request
	RestoreManyFavoriteFoldersWithResponse(ctx context.Context, params *RestoreManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*RestoreManyFavoriteFoldersResponse, error)

	// RestoreOneFavoriteFolderWithResponse request
	RestoreOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *RestoreOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*RestoreOneFavoriteFolderResponse, error)

	// RestoreManyFavoritesWithResponse request
	RestoreManyFavoritesWithResponse(ctx context.Context, params *RestoreManyFavoritesParams, reqEditors ...RequestEditorFn) (*RestoreManyFavoritesResponse, error)

	// RestoreOneFavoriteWithResponse request
	RestoreOneFavoriteWithResponse(ctx context.Context, id IdPath, params *RestoreOneFavoriteParams, reqEditors ...RequestEditorFn) (*RestoreOneFavoriteResponse, error)

	// RestoreManyMessageChannelMessageAssociationsWithResponse request
	RestoreManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *RestoreManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageChannelMessageAssociationsResponse, error)

	// RestoreOneMessageChannelMessageAssociationWithResponse request
	RestoreOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageChannelMessageAssociationResponse, error)

	// RestoreManyMessageChannelsWithResponse request
	RestoreManyMessageChannelsWithResponse(ctx context.Context, params *RestoreManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageChannelsResponse, error)

	// RestoreOneMessageChannelWithResponse request
	RestoreOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageChannelParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageChannelResponse, error)

	// RestoreManyMessageFoldersWithResponse request
	RestoreManyMessageFoldersWithResponse(ctx context.Context, params *RestoreManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageFoldersResponse, error)

	// RestoreOneMessageFolderWithResponse request
	RestoreOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageFolderParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageFolderResponse, error)

	// RestoreManyMessageParticipantsWithResponse request
	RestoreManyMessageParticipantsWithResponse(ctx context.Context, params *RestoreManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageParticipantsResponse, error)

	// RestoreOneMessageParticipantWithResponse request
	RestoreOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageParticipantResponse, error)

	// RestoreManyMessageThreadsWithResponse request
	RestoreManyMessageThreadsWithResponse(ctx context.Context, params *RestoreManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageThreadsResponse, error)

	// RestoreOneMessageThreadWithResponse request
	RestoreOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageThreadParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageThreadResponse, error)

	// RestoreManyMessagesWithResponse request
	RestoreManyMessagesWithResponse(ctx context.Context, params *RestoreManyMessagesParams, reqEditors ...RequestEditorFn) (*RestoreManyMessagesResponse, error)

	// RestoreOneMessageWithResponse request
	RestoreOneMessageWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageResponse, error)

	// RestoreManyNoteTargetsWithResponse request
	RestoreManyNoteTargetsWithResponse(ctx context.Context, params *RestoreManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*RestoreManyNoteTargetsResponse, error)

	// RestoreOneNoteTargetWithResponse request
	RestoreOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *RestoreOneNoteTargetParams, reqEditors ...RequestEditorFn) (*RestoreOneNoteTargetResponse, error)

	// RestoreManyNotesWithResponse request
	RestoreManyNotesWithResponse(ctx context.Context, params *RestoreManyNotesParams, reqEditors ...RequestEditorFn) (*RestoreManyNotesResponse, error)

	// RestoreOneNoteWithResponse request
	RestoreOneNoteWithResponse(ctx context.Context, id IdPath, params *RestoreOneNoteParams, reqEditors ...RequestEditorFn) (*RestoreOneNoteResponse, error)

	// RestoreManyOpportunitiesWithResponse request
	RestoreManyOpportunitiesWithResponse(ctx context.Context, params *RestoreManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*RestoreManyOpportunitiesResponse, error)

	// RestoreOneOpportunityWithResponse request
	RestoreOneOpportunityWithResponse(ctx context.Context, id IdPath, params *RestoreOneOpportunityParams, reqEditors ...RequestEditorFn) (*RestoreOneOpportunityResponse, error)

	// RestoreManyPeopleWithResponse request
	RestoreManyPeopleWithResponse(ctx context.Context, params *RestoreManyPeopleParams, reqEditors ...RequestEditorFn) (*RestoreManyPeopleResponse, error)

	// RestoreOnePersonWithResponse request
	RestoreOnePersonWithResponse(ctx context.Context, id IdPath, params *RestoreOnePersonParams, reqEditors ...RequestEditorFn) (*RestoreOnePersonResponse, error)

	// RestoreManyTaskTargetsWithResponse request
	RestoreManyTaskTargetsWithResponse(ctx context.Context, params *RestoreManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*RestoreManyTaskTargetsResponse, error)

	// RestoreOneTaskTargetWithResponse request
	RestoreOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *RestoreOneTaskTargetParams, reqEditors ...RequestEditorFn) (*RestoreOneTaskTargetResponse, error)

	// RestoreManyTasksWithResponse request
	RestoreManyTasksWithResponse(ctx context.Context, params *RestoreManyTasksParams, reqEditors ...RequestEditorFn) (*RestoreManyTasksResponse, error)

	// RestoreOneTaskWithResponse request
	RestoreOneTaskWithResponse(ctx context.Context, id IdPath, params *RestoreOneTaskParams, reqEditors ...RequestEditorFn) (*RestoreOneTaskResponse, error)

	// RestoreManyTimelineActivitiesWithResponse request
	RestoreManyTimelineActivitiesWithResponse(ctx context.Context, params *RestoreManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*RestoreManyTimelineActivitiesResponse, error)

	// RestoreOneTimelineActivityWithResponse request
	RestoreOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *RestoreOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*RestoreOneTimelineActivityResponse, error)

	// RestoreManyWorkflowAutomatedTriggersWithResponse request
	RestoreManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *RestoreManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowAutomatedTriggersResponse, error)

	// RestoreOneWorkflowAutomatedTriggerWithResponse request
	RestoreOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowAutomatedTriggerResponse, error)

	// RestoreManyWorkflowRunsWithResponse request
	RestoreManyWorkflowRunsWithResponse(ctx context.Context, params *RestoreManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowRunsResponse, error)

	// RestoreOneWorkflowRunWithResponse request
	RestoreOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowRunResponse, error)

	// RestoreManyWorkflowVersionsWithResponse request
	RestoreManyWorkflowVersionsWithResponse(ctx context.Context, params *RestoreManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowVersionsResponse, error)

	// RestoreOneWorkflowVersionWithResponse request
	RestoreOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowVersionResponse, error)

	// RestoreManyWorkflowsWithResponse request
	RestoreManyWorkflowsWithResponse(ctx context.Context, params *RestoreManyWorkflowsParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowsResponse, error)

	// RestoreOneWorkflowWithResponse request
	RestoreOneWorkflowWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowResponse, error)

	// RestoreManyWorkspaceMembersWithResponse request
	RestoreManyWorkspaceMembersWithResponse(ctx context.Context, params *RestoreManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkspaceMembersResponse, error)

	// RestoreOneWorkspaceMemberWithResponse request
	RestoreOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkspaceMemberResponse, error)

	// DeleteManyTaskTargetsWithResponse request
	DeleteManyTaskTargetsWithResponse(ctx context.Context, params *DeleteManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*DeleteManyTaskTargetsResponse, error)

	// FindManyTaskTargetsWithResponse request
	FindManyTaskTargetsWithResponse(ctx context.Context, params *FindManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*FindManyTaskTargetsResponse, error)

	// UpdateManyTaskTargetsWithBodyWithResponse request with any body
	UpdateManyTaskTargetsWithBodyWithResponse(ctx context.Context, params *UpdateManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyTaskTargetsResponse, error)

	UpdateManyTaskTargetsWithResponse(ctx context.Context, params *UpdateManyTaskTargetsParams, body UpdateManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyTaskTargetsResponse, error)

	// CreateOneTaskTargetWithBodyWithResponse request with any body
	CreateOneTaskTargetWithBodyWithResponse(ctx context.Context, params *CreateOneTaskTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneTaskTargetResponse, error)

	CreateOneTaskTargetWithResponse(ctx context.Context, params *CreateOneTaskTargetParams, body CreateOneTaskTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneTaskTargetResponse, error)

	// FindTaskTargetDuplicatesWithBodyWithResponse request with any body
	FindTaskTargetDuplicatesWithBodyWithResponse(ctx context.Context, params *FindTaskTargetDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTaskTargetDuplicatesResponse, error)

	FindTaskTargetDuplicatesWithResponse(ctx context.Context, params *FindTaskTargetDuplicatesParams, body FindTaskTargetDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTaskTargetDuplicatesResponse, error)

	// MergeManyTaskTargetsWithBodyWithResponse request with any body
	MergeManyTaskTargetsWithBodyWithResponse(ctx context.Context, params *MergeManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyTaskTargetsResponse, error)

	MergeManyTaskTargetsWithResponse(ctx context.Context, params *MergeManyTaskTargetsParams, body MergeManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyTaskTargetsResponse, error)

	// DeleteOneTaskTargetWithResponse request
	DeleteOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *DeleteOneTaskTargetParams, reqEditors ...RequestEditorFn) (*DeleteOneTaskTargetResponse, error)

	// FindOneTaskTargetWithResponse request
	FindOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *FindOneTaskTargetParams, reqEditors ...RequestEditorFn) (*FindOneTaskTargetResponse, error)

	// UpdateOneTaskTargetWithBodyWithResponse request with any body
	UpdateOneTaskTargetWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneTaskTargetResponse, error)

	UpdateOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskTargetParams, body UpdateOneTaskTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneTaskTargetResponse, error)

	// DeleteManyTasksWithResponse request
	DeleteManyTasksWithResponse(ctx context.Context, params *DeleteManyTasksParams, reqEditors ...RequestEditorFn) (*DeleteManyTasksResponse, error)

	// FindManyTasksWithResponse request
	FindManyTasksWithResponse(ctx context.Context, params *FindManyTasksParams, reqEditors ...RequestEditorFn) (*FindManyTasksResponse, error)

	// UpdateManyTasksWithBodyWithResponse request with any body
	UpdateManyTasksWithBodyWithResponse(ctx context.Context, params *UpdateManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyTasksResponse, error)

	UpdateManyTasksWithResponse(ctx context.Context, params *UpdateManyTasksParams, body UpdateManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyTasksResponse, error)

	// CreateOneTaskWithBodyWithResponse request with any body
	CreateOneTaskWithBodyWithResponse(ctx context.Context, params *CreateOneTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneTaskResponse, error)

	CreateOneTaskWithResponse(ctx context.Context, params *CreateOneTaskParams, body CreateOneTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneTaskResponse, error)

	// FindTaskDuplicatesWithBodyWithResponse request with any body
	FindTaskDuplicatesWithBodyWithResponse(ctx context.Context, params *FindTaskDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTaskDuplicatesResponse, error)

	FindTaskDuplicatesWithResponse(ctx context.Context, params *FindTaskDuplicatesParams, body FindTaskDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTaskDuplicatesResponse, error)

	// MergeManyTasksWithBodyWithResponse request with any body
	MergeManyTasksWithBodyWithResponse(ctx context.Context, params *MergeManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyTasksResponse, error)

	MergeManyTasksWithResponse(ctx context.Context, params *MergeManyTasksParams, body MergeManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyTasksResponse, error)

	// DeleteOneTaskWithResponse request
	DeleteOneTaskWithResponse(ctx context.Context, id IdPath, params *DeleteOneTaskParams, reqEditors ...RequestEditorFn) (*DeleteOneTaskResponse, error)

	// FindOneTaskWithResponse request
	FindOneTaskWithResponse(ctx context.Context, id IdPath, params *FindOneTaskParams, reqEditors ...RequestEditorFn) (*FindOneTaskResponse, error)

	// UpdateOneTaskWithBodyWithResponse request with any body
	UpdateOneTaskWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneTaskResponse, error)

	UpdateOneTaskWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskParams, body UpdateOneTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneTaskResponse, error)

	// DeleteManyTimelineActivitiesWithResponse request
	DeleteManyTimelineActivitiesWithResponse(ctx context.Context, params *DeleteManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*DeleteManyTimelineActivitiesResponse, error)

	// FindManyTimelineActivitiesWithResponse request
	FindManyTimelineActivitiesWithResponse(ctx context.Context, params *FindManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*FindManyTimelineActivitiesResponse, error)

	// UpdateManyTimelineActivitiesWithBodyWithResponse request with any body
	UpdateManyTimelineActivitiesWithBodyWithResponse(ctx context.Context, params *UpdateManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyTimelineActivitiesResponse, error)

	UpdateManyTimelineActivitiesWithResponse(ctx context.Context, params *UpdateManyTimelineActivitiesParams, body UpdateManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyTimelineActivitiesResponse, error)

	// CreateOneTimelineActivityWithBodyWithResponse request with any body
	CreateOneTimelineActivityWithBodyWithResponse(ctx context.Context, params *CreateOneTimelineActivityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneTimelineActivityResponse, error)

	CreateOneTimelineActivityWithResponse(ctx context.Context, params *CreateOneTimelineActivityParams, body CreateOneTimelineActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneTimelineActivityResponse, error)

	// FindTimelineActivityDuplicatesWithBodyWithResponse request with any body
	FindTimelineActivityDuplicatesWithBodyWithResponse(ctx context.Context, params *FindTimelineActivityDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTimelineActivityDuplicatesResponse, error)

	FindTimelineActivityDuplicatesWithResponse(ctx context.Context, params *FindTimelineActivityDuplicatesParams, body FindTimelineActivityDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTimelineActivityDuplicatesResponse, error)

	// MergeManyTimelineActivitiesWithBodyWithResponse request with any body
	MergeManyTimelineActivitiesWithBodyWithResponse(ctx context.Context, params *MergeManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyTimelineActivitiesResponse, error)

	MergeManyTimelineActivitiesWithResponse(ctx context.Context, params *MergeManyTimelineActivitiesParams, body MergeManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyTimelineActivitiesResponse, error)

	// DeleteOneTimelineActivityWithResponse request
	DeleteOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *DeleteOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*DeleteOneTimelineActivityResponse, error)

	// FindOneTimelineActivityWithResponse request
	FindOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *FindOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*FindOneTimelineActivityResponse, error)

	// UpdateOneTimelineActivityWithBodyWithResponse request with any body
	UpdateOneTimelineActivityWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneTimelineActivityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneTimelineActivityResponse, error)

	UpdateOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *UpdateOneTimelineActivityParams, body UpdateOneTimelineActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneTimelineActivityResponse, error)

	// DeleteManyWorkflowAutomatedTriggersWithResponse request
	DeleteManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *DeleteManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowAutomatedTriggersResponse, error)

	// FindManyWorkflowAutomatedTriggersWithResponse request
	FindManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *FindManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowAutomatedTriggersResponse, error)

	// UpdateManyWorkflowAutomatedTriggersWithBodyWithResponse request with any body
	UpdateManyWorkflowAutomatedTriggersWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowAutomatedTriggersResponse, error)

	UpdateManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *UpdateManyWorkflowAutomatedTriggersParams, body UpdateManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowAutomatedTriggersResponse, error)

	// CreateOneWorkflowAutomatedTriggerWithBodyWithResponse request with any body
	CreateOneWorkflowAutomatedTriggerWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowAutomatedTriggerResponse, error)

	CreateOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, params *CreateOneWorkflowAutomatedTriggerParams, body CreateOneWorkflowAutomatedTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowAutomatedTriggerResponse, error)

	// FindWorkflowAutomatedTriggerDuplicatesWithBodyWithResponse request with any body
	FindWorkflowAutomatedTriggerDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowAutomatedTriggerDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowAutomatedTriggerDuplicatesResponse, error)

	FindWorkflowAutomatedTriggerDuplicatesWithResponse(ctx context.Context, params *FindWorkflowAutomatedTriggerDuplicatesParams, body FindWorkflowAutomatedTriggerDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowAutomatedTriggerDuplicatesResponse, error)

	// MergeManyWorkflowAutomatedTriggersWithBodyWithResponse request with any body
	MergeManyWorkflowAutomatedTriggersWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowAutomatedTriggersResponse, error)

	MergeManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *MergeManyWorkflowAutomatedTriggersParams, body MergeManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowAutomatedTriggersResponse, error)

	// DeleteOneWorkflowAutomatedTriggerWithResponse request
	DeleteOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowAutomatedTriggerResponse, error)

	// FindOneWorkflowAutomatedTriggerWithResponse request
	FindOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowAutomatedTriggerResponse, error)

	// UpdateOneWorkflowAutomatedTriggerWithBodyWithResponse request with any body
	UpdateOneWorkflowAutomatedTriggerWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowAutomatedTriggerResponse, error)

	UpdateOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, body UpdateOneWorkflowAutomatedTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowAutomatedTriggerResponse, error)

	// DeleteManyWorkflowRunsWithResponse request
	DeleteManyWorkflowRunsWithResponse(ctx context.Context, params *DeleteManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowRunsResponse, error)

	// FindManyWorkflowRunsWithResponse request
	FindManyWorkflowRunsWithResponse(ctx context.Context, params *FindManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowRunsResponse, error)

	// UpdateManyWorkflowRunsWithBodyWithResponse request with any body
	UpdateManyWorkflowRunsWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowRunsResponse, error)

	UpdateManyWorkflowRunsWithResponse(ctx context.Context, params *UpdateManyWorkflowRunsParams, body UpdateManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowRunsResponse, error)

	// CreateOneWorkflowRunWithBodyWithResponse request with any body
	CreateOneWorkflowRunWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowRunResponse, error)

	CreateOneWorkflowRunWithResponse(ctx context.Context, params *CreateOneWorkflowRunParams, body CreateOneWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowRunResponse, error)

	// FindWorkflowRunDuplicatesWithBodyWithResponse request with any body
	FindWorkflowRunDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowRunDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowRunDuplicatesResponse, error)

	FindWorkflowRunDuplicatesWithResponse(ctx context.Context, params *FindWorkflowRunDuplicatesParams, body FindWorkflowRunDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowRunDuplicatesResponse, error)

	// MergeManyWorkflowRunsWithBodyWithResponse request with any body
	MergeManyWorkflowRunsWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowRunsResponse, error)

	MergeManyWorkflowRunsWithResponse(ctx context.Context, params *MergeManyWorkflowRunsParams, body MergeManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowRunsResponse, error)

	// DeleteOneWorkflowRunWithResponse request
	DeleteOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowRunResponse, error)

	// FindOneWorkflowRunWithResponse request
	FindOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowRunResponse, error)

	// UpdateOneWorkflowRunWithBodyWithResponse request with any body
	UpdateOneWorkflowRunWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowRunResponse, error)

	UpdateOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowRunParams, body UpdateOneWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowRunResponse, error)

	// DeleteManyWorkflowVersionsWithResponse request
	DeleteManyWorkflowVersionsWithResponse(ctx context.Context, params *DeleteManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowVersionsResponse, error)

	// FindManyWorkflowVersionsWithResponse request
	FindManyWorkflowVersionsWithResponse(ctx context.Context, params *FindManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowVersionsResponse, error)

	// UpdateManyWorkflowVersionsWithBodyWithResponse request with any body
	UpdateManyWorkflowVersionsWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowVersionsResponse, error)

	UpdateManyWorkflowVersionsWithResponse(ctx context.Context, params *UpdateManyWorkflowVersionsParams, body UpdateManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowVersionsResponse, error)

	// CreateOneWorkflowVersionWithBodyWithResponse request with any body
	CreateOneWorkflowVersionWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowVersionResponse, error)

	CreateOneWorkflowVersionWithResponse(ctx context.Context, params *CreateOneWorkflowVersionParams, body CreateOneWorkflowVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowVersionResponse, error)

	// FindWorkflowVersionDuplicatesWithBodyWithResponse request with any body
	FindWorkflowVersionDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowVersionDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowVersionDuplicatesResponse, error)

	FindWorkflowVersionDuplicatesWithResponse(ctx context.Context, params *FindWorkflowVersionDuplicatesParams, body FindWorkflowVersionDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowVersionDuplicatesResponse, error)

	// MergeManyWorkflowVersionsWithBodyWithResponse request with any body
	MergeManyWorkflowVersionsWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowVersionsResponse, error)

	MergeManyWorkflowVersionsWithResponse(ctx context.Context, params *MergeManyWorkflowVersionsParams, body MergeManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowVersionsResponse, error)

	// DeleteOneWorkflowVersionWithResponse request
	DeleteOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowVersionResponse, error)

	// FindOneWorkflowVersionWithResponse request
	FindOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowVersionResponse, error)

	// UpdateOneWorkflowVersionWithBodyWithResponse request with any body
	UpdateOneWorkflowVersionWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowVersionResponse, error)

	UpdateOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowVersionParams, body UpdateOneWorkflowVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowVersionResponse, error)

	// DeleteManyWorkflowsWithResponse request
	DeleteManyWorkflowsWithResponse(ctx context.Context, params *DeleteManyWorkflowsParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowsResponse, error)

	// FindManyWorkflowsWithResponse request
	FindManyWorkflowsWithResponse(ctx context.Context, params *FindManyWorkflowsParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowsResponse, error)

	// UpdateManyWorkflowsWithBodyWithResponse request with any body
	UpdateManyWorkflowsWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowsResponse, error)

	UpdateManyWorkflowsWithResponse(ctx context.Context, params *UpdateManyWorkflowsParams, body UpdateManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowsResponse, error)

	// CreateOneWorkflowWithBodyWithResponse request with any body
	CreateOneWorkflowWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowResponse, error)

	CreateOneWorkflowWithResponse(ctx context.Context, params *CreateOneWorkflowParams, body CreateOneWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowResponse, error)

	// FindWorkflowDuplicatesWithBodyWithResponse request with any body
	FindWorkflowDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowDuplicatesResponse, error)

	FindWorkflowDuplicatesWithResponse(ctx context.Context, params *FindWorkflowDuplicatesParams, body FindWorkflowDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowDuplicatesResponse, error)

	// MergeManyWorkflowsWithBodyWithResponse request with any body
	MergeManyWorkflowsWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowsResponse, error)

	MergeManyWorkflowsWithResponse(ctx context.Context, params *MergeManyWorkflowsParams, body MergeManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowsResponse, error)

	// DeleteOneWorkflowWithResponse request
	DeleteOneWorkflowWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowResponse, error)

	// FindOneWorkflowWithResponse request
	FindOneWorkflowWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowResponse, error)

	// UpdateOneWorkflowWithBodyWithResponse request with any body
	UpdateOneWorkflowWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowResponse, error)

	UpdateOneWorkflowWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowParams, body UpdateOneWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowResponse, error)

	// DeleteManyWorkspaceMembersWithResponse request
	DeleteManyWorkspaceMembersWithResponse(ctx context.Context, params *DeleteManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkspaceMembersResponse, error)

	// FindManyWorkspaceMembersWithResponse request
	FindManyWorkspaceMembersWithResponse(ctx context.Context, params *FindManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*FindManyWorkspaceMembersResponse, error)

	// UpdateManyWorkspaceMembersWithBodyWithResponse request with any body
	UpdateManyWorkspaceMembersWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkspaceMembersResponse, error)

	UpdateManyWorkspaceMembersWithResponse(ctx context.Context, params *UpdateManyWorkspaceMembersParams, body UpdateManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkspaceMembersResponse, error)

	// CreateOneWorkspaceMemberWithBodyWithResponse request with any body
	CreateOneWorkspaceMemberWithBodyWithResponse(ctx context.Context, params *CreateOneWorkspaceMemberParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkspaceMemberResponse, error)

	CreateOneWorkspaceMemberWithResponse(ctx context.Context, params *CreateOneWorkspaceMemberParams, body CreateOneWorkspaceMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkspaceMemberResponse, error)

	// FindWorkspaceMemberDuplicatesWithBodyWithResponse request with any body
	FindWorkspaceMemberDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkspaceMemberDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkspaceMemberDuplicatesResponse, error)

	FindWorkspaceMemberDuplicatesWithResponse(ctx context.Context, params *FindWorkspaceMemberDuplicatesParams, body FindWorkspaceMemberDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkspaceMemberDuplicatesResponse, error)

	// MergeManyWorkspaceMembersWithBodyWithResponse request with any body
	MergeManyWorkspaceMembersWithBodyWithResponse(ctx context.Context, params *MergeManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkspaceMembersResponse, error)

	MergeManyWorkspaceMembersWithResponse(ctx context.Context, params *MergeManyWorkspaceMembersParams, body MergeManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkspaceMembersResponse, error)

	// DeleteOneWorkspaceMemberWithResponse request
	DeleteOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkspaceMemberResponse, error)

	// FindOneWorkspaceMemberWithResponse request
	FindOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *FindOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*FindOneWorkspaceMemberResponse, error)

	// UpdateOneWorkspaceMemberWithBodyWithResponse request with any body
	UpdateOneWorkspaceMemberWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkspaceMemberParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkspaceMemberResponse, error)

	UpdateOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkspaceMemberParams, body UpdateOneWorkspaceMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkspaceMemberResponse, error)
}

type DeleteManyAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteAttachments *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteAttachments,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Attachments *[]AttachmentForResponse `json:"attachments,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateAttachments *[]AttachmentForResponse `json:"updateAttachments,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateAttachment An attachment
			CreateAttachment *AttachmentForResponse `json:"createAttachment,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAttachmentDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AttachmentDuplicates *[]AttachmentForResponse `json:"attachmentDuplicates,omitempty"`
			PageInfo             *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindAttachmentDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAttachmentDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeAttachments An attachment
			MergeAttachments *AttachmentForResponse `json:"mergeAttachments,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteAttachment *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteAttachment,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Attachment An attachment
			Attachment *AttachmentForResponse `json:"attachment,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateAttachment An attachment
			UpdateAttachment *AttachmentForResponse `json:"updateAttachment,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateAttachments *[]AttachmentForResponse `json:"createAttachments,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateBlocklists *[]BlocklistForResponse `json:"createBlocklists,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyCalendarChannelEventAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateCalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"createCalendarChannelEventAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyCalendarChannelEventAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyCalendarChannelEventAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyCalendarChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateCalendarChannels *[]CalendarChannelForResponse `json:"createCalendarChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyCalendarChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyCalendarChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyCalendarEventParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateCalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"createCalendarEventParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyCalendarEventParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyCalendarEventParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyCalendarEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateCalendarEvents *[]CalendarEventForResponse `json:"createCalendarEvents,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyCalendarEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyCalendarEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateCompanies *[]CompanyForResponse `json:"createCompanies,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyConnectedAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateConnectedAccounts *[]ConnectedAccountForResponse `json:"createConnectedAccounts,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyConnectedAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyConnectedAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateDashboards *[]DashboardForResponse `json:"createDashboards,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyFavoriteFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateFavoriteFolders *[]FavoriteFolderForResponse `json:"createFavoriteFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyFavoriteFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyFavoriteFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateFavorites *[]FavoriteForResponse `json:"createFavorites,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyMessageChannelMessageAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateMessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"createMessageChannelMessageAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyMessageChannelMessageAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyMessageChannelMessageAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyMessageChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateMessageChannels *[]MessageChannelForResponse `json:"createMessageChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyMessageChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyMessageChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyMessageFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateMessageFolders *[]MessageFolderForResponse `json:"createMessageFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyMessageFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyMessageFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyMessageParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateMessageParticipants *[]MessageParticipantForResponse `json:"createMessageParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyMessageParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyMessageParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyMessageThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateMessageThreads *[]MessageThreadForResponse `json:"createMessageThreads,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyMessageThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyMessageThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateMessages *[]MessageForResponse `json:"createMessages,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyNoteTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateNoteTargets *[]NoteTargetForResponse `json:"createNoteTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyNoteTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyNoteTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateNotes *[]NoteForResponse `json:"createNotes,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyOpportunitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateOpportunities *[]OpportunityForResponse `json:"createOpportunities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyOpportunitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyOpportunitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreatePeople *[]PersonForResponse `json:"createPeople,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyTaskTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateTaskTargets *[]TaskTargetForResponse `json:"createTaskTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyTaskTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyTaskTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateTasks *[]TaskForResponse `json:"createTasks,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyTimelineActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateTimelineActivities *[]TimelineActivityForResponse `json:"createTimelineActivities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyTimelineActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyTimelineActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyWorkflowAutomatedTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateWorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"createWorkflowAutomatedTriggers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyWorkflowAutomatedTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyWorkflowAutomatedTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateWorkflowRuns *[]WorkflowRunForResponse `json:"createWorkflowRuns,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyWorkflowVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateWorkflowVersions *[]WorkflowVersionForResponse `json:"createWorkflowVersions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyWorkflowVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyWorkflowVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateWorkflows *[]WorkflowForResponse `json:"createWorkflows,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManyWorkspaceMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			CreateWorkspaceMembers *[]WorkspaceMemberForResponse `json:"createWorkspaceMembers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateManyWorkspaceMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManyWorkspaceMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteBlocklists *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteBlocklists,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Blocklists *[]BlocklistForResponse `json:"blocklists,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateBlocklists *[]BlocklistForResponse `json:"updateBlocklists,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneBlocklistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateBlocklist Blocklist
			CreateBlocklist *BlocklistForResponse `json:"createBlocklist,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneBlocklistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneBlocklistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindBlocklistDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			BlocklistDuplicates *[]BlocklistForResponse `json:"blocklistDuplicates,omitempty"`
			PageInfo            *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindBlocklistDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindBlocklistDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeBlocklists Blocklist
			MergeBlocklists *BlocklistForResponse `json:"mergeBlocklists,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneBlocklistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteBlocklist *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteBlocklist,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneBlocklistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneBlocklistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneBlocklistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Blocklist Blocklist
			Blocklist *BlocklistForResponse `json:"blocklist,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneBlocklistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneBlocklistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneBlocklistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateBlocklist Blocklist
			UpdateBlocklist *BlocklistForResponse `json:"updateBlocklist,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneBlocklistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneBlocklistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyCalendarChannelEventAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarChannelEventAssociations *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarChannelEventAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyCalendarChannelEventAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyCalendarChannelEventAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyCalendarChannelEventAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			CalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"calendarChannelEventAssociations,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyCalendarChannelEventAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyCalendarChannelEventAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyCalendarChannelEventAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateCalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"updateCalendarChannelEventAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyCalendarChannelEventAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyCalendarChannelEventAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneCalendarChannelEventAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateCalendarChannelEventAssociation Calendar Channel Event Associations
			CreateCalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"createCalendarChannelEventAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneCalendarChannelEventAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneCalendarChannelEventAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCalendarChannelEventAssociationDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			CalendarChannelEventAssociationDuplicates *[]CalendarChannelEventAssociationForResponse `json:"calendarChannelEventAssociationDuplicates,omitempty"`
			PageInfo                                  *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindCalendarChannelEventAssociationDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCalendarChannelEventAssociationDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyCalendarChannelEventAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeCalendarChannelEventAssociations Calendar Channel Event Associations
			MergeCalendarChannelEventAssociations *CalendarChannelEventAssociationForResponse `json:"mergeCalendarChannelEventAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyCalendarChannelEventAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyCalendarChannelEventAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneCalendarChannelEventAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarChannelEventAssociation *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarChannelEventAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneCalendarChannelEventAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneCalendarChannelEventAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneCalendarChannelEventAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// CalendarChannelEventAssociation Calendar Channel Event Associations
			CalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"calendarChannelEventAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneCalendarChannelEventAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneCalendarChannelEventAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneCalendarChannelEventAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateCalendarChannelEventAssociation Calendar Channel Event Associations
			UpdateCalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"updateCalendarChannelEventAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneCalendarChannelEventAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneCalendarChannelEventAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyCalendarChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarChannels *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyCalendarChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyCalendarChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyCalendarChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			CalendarChannels *[]CalendarChannelForResponse `json:"calendarChannels,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyCalendarChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyCalendarChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyCalendarChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateCalendarChannels *[]CalendarChannelForResponse `json:"updateCalendarChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyCalendarChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyCalendarChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneCalendarChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateCalendarChannel Calendar Channels
			CreateCalendarChannel *CalendarChannelForResponse `json:"createCalendarChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneCalendarChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneCalendarChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCalendarChannelDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			CalendarChannelDuplicates *[]CalendarChannelForResponse `json:"calendarChannelDuplicates,omitempty"`
			PageInfo                  *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindCalendarChannelDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCalendarChannelDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyCalendarChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeCalendarChannels Calendar Channels
			MergeCalendarChannels *CalendarChannelForResponse `json:"mergeCalendarChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyCalendarChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyCalendarChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneCalendarChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarChannel *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneCalendarChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneCalendarChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneCalendarChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// CalendarChannel Calendar Channels
			CalendarChannel *CalendarChannelForResponse `json:"calendarChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneCalendarChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneCalendarChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneCalendarChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateCalendarChannel Calendar Channels
			UpdateCalendarChannel *CalendarChannelForResponse `json:"updateCalendarChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneCalendarChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneCalendarChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyCalendarEventParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarEventParticipants *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarEventParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyCalendarEventParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyCalendarEventParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyCalendarEventParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			CalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"calendarEventParticipants,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyCalendarEventParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyCalendarEventParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyCalendarEventParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateCalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"updateCalendarEventParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyCalendarEventParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyCalendarEventParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneCalendarEventParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateCalendarEventParticipant Calendar event participants
			CreateCalendarEventParticipant *CalendarEventParticipantForResponse `json:"createCalendarEventParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneCalendarEventParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneCalendarEventParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCalendarEventParticipantDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			CalendarEventParticipantDuplicates *[]CalendarEventParticipantForResponse `json:"calendarEventParticipantDuplicates,omitempty"`
			PageInfo                           *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindCalendarEventParticipantDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCalendarEventParticipantDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyCalendarEventParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeCalendarEventParticipants Calendar event participants
			MergeCalendarEventParticipants *CalendarEventParticipantForResponse `json:"mergeCalendarEventParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyCalendarEventParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyCalendarEventParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneCalendarEventParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarEventParticipant *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarEventParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneCalendarEventParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneCalendarEventParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneCalendarEventParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// CalendarEventParticipant Calendar event participants
			CalendarEventParticipant *CalendarEventParticipantForResponse `json:"calendarEventParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneCalendarEventParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneCalendarEventParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneCalendarEventParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateCalendarEventParticipant Calendar event participants
			UpdateCalendarEventParticipant *CalendarEventParticipantForResponse `json:"updateCalendarEventParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneCalendarEventParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneCalendarEventParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyCalendarEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarEvents *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarEvents,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyCalendarEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyCalendarEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyCalendarEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			CalendarEvents *[]CalendarEventForResponse `json:"calendarEvents,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyCalendarEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyCalendarEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyCalendarEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateCalendarEvents *[]CalendarEventForResponse `json:"updateCalendarEvents,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyCalendarEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyCalendarEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneCalendarEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateCalendarEvent Calendar events
			CreateCalendarEvent *CalendarEventForResponse `json:"createCalendarEvent,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneCalendarEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneCalendarEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCalendarEventDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			CalendarEventDuplicates *[]CalendarEventForResponse `json:"calendarEventDuplicates,omitempty"`
			PageInfo                *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindCalendarEventDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCalendarEventDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyCalendarEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeCalendarEvents Calendar events
			MergeCalendarEvents *CalendarEventForResponse `json:"mergeCalendarEvents,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyCalendarEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyCalendarEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneCalendarEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCalendarEvent *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCalendarEvent,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneCalendarEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneCalendarEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneCalendarEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// CalendarEvent Calendar events
			CalendarEvent *CalendarEventForResponse `json:"calendarEvent,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneCalendarEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneCalendarEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneCalendarEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateCalendarEvent Calendar events
			UpdateCalendarEvent *CalendarEventForResponse `json:"updateCalendarEvent,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneCalendarEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneCalendarEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCompanies *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCompanies,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Companies *[]CompanyForResponse `json:"companies,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateCompanies *[]CompanyForResponse `json:"updateCompanies,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateCompany A company
			CreateCompany *CompanyForResponse `json:"createCompany,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCompanyDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			CompanyDuplicates *[]CompanyForResponse `json:"companyDuplicates,omitempty"`
			PageInfo          *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindCompanyDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCompanyDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeCompanies A company
			MergeCompanies *CompanyForResponse `json:"mergeCompanies,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteCompany *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteCompany,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Company A company
			Company *CompanyForResponse `json:"company,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateCompany A company
			UpdateCompany *CompanyForResponse `json:"updateCompany,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyConnectedAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteConnectedAccounts *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteConnectedAccounts,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyConnectedAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyConnectedAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyConnectedAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			ConnectedAccounts *[]ConnectedAccountForResponse `json:"connectedAccounts,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyConnectedAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyConnectedAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyConnectedAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateConnectedAccounts *[]ConnectedAccountForResponse `json:"updateConnectedAccounts,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyConnectedAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyConnectedAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneConnectedAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateConnectedAccount A connected account
			CreateConnectedAccount *ConnectedAccountForResponse `json:"createConnectedAccount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneConnectedAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneConnectedAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindConnectedAccountDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			ConnectedAccountDuplicates *[]ConnectedAccountForResponse `json:"connectedAccountDuplicates,omitempty"`
			PageInfo                   *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindConnectedAccountDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindConnectedAccountDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyConnectedAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeConnectedAccounts A connected account
			MergeConnectedAccounts *ConnectedAccountForResponse `json:"mergeConnectedAccounts,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyConnectedAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyConnectedAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneConnectedAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteConnectedAccount *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteConnectedAccount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneConnectedAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneConnectedAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneConnectedAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// ConnectedAccount A connected account
			ConnectedAccount *ConnectedAccountForResponse `json:"connectedAccount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneConnectedAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneConnectedAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneConnectedAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateConnectedAccount A connected account
			UpdateConnectedAccount *ConnectedAccountForResponse `json:"updateConnectedAccount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneConnectedAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneConnectedAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteDashboards *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteDashboards,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Dashboards *[]DashboardForResponse `json:"dashboards,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateDashboards *[]DashboardForResponse `json:"updateDashboards,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateDashboard A dashboard
			CreateDashboard *DashboardForResponse `json:"createDashboard,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindDashboardDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			DashboardDuplicates *[]DashboardForResponse `json:"dashboardDuplicates,omitempty"`
			PageInfo            *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindDashboardDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindDashboardDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeDashboards A dashboard
			MergeDashboards *DashboardForResponse `json:"mergeDashboards,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteDashboard *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteDashboard,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Dashboard A dashboard
			Dashboard *DashboardForResponse `json:"dashboard,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateDashboard A dashboard
			UpdateDashboard *DashboardForResponse `json:"updateDashboard,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuplicateDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DashboardForResponse
	JSON400      *N400
	JSON401      *N401
}

// Status returns HTTPResponse.Status
func (r DuplicateDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuplicateDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyFavoriteFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteFavoriteFolders *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteFavoriteFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyFavoriteFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyFavoriteFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyFavoriteFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			FavoriteFolders *[]FavoriteFolderForResponse `json:"favoriteFolders,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyFavoriteFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyFavoriteFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyFavoriteFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateFavoriteFolders *[]FavoriteFolderForResponse `json:"updateFavoriteFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyFavoriteFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyFavoriteFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneFavoriteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateFavoriteFolder A Folder of favorites
			CreateFavoriteFolder *FavoriteFolderForResponse `json:"createFavoriteFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneFavoriteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneFavoriteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindFavoriteFolderDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			FavoriteFolderDuplicates *[]FavoriteFolderForResponse `json:"favoriteFolderDuplicates,omitempty"`
			PageInfo                 *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindFavoriteFolderDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindFavoriteFolderDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyFavoriteFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeFavoriteFolders A Folder of favorites
			MergeFavoriteFolders *FavoriteFolderForResponse `json:"mergeFavoriteFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyFavoriteFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyFavoriteFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneFavoriteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteFavoriteFolder *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteFavoriteFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneFavoriteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneFavoriteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneFavoriteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// FavoriteFolder A Folder of favorites
			FavoriteFolder *FavoriteFolderForResponse `json:"favoriteFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneFavoriteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneFavoriteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneFavoriteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateFavoriteFolder A Folder of favorites
			UpdateFavoriteFolder *FavoriteFolderForResponse `json:"updateFavoriteFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneFavoriteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneFavoriteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteFavorites *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteFavorites,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Favorites *[]FavoriteForResponse `json:"favorites,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateFavorites *[]FavoriteForResponse `json:"updateFavorites,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateFavorite A favorite that can be accessed from the left menu
			CreateFavorite *FavoriteForResponse `json:"createFavorite,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindFavoriteDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			FavoriteDuplicates *[]FavoriteForResponse `json:"favoriteDuplicates,omitempty"`
			PageInfo           *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindFavoriteDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindFavoriteDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeFavorites A favorite that can be accessed from the left menu
			MergeFavorites *FavoriteForResponse `json:"mergeFavorites,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteFavorite *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteFavorite,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Favorite A favorite that can be accessed from the left menu
			Favorite *FavoriteForResponse `json:"favorite,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateFavorite A favorite that can be accessed from the left menu
			UpdateFavorite *FavoriteForResponse `json:"updateFavorite,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyMessageChannelMessageAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageChannelMessageAssociations *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageChannelMessageAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyMessageChannelMessageAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyMessageChannelMessageAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyMessageChannelMessageAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			MessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"messageChannelMessageAssociations,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyMessageChannelMessageAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyMessageChannelMessageAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyMessageChannelMessageAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateMessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"updateMessageChannelMessageAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyMessageChannelMessageAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyMessageChannelMessageAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneMessageChannelMessageAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateMessageChannelMessageAssociation Message Synced with a Message Channel
			CreateMessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"createMessageChannelMessageAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneMessageChannelMessageAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneMessageChannelMessageAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMessageChannelMessageAssociationDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			MessageChannelMessageAssociationDuplicates *[]MessageChannelMessageAssociationForResponse `json:"messageChannelMessageAssociationDuplicates,omitempty"`
			PageInfo                                   *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindMessageChannelMessageAssociationDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMessageChannelMessageAssociationDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyMessageChannelMessageAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeMessageChannelMessageAssociations Message Synced with a Message Channel
			MergeMessageChannelMessageAssociations *MessageChannelMessageAssociationForResponse `json:"mergeMessageChannelMessageAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyMessageChannelMessageAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyMessageChannelMessageAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneMessageChannelMessageAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageChannelMessageAssociation *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageChannelMessageAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneMessageChannelMessageAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneMessageChannelMessageAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneMessageChannelMessageAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MessageChannelMessageAssociation Message Synced with a Message Channel
			MessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"messageChannelMessageAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneMessageChannelMessageAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneMessageChannelMessageAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneMessageChannelMessageAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateMessageChannelMessageAssociation Message Synced with a Message Channel
			UpdateMessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"updateMessageChannelMessageAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneMessageChannelMessageAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneMessageChannelMessageAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyMessageChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageChannels *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyMessageChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyMessageChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyMessageChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			MessageChannels *[]MessageChannelForResponse `json:"messageChannels,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyMessageChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyMessageChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyMessageChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateMessageChannels *[]MessageChannelForResponse `json:"updateMessageChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyMessageChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyMessageChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneMessageChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateMessageChannel Message Channels
			CreateMessageChannel *MessageChannelForResponse `json:"createMessageChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneMessageChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneMessageChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMessageChannelDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			MessageChannelDuplicates *[]MessageChannelForResponse `json:"messageChannelDuplicates,omitempty"`
			PageInfo                 *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindMessageChannelDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMessageChannelDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyMessageChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeMessageChannels Message Channels
			MergeMessageChannels *MessageChannelForResponse `json:"mergeMessageChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyMessageChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyMessageChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneMessageChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageChannel *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneMessageChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneMessageChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneMessageChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MessageChannel Message Channels
			MessageChannel *MessageChannelForResponse `json:"messageChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneMessageChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneMessageChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneMessageChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateMessageChannel Message Channels
			UpdateMessageChannel *MessageChannelForResponse `json:"updateMessageChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneMessageChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneMessageChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyMessageFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageFolders *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyMessageFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyMessageFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyMessageFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			MessageFolders *[]MessageFolderForResponse `json:"messageFolders,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyMessageFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyMessageFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyMessageFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateMessageFolders *[]MessageFolderForResponse `json:"updateMessageFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyMessageFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyMessageFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneMessageFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateMessageFolder Folder for Message Channel
			CreateMessageFolder *MessageFolderForResponse `json:"createMessageFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneMessageFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneMessageFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMessageFolderDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			MessageFolderDuplicates *[]MessageFolderForResponse `json:"messageFolderDuplicates,omitempty"`
			PageInfo                *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindMessageFolderDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMessageFolderDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyMessageFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeMessageFolders Folder for Message Channel
			MergeMessageFolders *MessageFolderForResponse `json:"mergeMessageFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyMessageFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyMessageFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneMessageFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageFolder *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneMessageFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneMessageFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneMessageFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MessageFolder Folder for Message Channel
			MessageFolder *MessageFolderForResponse `json:"messageFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneMessageFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneMessageFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneMessageFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateMessageFolder Folder for Message Channel
			UpdateMessageFolder *MessageFolderForResponse `json:"updateMessageFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneMessageFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneMessageFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyMessageParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageParticipants *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyMessageParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyMessageParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyMessageParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			MessageParticipants *[]MessageParticipantForResponse `json:"messageParticipants,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyMessageParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyMessageParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyMessageParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateMessageParticipants *[]MessageParticipantForResponse `json:"updateMessageParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyMessageParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyMessageParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneMessageParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateMessageParticipant Message Participants
			CreateMessageParticipant *MessageParticipantForResponse `json:"createMessageParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneMessageParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneMessageParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMessageParticipantDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			MessageParticipantDuplicates *[]MessageParticipantForResponse `json:"messageParticipantDuplicates,omitempty"`
			PageInfo                     *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindMessageParticipantDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMessageParticipantDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyMessageParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeMessageParticipants Message Participants
			MergeMessageParticipants *MessageParticipantForResponse `json:"mergeMessageParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyMessageParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyMessageParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneMessageParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageParticipant *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneMessageParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneMessageParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneMessageParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MessageParticipant Message Participants
			MessageParticipant *MessageParticipantForResponse `json:"messageParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneMessageParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneMessageParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneMessageParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateMessageParticipant Message Participants
			UpdateMessageParticipant *MessageParticipantForResponse `json:"updateMessageParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneMessageParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneMessageParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyMessageThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageThreads *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageThreads,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyMessageThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyMessageThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyMessageThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			MessageThreads *[]MessageThreadForResponse `json:"messageThreads,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyMessageThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyMessageThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyMessageThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateMessageThreads *[]MessageThreadForResponse `json:"updateMessageThreads,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyMessageThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyMessageThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneMessageThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateMessageThread A group of related messages (e.g. email thread, chat thread)
			CreateMessageThread *MessageThreadForResponse `json:"createMessageThread,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneMessageThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneMessageThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMessageThreadDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			MessageThreadDuplicates *[]MessageThreadForResponse `json:"messageThreadDuplicates,omitempty"`
			PageInfo                *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindMessageThreadDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMessageThreadDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyMessageThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeMessageThreads A group of related messages (e.g. email thread, chat thread)
			MergeMessageThreads *MessageThreadForResponse `json:"mergeMessageThreads,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyMessageThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyMessageThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneMessageThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessageThread *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessageThread,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneMessageThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneMessageThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneMessageThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MessageThread A group of related messages (e.g. email thread, chat thread)
			MessageThread *MessageThreadForResponse `json:"messageThread,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneMessageThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneMessageThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneMessageThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateMessageThread A group of related messages (e.g. email thread, chat thread)
			UpdateMessageThread *MessageThreadForResponse `json:"updateMessageThread,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneMessageThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneMessageThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessages *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessages,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Messages *[]MessageForResponse `json:"messages,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateMessages *[]MessageForResponse `json:"updateMessages,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateMessage A message sent or received through a messaging channel (email, chat, etc.)
			CreateMessage *MessageForResponse `json:"createMessage,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMessageDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			MessageDuplicates *[]MessageForResponse `json:"messageDuplicates,omitempty"`
			PageInfo          *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindMessageDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMessageDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeMessages A message sent or received through a messaging channel (email, chat, etc.)
			MergeMessages *MessageForResponse `json:"mergeMessages,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteMessage *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteMessage,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Message A message sent or received through a messaging channel (email, chat, etc.)
			Message *MessageForResponse `json:"message,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateMessage A message sent or received through a messaging channel (email, chat, etc.)
			UpdateMessage *MessageForResponse `json:"updateMessage,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyNoteTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteNoteTargets *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteNoteTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyNoteTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyNoteTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyNoteTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			NoteTargets *[]NoteTargetForResponse `json:"noteTargets,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyNoteTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyNoteTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyNoteTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateNoteTargets *[]NoteTargetForResponse `json:"updateNoteTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyNoteTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyNoteTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneNoteTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateNoteTarget A note target
			CreateNoteTarget *NoteTargetForResponse `json:"createNoteTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneNoteTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneNoteTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindNoteTargetDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			NoteTargetDuplicates *[]NoteTargetForResponse `json:"noteTargetDuplicates,omitempty"`
			PageInfo             *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindNoteTargetDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindNoteTargetDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyNoteTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeNoteTargets A note target
			MergeNoteTargets *NoteTargetForResponse `json:"mergeNoteTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyNoteTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyNoteTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneNoteTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteNoteTarget *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteNoteTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneNoteTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneNoteTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneNoteTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// NoteTarget A note target
			NoteTarget *NoteTargetForResponse `json:"noteTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneNoteTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneNoteTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneNoteTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateNoteTarget A note target
			UpdateNoteTarget *NoteTargetForResponse `json:"updateNoteTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneNoteTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneNoteTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteNotes *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteNotes,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Notes *[]NoteForResponse `json:"notes,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateNotes *[]NoteForResponse `json:"updateNotes,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateNote A note
			CreateNote *NoteForResponse `json:"createNote,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindNoteDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			NoteDuplicates *[]NoteForResponse `json:"noteDuplicates,omitempty"`
			PageInfo       *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindNoteDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindNoteDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeNotes A note
			MergeNotes *NoteForResponse `json:"mergeNotes,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteNote *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteNote,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Note A note
			Note *NoteForResponse `json:"note,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateNote A note
			UpdateNote *NoteForResponse `json:"updateNote,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenApiSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Components *struct {
			Parameters *map[string]interface{} `json:"parameters,omitempty"`
			Responses  *map[string]interface{} `json:"responses,omitempty"`
			Schemas    *map[string]interface{} `json:"schemas,omitempty"`
		} `json:"components,omitempty"`
		Info *struct {
			Contact *struct {
				Email *string `json:"email,omitempty"`
			} `json:"contact,omitempty"`
			Description *string `json:"description,omitempty"`
			License     *struct {
				Name *string `json:"name,omitempty"`
				Url  *string `json:"url,omitempty"`
			} `json:"license,omitempty"`
			TermsOfService *string `json:"termsOfService,omitempty"`
			Title          *string `json:"title,omitempty"`
		} `json:"info,omitempty"`
		Openapi *string                 `json:"openapi,omitempty"`
		Paths   *map[string]interface{} `json:"paths,omitempty"`
		Servers *[]struct {
			Description *string `json:"description,omitempty"`
			Url         *string `json:"url,omitempty"`
		} `json:"servers,omitempty"`
		Tags *map[string]interface{} `json:"tags,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOpenApiSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenApiSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyOpportunitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteOpportunities *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteOpportunities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyOpportunitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyOpportunitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyOpportunitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Opportunities *[]OpportunityForResponse `json:"opportunities,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyOpportunitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyOpportunitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyOpportunitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateOpportunities *[]OpportunityForResponse `json:"updateOpportunities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyOpportunitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyOpportunitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneOpportunityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateOpportunity An opportunity
			CreateOpportunity *OpportunityForResponse `json:"createOpportunity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneOpportunityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneOpportunityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOpportunityDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			OpportunityDuplicates *[]OpportunityForResponse `json:"opportunityDuplicates,omitempty"`
			PageInfo              *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *float32 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOpportunityDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOpportunityDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyOpportunitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeOpportunities An opportunity
			MergeOpportunities *OpportunityForResponse `json:"mergeOpportunities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyOpportunitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyOpportunitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneOpportunityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteOpportunity *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteOpportunity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneOpportunityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneOpportunityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneOpportunityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Opportunity An opportunity
			Opportunity *OpportunityForResponse `json:"opportunity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneOpportunityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneOpportunityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneOpportunityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateOpportunity An opportunity
			UpdateOpportunity *OpportunityForResponse `json:"updateOpportunity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneOpportunityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneOpportunityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeletePeople *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deletePeople,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			People *[]PersonForResponse `json:"people,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdatePeople *[]PersonForResponse `json:"updatePeople,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOnePersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreatePerson A person
			CreatePerson *PersonForResponse `json:"createPerson,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOnePersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOnePersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPersonDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			PersonDuplicates *[]PersonForResponse `json:"personDuplicates,omitempty"`
			TotalCount       *float32             `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindPersonDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPersonDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergePeople A person
			MergePeople *PersonForResponse `json:"mergePeople,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOnePersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeletePerson *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deletePerson,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOnePersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOnePersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOnePersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Person A person
			Person *PersonForResponse `json:"person,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOnePersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOnePersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOnePersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdatePerson A person
			UpdatePerson *PersonForResponse `json:"updatePerson,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOnePersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOnePersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreAttachments *[]AttachmentForResponse `json:"restoreAttachments,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreAttachment An attachment
			RestoreAttachment *AttachmentForResponse `json:"restoreAttachment,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyBlocklistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreBlocklists *[]BlocklistForResponse `json:"restoreBlocklists,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyBlocklistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyBlocklistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneBlocklistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreBlocklist Blocklist
			RestoreBlocklist *BlocklistForResponse `json:"restoreBlocklist,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneBlocklistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneBlocklistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyCalendarChannelEventAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreCalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"restoreCalendarChannelEventAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyCalendarChannelEventAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyCalendarChannelEventAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneCalendarChannelEventAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreCalendarChannelEventAssociation Calendar Channel Event Associations
			RestoreCalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"restoreCalendarChannelEventAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneCalendarChannelEventAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneCalendarChannelEventAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyCalendarChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreCalendarChannels *[]CalendarChannelForResponse `json:"restoreCalendarChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyCalendarChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyCalendarChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneCalendarChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreCalendarChannel Calendar Channels
			RestoreCalendarChannel *CalendarChannelForResponse `json:"restoreCalendarChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneCalendarChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneCalendarChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyCalendarEventParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreCalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"restoreCalendarEventParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyCalendarEventParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyCalendarEventParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneCalendarEventParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreCalendarEventParticipant Calendar event participants
			RestoreCalendarEventParticipant *CalendarEventParticipantForResponse `json:"restoreCalendarEventParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneCalendarEventParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneCalendarEventParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyCalendarEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreCalendarEvents *[]CalendarEventForResponse `json:"restoreCalendarEvents,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyCalendarEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyCalendarEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneCalendarEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreCalendarEvent Calendar events
			RestoreCalendarEvent *CalendarEventForResponse `json:"restoreCalendarEvent,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneCalendarEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneCalendarEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreCompanies *[]CompanyForResponse `json:"restoreCompanies,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreCompany A company
			RestoreCompany *CompanyForResponse `json:"restoreCompany,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyConnectedAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreConnectedAccounts *[]ConnectedAccountForResponse `json:"restoreConnectedAccounts,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyConnectedAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyConnectedAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneConnectedAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreConnectedAccount A connected account
			RestoreConnectedAccount *ConnectedAccountForResponse `json:"restoreConnectedAccount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneConnectedAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneConnectedAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreDashboards *[]DashboardForResponse `json:"restoreDashboards,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreDashboard A dashboard
			RestoreDashboard *DashboardForResponse `json:"restoreDashboard,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyFavoriteFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreFavoriteFolders *[]FavoriteFolderForResponse `json:"restoreFavoriteFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyFavoriteFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyFavoriteFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneFavoriteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreFavoriteFolder A Folder of favorites
			RestoreFavoriteFolder *FavoriteFolderForResponse `json:"restoreFavoriteFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneFavoriteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneFavoriteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreFavorites *[]FavoriteForResponse `json:"restoreFavorites,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneFavoriteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreFavorite A favorite that can be accessed from the left menu
			RestoreFavorite *FavoriteForResponse `json:"restoreFavorite,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneFavoriteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneFavoriteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyMessageChannelMessageAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreMessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"restoreMessageChannelMessageAssociations,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyMessageChannelMessageAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyMessageChannelMessageAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneMessageChannelMessageAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreMessageChannelMessageAssociation Message Synced with a Message Channel
			RestoreMessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"restoreMessageChannelMessageAssociation,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneMessageChannelMessageAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneMessageChannelMessageAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyMessageChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreMessageChannels *[]MessageChannelForResponse `json:"restoreMessageChannels,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyMessageChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyMessageChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneMessageChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreMessageChannel Message Channels
			RestoreMessageChannel *MessageChannelForResponse `json:"restoreMessageChannel,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneMessageChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneMessageChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyMessageFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreMessageFolders *[]MessageFolderForResponse `json:"restoreMessageFolders,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyMessageFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyMessageFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneMessageFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreMessageFolder Folder for Message Channel
			RestoreMessageFolder *MessageFolderForResponse `json:"restoreMessageFolder,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneMessageFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneMessageFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyMessageParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreMessageParticipants *[]MessageParticipantForResponse `json:"restoreMessageParticipants,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyMessageParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyMessageParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneMessageParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreMessageParticipant Message Participants
			RestoreMessageParticipant *MessageParticipantForResponse `json:"restoreMessageParticipant,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneMessageParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneMessageParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyMessageThreadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreMessageThreads *[]MessageThreadForResponse `json:"restoreMessageThreads,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyMessageThreadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyMessageThreadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneMessageThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreMessageThread A group of related messages (e.g. email thread, chat thread)
			RestoreMessageThread *MessageThreadForResponse `json:"restoreMessageThread,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneMessageThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneMessageThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreMessages *[]MessageForResponse `json:"restoreMessages,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreMessage A message sent or received through a messaging channel (email, chat, etc.)
			RestoreMessage *MessageForResponse `json:"restoreMessage,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyNoteTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreNoteTargets *[]NoteTargetForResponse `json:"restoreNoteTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyNoteTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyNoteTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneNoteTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreNoteTarget A note target
			RestoreNoteTarget *NoteTargetForResponse `json:"restoreNoteTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneNoteTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneNoteTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreNotes *[]NoteForResponse `json:"restoreNotes,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreNote A note
			RestoreNote *NoteForResponse `json:"restoreNote,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyOpportunitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreOpportunities *[]OpportunityForResponse `json:"restoreOpportunities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyOpportunitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyOpportunitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneOpportunityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreOpportunity An opportunity
			RestoreOpportunity *OpportunityForResponse `json:"restoreOpportunity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneOpportunityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneOpportunityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestorePeople *[]PersonForResponse `json:"restorePeople,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOnePersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestorePerson A person
			RestorePerson *PersonForResponse `json:"restorePerson,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOnePersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOnePersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyTaskTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreTaskTargets *[]TaskTargetForResponse `json:"restoreTaskTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyTaskTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyTaskTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneTaskTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreTaskTarget A task target
			RestoreTaskTarget *TaskTargetForResponse `json:"restoreTaskTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneTaskTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneTaskTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreTasks *[]TaskForResponse `json:"restoreTasks,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreTask A task
			RestoreTask *TaskForResponse `json:"restoreTask,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyTimelineActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreTimelineActivities *[]TimelineActivityForResponse `json:"restoreTimelineActivities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyTimelineActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyTimelineActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneTimelineActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreTimelineActivity Aggregated / filtered event to be displayed on the timeline
			RestoreTimelineActivity *TimelineActivityForResponse `json:"restoreTimelineActivity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneTimelineActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneTimelineActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyWorkflowAutomatedTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreWorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"restoreWorkflowAutomatedTriggers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyWorkflowAutomatedTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyWorkflowAutomatedTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneWorkflowAutomatedTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreWorkflowAutomatedTrigger A workflow automated trigger
			RestoreWorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"restoreWorkflowAutomatedTrigger,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneWorkflowAutomatedTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneWorkflowAutomatedTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreWorkflowRuns *[]WorkflowRunForResponse `json:"restoreWorkflowRuns,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreWorkflowRun A workflow run
			RestoreWorkflowRun *WorkflowRunForResponse `json:"restoreWorkflowRun,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyWorkflowVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreWorkflowVersions *[]WorkflowVersionForResponse `json:"restoreWorkflowVersions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyWorkflowVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyWorkflowVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneWorkflowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreWorkflowVersion A workflow version
			RestoreWorkflowVersion *WorkflowVersionForResponse `json:"restoreWorkflowVersion,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneWorkflowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneWorkflowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreWorkflows *[]WorkflowForResponse `json:"restoreWorkflows,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreWorkflow A workflow
			RestoreWorkflow *WorkflowForResponse `json:"restoreWorkflow,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreManyWorkspaceMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			RestoreWorkspaceMembers *[]WorkspaceMemberForResponse `json:"restoreWorkspaceMembers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreManyWorkspaceMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreManyWorkspaceMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreOneWorkspaceMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// RestoreWorkspaceMember A workspace member
			RestoreWorkspaceMember *WorkspaceMemberForResponse `json:"restoreWorkspaceMember,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r RestoreOneWorkspaceMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreOneWorkspaceMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyTaskTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteTaskTargets *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteTaskTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyTaskTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyTaskTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyTaskTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			TaskTargets *[]TaskTargetForResponse `json:"taskTargets,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyTaskTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyTaskTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyTaskTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateTaskTargets *[]TaskTargetForResponse `json:"updateTaskTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyTaskTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyTaskTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneTaskTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateTaskTarget A task target
			CreateTaskTarget *TaskTargetForResponse `json:"createTaskTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneTaskTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneTaskTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindTaskTargetDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TaskTargetDuplicates *[]TaskTargetForResponse `json:"taskTargetDuplicates,omitempty"`
			TotalCount           *float32                 `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindTaskTargetDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindTaskTargetDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyTaskTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeTaskTargets A task target
			MergeTaskTargets *TaskTargetForResponse `json:"mergeTaskTargets,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyTaskTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyTaskTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneTaskTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteTaskTarget *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteTaskTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneTaskTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneTaskTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneTaskTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// TaskTarget A task target
			TaskTarget *TaskTargetForResponse `json:"taskTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneTaskTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneTaskTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneTaskTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateTaskTarget A task target
			UpdateTaskTarget *TaskTargetForResponse `json:"updateTaskTarget,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneTaskTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneTaskTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteTasks *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteTasks,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Tasks *[]TaskForResponse `json:"tasks,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateTasks *[]TaskForResponse `json:"updateTasks,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateTask A task
			CreateTask *TaskForResponse `json:"createTask,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindTaskDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TaskDuplicates *[]TaskForResponse `json:"taskDuplicates,omitempty"`
			TotalCount     *float32           `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindTaskDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindTaskDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeTasks A task
			MergeTasks *TaskForResponse `json:"mergeTasks,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteTask *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteTask,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Task A task
			Task *TaskForResponse `json:"task,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateTask A task
			UpdateTask *TaskForResponse `json:"updateTask,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyTimelineActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteTimelineActivities *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteTimelineActivities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyTimelineActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyTimelineActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyTimelineActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			TimelineActivities *[]TimelineActivityForResponse `json:"timelineActivities,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyTimelineActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyTimelineActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyTimelineActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateTimelineActivities *[]TimelineActivityForResponse `json:"updateTimelineActivities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyTimelineActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyTimelineActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneTimelineActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateTimelineActivity Aggregated / filtered event to be displayed on the timeline
			CreateTimelineActivity *TimelineActivityForResponse `json:"createTimelineActivity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneTimelineActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneTimelineActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindTimelineActivityDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TimelineActivityDuplicates *[]TimelineActivityForResponse `json:"timelineActivityDuplicates,omitempty"`
			TotalCount                 *float32                       `json:"totalCount,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindTimelineActivityDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindTimelineActivityDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyTimelineActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeTimelineActivities Aggregated / filtered event to be displayed on the timeline
			MergeTimelineActivities *TimelineActivityForResponse `json:"mergeTimelineActivities,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyTimelineActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyTimelineActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneTimelineActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteTimelineActivity *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteTimelineActivity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneTimelineActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneTimelineActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneTimelineActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// TimelineActivity Aggregated / filtered event to be displayed on the timeline
			TimelineActivity *TimelineActivityForResponse `json:"timelineActivity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneTimelineActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneTimelineActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneTimelineActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateTimelineActivity Aggregated / filtered event to be displayed on the timeline
			UpdateTimelineActivity *TimelineActivityForResponse `json:"updateTimelineActivity,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneTimelineActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneTimelineActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyWorkflowAutomatedTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflowAutomatedTriggers *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflowAutomatedTriggers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyWorkflowAutomatedTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyWorkflowAutomatedTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyWorkflowAutomatedTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			WorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"workflowAutomatedTriggers,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyWorkflowAutomatedTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyWorkflowAutomatedTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyWorkflowAutomatedTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateWorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"updateWorkflowAutomatedTriggers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyWorkflowAutomatedTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyWorkflowAutomatedTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneWorkflowAutomatedTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateWorkflowAutomatedTrigger A workflow automated trigger
			CreateWorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"createWorkflowAutomatedTrigger,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneWorkflowAutomatedTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneWorkflowAutomatedTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindWorkflowAutomatedTriggerDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount                         *float32                               `json:"totalCount,omitempty"`
			WorkflowAutomatedTriggerDuplicates *[]WorkflowAutomatedTriggerForResponse `json:"workflowAutomatedTriggerDuplicates,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindWorkflowAutomatedTriggerDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindWorkflowAutomatedTriggerDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyWorkflowAutomatedTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeWorkflowAutomatedTriggers A workflow automated trigger
			MergeWorkflowAutomatedTriggers *WorkflowAutomatedTriggerForResponse `json:"mergeWorkflowAutomatedTriggers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyWorkflowAutomatedTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyWorkflowAutomatedTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneWorkflowAutomatedTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflowAutomatedTrigger *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflowAutomatedTrigger,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneWorkflowAutomatedTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneWorkflowAutomatedTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneWorkflowAutomatedTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// WorkflowAutomatedTrigger A workflow automated trigger
			WorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"workflowAutomatedTrigger,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneWorkflowAutomatedTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneWorkflowAutomatedTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneWorkflowAutomatedTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateWorkflowAutomatedTrigger A workflow automated trigger
			UpdateWorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"updateWorkflowAutomatedTrigger,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneWorkflowAutomatedTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneWorkflowAutomatedTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflowRuns *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflowRuns,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			WorkflowRuns *[]WorkflowRunForResponse `json:"workflowRuns,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateWorkflowRuns *[]WorkflowRunForResponse `json:"updateWorkflowRuns,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateWorkflowRun A workflow run
			CreateWorkflowRun *WorkflowRunForResponse `json:"createWorkflowRun,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindWorkflowRunDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount            *float32                  `json:"totalCount,omitempty"`
			WorkflowRunDuplicates *[]WorkflowRunForResponse `json:"workflowRunDuplicates,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindWorkflowRunDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindWorkflowRunDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeWorkflowRuns A workflow run
			MergeWorkflowRuns *WorkflowRunForResponse `json:"mergeWorkflowRuns,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflowRun *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflowRun,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// WorkflowRun A workflow run
			WorkflowRun *WorkflowRunForResponse `json:"workflowRun,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateWorkflowRun A workflow run
			UpdateWorkflowRun *WorkflowRunForResponse `json:"updateWorkflowRun,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyWorkflowVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflowVersions *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflowVersions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyWorkflowVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyWorkflowVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyWorkflowVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			WorkflowVersions *[]WorkflowVersionForResponse `json:"workflowVersions,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyWorkflowVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyWorkflowVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyWorkflowVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateWorkflowVersions *[]WorkflowVersionForResponse `json:"updateWorkflowVersions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyWorkflowVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyWorkflowVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneWorkflowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateWorkflowVersion A workflow version
			CreateWorkflowVersion *WorkflowVersionForResponse `json:"createWorkflowVersion,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneWorkflowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneWorkflowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindWorkflowVersionDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount                *float32                      `json:"totalCount,omitempty"`
			WorkflowVersionDuplicates *[]WorkflowVersionForResponse `json:"workflowVersionDuplicates,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindWorkflowVersionDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindWorkflowVersionDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyWorkflowVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeWorkflowVersions A workflow version
			MergeWorkflowVersions *WorkflowVersionForResponse `json:"mergeWorkflowVersions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyWorkflowVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyWorkflowVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneWorkflowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflowVersion *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflowVersion,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneWorkflowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneWorkflowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneWorkflowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// WorkflowVersion A workflow version
			WorkflowVersion *WorkflowVersionForResponse `json:"workflowVersion,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneWorkflowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneWorkflowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneWorkflowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateWorkflowVersion A workflow version
			UpdateWorkflowVersion *WorkflowVersionForResponse `json:"updateWorkflowVersion,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneWorkflowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneWorkflowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflows *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflows,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Workflows *[]WorkflowForResponse `json:"workflows,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateWorkflows *[]WorkflowForResponse `json:"updateWorkflows,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateWorkflow A workflow
			CreateWorkflow *WorkflowForResponse `json:"createWorkflow,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindWorkflowDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount         *float32               `json:"totalCount,omitempty"`
			WorkflowDuplicates *[]WorkflowForResponse `json:"workflowDuplicates,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindWorkflowDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindWorkflowDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeWorkflows A workflow
			MergeWorkflows *WorkflowForResponse `json:"mergeWorkflows,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkflow *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkflow,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Workflow A workflow
			Workflow *WorkflowForResponse `json:"workflow,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateWorkflow A workflow
			UpdateWorkflow *WorkflowForResponse `json:"updateWorkflow,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManyWorkspaceMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkspaceMembers *[]struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkspaceMembers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteManyWorkspaceMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManyWorkspaceMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManyWorkspaceMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			WorkspaceMembers *[]WorkspaceMemberForResponse `json:"workspaceMembers,omitempty"`
		} `json:"data,omitempty"`
		PageInfo *struct {
			EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
			HasNextPage *bool               `json:"hasNextPage,omitempty"`
			StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
		} `json:"pageInfo,omitempty"`
		TotalCount *int `json:"totalCount,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindManyWorkspaceMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManyWorkspaceMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManyWorkspaceMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			UpdateWorkspaceMembers *[]WorkspaceMemberForResponse `json:"updateWorkspaceMembers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateManyWorkspaceMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManyWorkspaceMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOneWorkspaceMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			// CreateWorkspaceMember A workspace member
			CreateWorkspaceMember *WorkspaceMemberForResponse `json:"createWorkspaceMember,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r CreateOneWorkspaceMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOneWorkspaceMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindWorkspaceMemberDuplicatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount                *float32                      `json:"totalCount,omitempty"`
			WorkspaceMemberDuplicates *[]WorkspaceMemberForResponse `json:"workspaceMemberDuplicates,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindWorkspaceMemberDuplicatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindWorkspaceMemberDuplicatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeManyWorkspaceMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// MergeWorkspaceMembers A workspace member
			MergeWorkspaceMembers *WorkspaceMemberForResponse `json:"mergeWorkspaceMembers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r MergeManyWorkspaceMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeManyWorkspaceMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOneWorkspaceMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			DeleteWorkspaceMember *struct {
				Id *openapi_types.UUID `json:"id,omitempty"`
			} `json:"deleteWorkspaceMember,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r DeleteOneWorkspaceMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOneWorkspaceMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOneWorkspaceMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// WorkspaceMember A workspace member
			WorkspaceMember *WorkspaceMemberForResponse `json:"workspaceMember,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r FindOneWorkspaceMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOneWorkspaceMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOneWorkspaceMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// UpdateWorkspaceMember A workspace member
			UpdateWorkspaceMember *WorkspaceMemberForResponse `json:"updateWorkspaceMember,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
}

// Status returns HTTPResponse.Status
func (r UpdateOneWorkspaceMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOneWorkspaceMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteManyAttachmentsWithResponse request returning *DeleteManyAttachmentsResponse
func (c *ClientWithResponses) DeleteManyAttachmentsWithResponse(ctx context.Context, params *DeleteManyAttachmentsParams, reqEditors ...RequestEditorFn) (*DeleteManyAttachmentsResponse, error) {
	rsp, err := c.DeleteManyAttachments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyAttachmentsResponse(rsp)
}

// FindManyAttachmentsWithResponse request returning *FindManyAttachmentsResponse
func (c *ClientWithResponses) FindManyAttachmentsWithResponse(ctx context.Context, params *FindManyAttachmentsParams, reqEditors ...RequestEditorFn) (*FindManyAttachmentsResponse, error) {
	rsp, err := c.FindManyAttachments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyAttachmentsResponse(rsp)
}

// UpdateManyAttachmentsWithBodyWithResponse request with arbitrary body returning *UpdateManyAttachmentsResponse
func (c *ClientWithResponses) UpdateManyAttachmentsWithBodyWithResponse(ctx context.Context, params *UpdateManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyAttachmentsResponse, error) {
	rsp, err := c.UpdateManyAttachmentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyAttachmentsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyAttachmentsWithResponse(ctx context.Context, params *UpdateManyAttachmentsParams, body UpdateManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyAttachmentsResponse, error) {
	rsp, err := c.UpdateManyAttachments(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyAttachmentsResponse(rsp)
}

// CreateOneAttachmentWithBodyWithResponse request with arbitrary body returning *CreateOneAttachmentResponse
func (c *ClientWithResponses) CreateOneAttachmentWithBodyWithResponse(ctx context.Context, params *CreateOneAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneAttachmentResponse, error) {
	rsp, err := c.CreateOneAttachmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneAttachmentResponse(rsp)
}

func (c *ClientWithResponses) CreateOneAttachmentWithResponse(ctx context.Context, params *CreateOneAttachmentParams, body CreateOneAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneAttachmentResponse, error) {
	rsp, err := c.CreateOneAttachment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneAttachmentResponse(rsp)
}

// FindAttachmentDuplicatesWithBodyWithResponse request with arbitrary body returning *FindAttachmentDuplicatesResponse
func (c *ClientWithResponses) FindAttachmentDuplicatesWithBodyWithResponse(ctx context.Context, params *FindAttachmentDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindAttachmentDuplicatesResponse, error) {
	rsp, err := c.FindAttachmentDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAttachmentDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindAttachmentDuplicatesWithResponse(ctx context.Context, params *FindAttachmentDuplicatesParams, body FindAttachmentDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindAttachmentDuplicatesResponse, error) {
	rsp, err := c.FindAttachmentDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAttachmentDuplicatesResponse(rsp)
}

// MergeManyAttachmentsWithBodyWithResponse request with arbitrary body returning *MergeManyAttachmentsResponse
func (c *ClientWithResponses) MergeManyAttachmentsWithBodyWithResponse(ctx context.Context, params *MergeManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyAttachmentsResponse, error) {
	rsp, err := c.MergeManyAttachmentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyAttachmentsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyAttachmentsWithResponse(ctx context.Context, params *MergeManyAttachmentsParams, body MergeManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyAttachmentsResponse, error) {
	rsp, err := c.MergeManyAttachments(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyAttachmentsResponse(rsp)
}

// DeleteOneAttachmentWithResponse request returning *DeleteOneAttachmentResponse
func (c *ClientWithResponses) DeleteOneAttachmentWithResponse(ctx context.Context, id IdPath, params *DeleteOneAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteOneAttachmentResponse, error) {
	rsp, err := c.DeleteOneAttachment(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneAttachmentResponse(rsp)
}

// FindOneAttachmentWithResponse request returning *FindOneAttachmentResponse
func (c *ClientWithResponses) FindOneAttachmentWithResponse(ctx context.Context, id IdPath, params *FindOneAttachmentParams, reqEditors ...RequestEditorFn) (*FindOneAttachmentResponse, error) {
	rsp, err := c.FindOneAttachment(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneAttachmentResponse(rsp)
}

// UpdateOneAttachmentWithBodyWithResponse request with arbitrary body returning *UpdateOneAttachmentResponse
func (c *ClientWithResponses) UpdateOneAttachmentWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneAttachmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneAttachmentResponse, error) {
	rsp, err := c.UpdateOneAttachmentWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneAttachmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneAttachmentWithResponse(ctx context.Context, id IdPath, params *UpdateOneAttachmentParams, body UpdateOneAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneAttachmentResponse, error) {
	rsp, err := c.UpdateOneAttachment(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneAttachmentResponse(rsp)
}

// CreateManyAttachmentsWithBodyWithResponse request with arbitrary body returning *CreateManyAttachmentsResponse
func (c *ClientWithResponses) CreateManyAttachmentsWithBodyWithResponse(ctx context.Context, params *CreateManyAttachmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyAttachmentsResponse, error) {
	rsp, err := c.CreateManyAttachmentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyAttachmentsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyAttachmentsWithResponse(ctx context.Context, params *CreateManyAttachmentsParams, body CreateManyAttachmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyAttachmentsResponse, error) {
	rsp, err := c.CreateManyAttachments(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyAttachmentsResponse(rsp)
}

// CreateManyBlocklistsWithBodyWithResponse request with arbitrary body returning *CreateManyBlocklistsResponse
func (c *ClientWithResponses) CreateManyBlocklistsWithBodyWithResponse(ctx context.Context, params *CreateManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyBlocklistsResponse, error) {
	rsp, err := c.CreateManyBlocklistsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyBlocklistsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyBlocklistsWithResponse(ctx context.Context, params *CreateManyBlocklistsParams, body CreateManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyBlocklistsResponse, error) {
	rsp, err := c.CreateManyBlocklists(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyBlocklistsResponse(rsp)
}

// CreateManyCalendarChannelEventAssociationsWithBodyWithResponse request with arbitrary body returning *CreateManyCalendarChannelEventAssociationsResponse
func (c *ClientWithResponses) CreateManyCalendarChannelEventAssociationsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.CreateManyCalendarChannelEventAssociationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarChannelEventAssociationsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *CreateManyCalendarChannelEventAssociationsParams, body CreateManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.CreateManyCalendarChannelEventAssociations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarChannelEventAssociationsResponse(rsp)
}

// CreateManyCalendarChannelsWithBodyWithResponse request with arbitrary body returning *CreateManyCalendarChannelsResponse
func (c *ClientWithResponses) CreateManyCalendarChannelsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelsResponse, error) {
	rsp, err := c.CreateManyCalendarChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarChannelsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyCalendarChannelsWithResponse(ctx context.Context, params *CreateManyCalendarChannelsParams, body CreateManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarChannelsResponse, error) {
	rsp, err := c.CreateManyCalendarChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarChannelsResponse(rsp)
}

// CreateManyCalendarEventParticipantsWithBodyWithResponse request with arbitrary body returning *CreateManyCalendarEventParticipantsResponse
func (c *ClientWithResponses) CreateManyCalendarEventParticipantsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.CreateManyCalendarEventParticipantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarEventParticipantsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyCalendarEventParticipantsWithResponse(ctx context.Context, params *CreateManyCalendarEventParticipantsParams, body CreateManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.CreateManyCalendarEventParticipants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarEventParticipantsResponse(rsp)
}

// CreateManyCalendarEventsWithBodyWithResponse request with arbitrary body returning *CreateManyCalendarEventsResponse
func (c *ClientWithResponses) CreateManyCalendarEventsWithBodyWithResponse(ctx context.Context, params *CreateManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventsResponse, error) {
	rsp, err := c.CreateManyCalendarEventsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarEventsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyCalendarEventsWithResponse(ctx context.Context, params *CreateManyCalendarEventsParams, body CreateManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCalendarEventsResponse, error) {
	rsp, err := c.CreateManyCalendarEvents(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCalendarEventsResponse(rsp)
}

// CreateManyCompaniesWithBodyWithResponse request with arbitrary body returning *CreateManyCompaniesResponse
func (c *ClientWithResponses) CreateManyCompaniesWithBodyWithResponse(ctx context.Context, params *CreateManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyCompaniesResponse, error) {
	rsp, err := c.CreateManyCompaniesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCompaniesResponse(rsp)
}

func (c *ClientWithResponses) CreateManyCompaniesWithResponse(ctx context.Context, params *CreateManyCompaniesParams, body CreateManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyCompaniesResponse, error) {
	rsp, err := c.CreateManyCompanies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyCompaniesResponse(rsp)
}

// CreateManyConnectedAccountsWithBodyWithResponse request with arbitrary body returning *CreateManyConnectedAccountsResponse
func (c *ClientWithResponses) CreateManyConnectedAccountsWithBodyWithResponse(ctx context.Context, params *CreateManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyConnectedAccountsResponse, error) {
	rsp, err := c.CreateManyConnectedAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyConnectedAccountsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyConnectedAccountsWithResponse(ctx context.Context, params *CreateManyConnectedAccountsParams, body CreateManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyConnectedAccountsResponse, error) {
	rsp, err := c.CreateManyConnectedAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyConnectedAccountsResponse(rsp)
}

// CreateManyDashboardsWithBodyWithResponse request with arbitrary body returning *CreateManyDashboardsResponse
func (c *ClientWithResponses) CreateManyDashboardsWithBodyWithResponse(ctx context.Context, params *CreateManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyDashboardsResponse, error) {
	rsp, err := c.CreateManyDashboardsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyDashboardsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyDashboardsWithResponse(ctx context.Context, params *CreateManyDashboardsParams, body CreateManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyDashboardsResponse, error) {
	rsp, err := c.CreateManyDashboards(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyDashboardsResponse(rsp)
}

// CreateManyFavoriteFoldersWithBodyWithResponse request with arbitrary body returning *CreateManyFavoriteFoldersResponse
func (c *ClientWithResponses) CreateManyFavoriteFoldersWithBodyWithResponse(ctx context.Context, params *CreateManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyFavoriteFoldersResponse, error) {
	rsp, err := c.CreateManyFavoriteFoldersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyFavoriteFoldersResponse(rsp)
}

func (c *ClientWithResponses) CreateManyFavoriteFoldersWithResponse(ctx context.Context, params *CreateManyFavoriteFoldersParams, body CreateManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyFavoriteFoldersResponse, error) {
	rsp, err := c.CreateManyFavoriteFolders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyFavoriteFoldersResponse(rsp)
}

// CreateManyFavoritesWithBodyWithResponse request with arbitrary body returning *CreateManyFavoritesResponse
func (c *ClientWithResponses) CreateManyFavoritesWithBodyWithResponse(ctx context.Context, params *CreateManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyFavoritesResponse, error) {
	rsp, err := c.CreateManyFavoritesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyFavoritesResponse(rsp)
}

func (c *ClientWithResponses) CreateManyFavoritesWithResponse(ctx context.Context, params *CreateManyFavoritesParams, body CreateManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyFavoritesResponse, error) {
	rsp, err := c.CreateManyFavorites(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyFavoritesResponse(rsp)
}

// CreateManyMessageChannelMessageAssociationsWithBodyWithResponse request with arbitrary body returning *CreateManyMessageChannelMessageAssociationsResponse
func (c *ClientWithResponses) CreateManyMessageChannelMessageAssociationsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.CreateManyMessageChannelMessageAssociationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageChannelMessageAssociationsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *CreateManyMessageChannelMessageAssociationsParams, body CreateManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.CreateManyMessageChannelMessageAssociations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageChannelMessageAssociationsResponse(rsp)
}

// CreateManyMessageChannelsWithBodyWithResponse request with arbitrary body returning *CreateManyMessageChannelsResponse
func (c *ClientWithResponses) CreateManyMessageChannelsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelsResponse, error) {
	rsp, err := c.CreateManyMessageChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageChannelsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyMessageChannelsWithResponse(ctx context.Context, params *CreateManyMessageChannelsParams, body CreateManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageChannelsResponse, error) {
	rsp, err := c.CreateManyMessageChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageChannelsResponse(rsp)
}

// CreateManyMessageFoldersWithBodyWithResponse request with arbitrary body returning *CreateManyMessageFoldersResponse
func (c *ClientWithResponses) CreateManyMessageFoldersWithBodyWithResponse(ctx context.Context, params *CreateManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageFoldersResponse, error) {
	rsp, err := c.CreateManyMessageFoldersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageFoldersResponse(rsp)
}

func (c *ClientWithResponses) CreateManyMessageFoldersWithResponse(ctx context.Context, params *CreateManyMessageFoldersParams, body CreateManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageFoldersResponse, error) {
	rsp, err := c.CreateManyMessageFolders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageFoldersResponse(rsp)
}

// CreateManyMessageParticipantsWithBodyWithResponse request with arbitrary body returning *CreateManyMessageParticipantsResponse
func (c *ClientWithResponses) CreateManyMessageParticipantsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageParticipantsResponse, error) {
	rsp, err := c.CreateManyMessageParticipantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageParticipantsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyMessageParticipantsWithResponse(ctx context.Context, params *CreateManyMessageParticipantsParams, body CreateManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageParticipantsResponse, error) {
	rsp, err := c.CreateManyMessageParticipants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageParticipantsResponse(rsp)
}

// CreateManyMessageThreadsWithBodyWithResponse request with arbitrary body returning *CreateManyMessageThreadsResponse
func (c *ClientWithResponses) CreateManyMessageThreadsWithBodyWithResponse(ctx context.Context, params *CreateManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessageThreadsResponse, error) {
	rsp, err := c.CreateManyMessageThreadsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageThreadsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyMessageThreadsWithResponse(ctx context.Context, params *CreateManyMessageThreadsParams, body CreateManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessageThreadsResponse, error) {
	rsp, err := c.CreateManyMessageThreads(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessageThreadsResponse(rsp)
}

// CreateManyMessagesWithBodyWithResponse request with arbitrary body returning *CreateManyMessagesResponse
func (c *ClientWithResponses) CreateManyMessagesWithBodyWithResponse(ctx context.Context, params *CreateManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyMessagesResponse, error) {
	rsp, err := c.CreateManyMessagesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessagesResponse(rsp)
}

func (c *ClientWithResponses) CreateManyMessagesWithResponse(ctx context.Context, params *CreateManyMessagesParams, body CreateManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyMessagesResponse, error) {
	rsp, err := c.CreateManyMessages(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyMessagesResponse(rsp)
}

// CreateManyNoteTargetsWithBodyWithResponse request with arbitrary body returning *CreateManyNoteTargetsResponse
func (c *ClientWithResponses) CreateManyNoteTargetsWithBodyWithResponse(ctx context.Context, params *CreateManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyNoteTargetsResponse, error) {
	rsp, err := c.CreateManyNoteTargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyNoteTargetsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyNoteTargetsWithResponse(ctx context.Context, params *CreateManyNoteTargetsParams, body CreateManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyNoteTargetsResponse, error) {
	rsp, err := c.CreateManyNoteTargets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyNoteTargetsResponse(rsp)
}

// CreateManyNotesWithBodyWithResponse request with arbitrary body returning *CreateManyNotesResponse
func (c *ClientWithResponses) CreateManyNotesWithBodyWithResponse(ctx context.Context, params *CreateManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyNotesResponse, error) {
	rsp, err := c.CreateManyNotesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyNotesResponse(rsp)
}

func (c *ClientWithResponses) CreateManyNotesWithResponse(ctx context.Context, params *CreateManyNotesParams, body CreateManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyNotesResponse, error) {
	rsp, err := c.CreateManyNotes(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyNotesResponse(rsp)
}

// CreateManyOpportunitiesWithBodyWithResponse request with arbitrary body returning *CreateManyOpportunitiesResponse
func (c *ClientWithResponses) CreateManyOpportunitiesWithBodyWithResponse(ctx context.Context, params *CreateManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyOpportunitiesResponse, error) {
	rsp, err := c.CreateManyOpportunitiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyOpportunitiesResponse(rsp)
}

func (c *ClientWithResponses) CreateManyOpportunitiesWithResponse(ctx context.Context, params *CreateManyOpportunitiesParams, body CreateManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyOpportunitiesResponse, error) {
	rsp, err := c.CreateManyOpportunities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyOpportunitiesResponse(rsp)
}

// CreateManyPeopleWithBodyWithResponse request with arbitrary body returning *CreateManyPeopleResponse
func (c *ClientWithResponses) CreateManyPeopleWithBodyWithResponse(ctx context.Context, params *CreateManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyPeopleResponse, error) {
	rsp, err := c.CreateManyPeopleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyPeopleResponse(rsp)
}

func (c *ClientWithResponses) CreateManyPeopleWithResponse(ctx context.Context, params *CreateManyPeopleParams, body CreateManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyPeopleResponse, error) {
	rsp, err := c.CreateManyPeople(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyPeopleResponse(rsp)
}

// CreateManyTaskTargetsWithBodyWithResponse request with arbitrary body returning *CreateManyTaskTargetsResponse
func (c *ClientWithResponses) CreateManyTaskTargetsWithBodyWithResponse(ctx context.Context, params *CreateManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyTaskTargetsResponse, error) {
	rsp, err := c.CreateManyTaskTargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyTaskTargetsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyTaskTargetsWithResponse(ctx context.Context, params *CreateManyTaskTargetsParams, body CreateManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyTaskTargetsResponse, error) {
	rsp, err := c.CreateManyTaskTargets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyTaskTargetsResponse(rsp)
}

// CreateManyTasksWithBodyWithResponse request with arbitrary body returning *CreateManyTasksResponse
func (c *ClientWithResponses) CreateManyTasksWithBodyWithResponse(ctx context.Context, params *CreateManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyTasksResponse, error) {
	rsp, err := c.CreateManyTasksWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyTasksResponse(rsp)
}

func (c *ClientWithResponses) CreateManyTasksWithResponse(ctx context.Context, params *CreateManyTasksParams, body CreateManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyTasksResponse, error) {
	rsp, err := c.CreateManyTasks(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyTasksResponse(rsp)
}

// CreateManyTimelineActivitiesWithBodyWithResponse request with arbitrary body returning *CreateManyTimelineActivitiesResponse
func (c *ClientWithResponses) CreateManyTimelineActivitiesWithBodyWithResponse(ctx context.Context, params *CreateManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyTimelineActivitiesResponse, error) {
	rsp, err := c.CreateManyTimelineActivitiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyTimelineActivitiesResponse(rsp)
}

func (c *ClientWithResponses) CreateManyTimelineActivitiesWithResponse(ctx context.Context, params *CreateManyTimelineActivitiesParams, body CreateManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyTimelineActivitiesResponse, error) {
	rsp, err := c.CreateManyTimelineActivities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyTimelineActivitiesResponse(rsp)
}

// CreateManyWorkflowAutomatedTriggersWithBodyWithResponse request with arbitrary body returning *CreateManyWorkflowAutomatedTriggersResponse
func (c *ClientWithResponses) CreateManyWorkflowAutomatedTriggersWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.CreateManyWorkflowAutomatedTriggersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowAutomatedTriggersResponse(rsp)
}

func (c *ClientWithResponses) CreateManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *CreateManyWorkflowAutomatedTriggersParams, body CreateManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.CreateManyWorkflowAutomatedTriggers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowAutomatedTriggersResponse(rsp)
}

// CreateManyWorkflowRunsWithBodyWithResponse request with arbitrary body returning *CreateManyWorkflowRunsResponse
func (c *ClientWithResponses) CreateManyWorkflowRunsWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowRunsResponse, error) {
	rsp, err := c.CreateManyWorkflowRunsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowRunsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyWorkflowRunsWithResponse(ctx context.Context, params *CreateManyWorkflowRunsParams, body CreateManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowRunsResponse, error) {
	rsp, err := c.CreateManyWorkflowRuns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowRunsResponse(rsp)
}

// CreateManyWorkflowVersionsWithBodyWithResponse request with arbitrary body returning *CreateManyWorkflowVersionsResponse
func (c *ClientWithResponses) CreateManyWorkflowVersionsWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowVersionsResponse, error) {
	rsp, err := c.CreateManyWorkflowVersionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowVersionsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyWorkflowVersionsWithResponse(ctx context.Context, params *CreateManyWorkflowVersionsParams, body CreateManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowVersionsResponse, error) {
	rsp, err := c.CreateManyWorkflowVersions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowVersionsResponse(rsp)
}

// CreateManyWorkflowsWithBodyWithResponse request with arbitrary body returning *CreateManyWorkflowsResponse
func (c *ClientWithResponses) CreateManyWorkflowsWithBodyWithResponse(ctx context.Context, params *CreateManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkflowsResponse, error) {
	rsp, err := c.CreateManyWorkflowsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowsResponse(rsp)
}

func (c *ClientWithResponses) CreateManyWorkflowsWithResponse(ctx context.Context, params *CreateManyWorkflowsParams, body CreateManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkflowsResponse, error) {
	rsp, err := c.CreateManyWorkflows(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkflowsResponse(rsp)
}

// CreateManyWorkspaceMembersWithBodyWithResponse request with arbitrary body returning *CreateManyWorkspaceMembersResponse
func (c *ClientWithResponses) CreateManyWorkspaceMembersWithBodyWithResponse(ctx context.Context, params *CreateManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManyWorkspaceMembersResponse, error) {
	rsp, err := c.CreateManyWorkspaceMembersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkspaceMembersResponse(rsp)
}

func (c *ClientWithResponses) CreateManyWorkspaceMembersWithResponse(ctx context.Context, params *CreateManyWorkspaceMembersParams, body CreateManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManyWorkspaceMembersResponse, error) {
	rsp, err := c.CreateManyWorkspaceMembers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManyWorkspaceMembersResponse(rsp)
}

// DeleteManyBlocklistsWithResponse request returning *DeleteManyBlocklistsResponse
func (c *ClientWithResponses) DeleteManyBlocklistsWithResponse(ctx context.Context, params *DeleteManyBlocklistsParams, reqEditors ...RequestEditorFn) (*DeleteManyBlocklistsResponse, error) {
	rsp, err := c.DeleteManyBlocklists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyBlocklistsResponse(rsp)
}

// FindManyBlocklistsWithResponse request returning *FindManyBlocklistsResponse
func (c *ClientWithResponses) FindManyBlocklistsWithResponse(ctx context.Context, params *FindManyBlocklistsParams, reqEditors ...RequestEditorFn) (*FindManyBlocklistsResponse, error) {
	rsp, err := c.FindManyBlocklists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyBlocklistsResponse(rsp)
}

// UpdateManyBlocklistsWithBodyWithResponse request with arbitrary body returning *UpdateManyBlocklistsResponse
func (c *ClientWithResponses) UpdateManyBlocklistsWithBodyWithResponse(ctx context.Context, params *UpdateManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyBlocklistsResponse, error) {
	rsp, err := c.UpdateManyBlocklistsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyBlocklistsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyBlocklistsWithResponse(ctx context.Context, params *UpdateManyBlocklistsParams, body UpdateManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyBlocklistsResponse, error) {
	rsp, err := c.UpdateManyBlocklists(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyBlocklistsResponse(rsp)
}

// CreateOneBlocklistWithBodyWithResponse request with arbitrary body returning *CreateOneBlocklistResponse
func (c *ClientWithResponses) CreateOneBlocklistWithBodyWithResponse(ctx context.Context, params *CreateOneBlocklistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneBlocklistResponse, error) {
	rsp, err := c.CreateOneBlocklistWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneBlocklistResponse(rsp)
}

func (c *ClientWithResponses) CreateOneBlocklistWithResponse(ctx context.Context, params *CreateOneBlocklistParams, body CreateOneBlocklistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneBlocklistResponse, error) {
	rsp, err := c.CreateOneBlocklist(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneBlocklistResponse(rsp)
}

// FindBlocklistDuplicatesWithBodyWithResponse request with arbitrary body returning *FindBlocklistDuplicatesResponse
func (c *ClientWithResponses) FindBlocklistDuplicatesWithBodyWithResponse(ctx context.Context, params *FindBlocklistDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindBlocklistDuplicatesResponse, error) {
	rsp, err := c.FindBlocklistDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBlocklistDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindBlocklistDuplicatesWithResponse(ctx context.Context, params *FindBlocklistDuplicatesParams, body FindBlocklistDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindBlocklistDuplicatesResponse, error) {
	rsp, err := c.FindBlocklistDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBlocklistDuplicatesResponse(rsp)
}

// MergeManyBlocklistsWithBodyWithResponse request with arbitrary body returning *MergeManyBlocklistsResponse
func (c *ClientWithResponses) MergeManyBlocklistsWithBodyWithResponse(ctx context.Context, params *MergeManyBlocklistsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyBlocklistsResponse, error) {
	rsp, err := c.MergeManyBlocklistsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyBlocklistsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyBlocklistsWithResponse(ctx context.Context, params *MergeManyBlocklistsParams, body MergeManyBlocklistsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyBlocklistsResponse, error) {
	rsp, err := c.MergeManyBlocklists(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyBlocklistsResponse(rsp)
}

// DeleteOneBlocklistWithResponse request returning *DeleteOneBlocklistResponse
func (c *ClientWithResponses) DeleteOneBlocklistWithResponse(ctx context.Context, id IdPath, params *DeleteOneBlocklistParams, reqEditors ...RequestEditorFn) (*DeleteOneBlocklistResponse, error) {
	rsp, err := c.DeleteOneBlocklist(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneBlocklistResponse(rsp)
}

// FindOneBlocklistWithResponse request returning *FindOneBlocklistResponse
func (c *ClientWithResponses) FindOneBlocklistWithResponse(ctx context.Context, id IdPath, params *FindOneBlocklistParams, reqEditors ...RequestEditorFn) (*FindOneBlocklistResponse, error) {
	rsp, err := c.FindOneBlocklist(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneBlocklistResponse(rsp)
}

// UpdateOneBlocklistWithBodyWithResponse request with arbitrary body returning *UpdateOneBlocklistResponse
func (c *ClientWithResponses) UpdateOneBlocklistWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneBlocklistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneBlocklistResponse, error) {
	rsp, err := c.UpdateOneBlocklistWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneBlocklistResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneBlocklistWithResponse(ctx context.Context, id IdPath, params *UpdateOneBlocklistParams, body UpdateOneBlocklistJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneBlocklistResponse, error) {
	rsp, err := c.UpdateOneBlocklist(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneBlocklistResponse(rsp)
}

// DeleteManyCalendarChannelEventAssociationsWithResponse request returning *DeleteManyCalendarChannelEventAssociationsResponse
func (c *ClientWithResponses) DeleteManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *DeleteManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.DeleteManyCalendarChannelEventAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyCalendarChannelEventAssociationsResponse(rsp)
}

// FindManyCalendarChannelEventAssociationsWithResponse request returning *FindManyCalendarChannelEventAssociationsResponse
func (c *ClientWithResponses) FindManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *FindManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.FindManyCalendarChannelEventAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyCalendarChannelEventAssociationsResponse(rsp)
}

// UpdateManyCalendarChannelEventAssociationsWithBodyWithResponse request with arbitrary body returning *UpdateManyCalendarChannelEventAssociationsResponse
func (c *ClientWithResponses) UpdateManyCalendarChannelEventAssociationsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.UpdateManyCalendarChannelEventAssociationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarChannelEventAssociationsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *UpdateManyCalendarChannelEventAssociationsParams, body UpdateManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.UpdateManyCalendarChannelEventAssociations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarChannelEventAssociationsResponse(rsp)
}

// CreateOneCalendarChannelEventAssociationWithBodyWithResponse request with arbitrary body returning *CreateOneCalendarChannelEventAssociationResponse
func (c *ClientWithResponses) CreateOneCalendarChannelEventAssociationWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelEventAssociationResponse, error) {
	rsp, err := c.CreateOneCalendarChannelEventAssociationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarChannelEventAssociationResponse(rsp)
}

func (c *ClientWithResponses) CreateOneCalendarChannelEventAssociationWithResponse(ctx context.Context, params *CreateOneCalendarChannelEventAssociationParams, body CreateOneCalendarChannelEventAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelEventAssociationResponse, error) {
	rsp, err := c.CreateOneCalendarChannelEventAssociation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarChannelEventAssociationResponse(rsp)
}

// FindCalendarChannelEventAssociationDuplicatesWithBodyWithResponse request with arbitrary body returning *FindCalendarChannelEventAssociationDuplicatesResponse
func (c *ClientWithResponses) FindCalendarChannelEventAssociationDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarChannelEventAssociationDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarChannelEventAssociationDuplicatesResponse, error) {
	rsp, err := c.FindCalendarChannelEventAssociationDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarChannelEventAssociationDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindCalendarChannelEventAssociationDuplicatesWithResponse(ctx context.Context, params *FindCalendarChannelEventAssociationDuplicatesParams, body FindCalendarChannelEventAssociationDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarChannelEventAssociationDuplicatesResponse, error) {
	rsp, err := c.FindCalendarChannelEventAssociationDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarChannelEventAssociationDuplicatesResponse(rsp)
}

// MergeManyCalendarChannelEventAssociationsWithBodyWithResponse request with arbitrary body returning *MergeManyCalendarChannelEventAssociationsResponse
func (c *ClientWithResponses) MergeManyCalendarChannelEventAssociationsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarChannelEventAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.MergeManyCalendarChannelEventAssociationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarChannelEventAssociationsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *MergeManyCalendarChannelEventAssociationsParams, body MergeManyCalendarChannelEventAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.MergeManyCalendarChannelEventAssociations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarChannelEventAssociationsResponse(rsp)
}

// DeleteOneCalendarChannelEventAssociationWithResponse request returning *DeleteOneCalendarChannelEventAssociationResponse
func (c *ClientWithResponses) DeleteOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarChannelEventAssociationResponse, error) {
	rsp, err := c.DeleteOneCalendarChannelEventAssociation(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneCalendarChannelEventAssociationResponse(rsp)
}

// FindOneCalendarChannelEventAssociationWithResponse request returning *FindOneCalendarChannelEventAssociationResponse
func (c *ClientWithResponses) FindOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*FindOneCalendarChannelEventAssociationResponse, error) {
	rsp, err := c.FindOneCalendarChannelEventAssociation(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneCalendarChannelEventAssociationResponse(rsp)
}

// UpdateOneCalendarChannelEventAssociationWithBodyWithResponse request with arbitrary body returning *UpdateOneCalendarChannelEventAssociationResponse
func (c *ClientWithResponses) UpdateOneCalendarChannelEventAssociationWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelEventAssociationResponse, error) {
	rsp, err := c.UpdateOneCalendarChannelEventAssociationWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarChannelEventAssociationResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelEventAssociationParams, body UpdateOneCalendarChannelEventAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelEventAssociationResponse, error) {
	rsp, err := c.UpdateOneCalendarChannelEventAssociation(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarChannelEventAssociationResponse(rsp)
}

// DeleteManyCalendarChannelsWithResponse request returning *DeleteManyCalendarChannelsResponse
func (c *ClientWithResponses) DeleteManyCalendarChannelsWithResponse(ctx context.Context, params *DeleteManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarChannelsResponse, error) {
	rsp, err := c.DeleteManyCalendarChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyCalendarChannelsResponse(rsp)
}

// FindManyCalendarChannelsWithResponse request returning *FindManyCalendarChannelsResponse
func (c *ClientWithResponses) FindManyCalendarChannelsWithResponse(ctx context.Context, params *FindManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarChannelsResponse, error) {
	rsp, err := c.FindManyCalendarChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyCalendarChannelsResponse(rsp)
}

// UpdateManyCalendarChannelsWithBodyWithResponse request with arbitrary body returning *UpdateManyCalendarChannelsResponse
func (c *ClientWithResponses) UpdateManyCalendarChannelsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelsResponse, error) {
	rsp, err := c.UpdateManyCalendarChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarChannelsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyCalendarChannelsWithResponse(ctx context.Context, params *UpdateManyCalendarChannelsParams, body UpdateManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarChannelsResponse, error) {
	rsp, err := c.UpdateManyCalendarChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarChannelsResponse(rsp)
}

// CreateOneCalendarChannelWithBodyWithResponse request with arbitrary body returning *CreateOneCalendarChannelResponse
func (c *ClientWithResponses) CreateOneCalendarChannelWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelResponse, error) {
	rsp, err := c.CreateOneCalendarChannelWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateOneCalendarChannelWithResponse(ctx context.Context, params *CreateOneCalendarChannelParams, body CreateOneCalendarChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarChannelResponse, error) {
	rsp, err := c.CreateOneCalendarChannel(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarChannelResponse(rsp)
}

// FindCalendarChannelDuplicatesWithBodyWithResponse request with arbitrary body returning *FindCalendarChannelDuplicatesResponse
func (c *ClientWithResponses) FindCalendarChannelDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarChannelDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarChannelDuplicatesResponse, error) {
	rsp, err := c.FindCalendarChannelDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarChannelDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindCalendarChannelDuplicatesWithResponse(ctx context.Context, params *FindCalendarChannelDuplicatesParams, body FindCalendarChannelDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarChannelDuplicatesResponse, error) {
	rsp, err := c.FindCalendarChannelDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarChannelDuplicatesResponse(rsp)
}

// MergeManyCalendarChannelsWithBodyWithResponse request with arbitrary body returning *MergeManyCalendarChannelsResponse
func (c *ClientWithResponses) MergeManyCalendarChannelsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelsResponse, error) {
	rsp, err := c.MergeManyCalendarChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarChannelsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyCalendarChannelsWithResponse(ctx context.Context, params *MergeManyCalendarChannelsParams, body MergeManyCalendarChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarChannelsResponse, error) {
	rsp, err := c.MergeManyCalendarChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarChannelsResponse(rsp)
}

// DeleteOneCalendarChannelWithResponse request returning *DeleteOneCalendarChannelResponse
func (c *ClientWithResponses) DeleteOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarChannelResponse, error) {
	rsp, err := c.DeleteOneCalendarChannel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneCalendarChannelResponse(rsp)
}

// FindOneCalendarChannelWithResponse request returning *FindOneCalendarChannelResponse
func (c *ClientWithResponses) FindOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*FindOneCalendarChannelResponse, error) {
	rsp, err := c.FindOneCalendarChannel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneCalendarChannelResponse(rsp)
}

// UpdateOneCalendarChannelWithBodyWithResponse request with arbitrary body returning *UpdateOneCalendarChannelResponse
func (c *ClientWithResponses) UpdateOneCalendarChannelWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelResponse, error) {
	rsp, err := c.UpdateOneCalendarChannelWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarChannelResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarChannelParams, body UpdateOneCalendarChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarChannelResponse, error) {
	rsp, err := c.UpdateOneCalendarChannel(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarChannelResponse(rsp)
}

// DeleteManyCalendarEventParticipantsWithResponse request returning *DeleteManyCalendarEventParticipantsResponse
func (c *ClientWithResponses) DeleteManyCalendarEventParticipantsWithResponse(ctx context.Context, params *DeleteManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.DeleteManyCalendarEventParticipants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyCalendarEventParticipantsResponse(rsp)
}

// FindManyCalendarEventParticipantsWithResponse request returning *FindManyCalendarEventParticipantsResponse
func (c *ClientWithResponses) FindManyCalendarEventParticipantsWithResponse(ctx context.Context, params *FindManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.FindManyCalendarEventParticipants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyCalendarEventParticipantsResponse(rsp)
}

// UpdateManyCalendarEventParticipantsWithBodyWithResponse request with arbitrary body returning *UpdateManyCalendarEventParticipantsResponse
func (c *ClientWithResponses) UpdateManyCalendarEventParticipantsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.UpdateManyCalendarEventParticipantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarEventParticipantsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyCalendarEventParticipantsWithResponse(ctx context.Context, params *UpdateManyCalendarEventParticipantsParams, body UpdateManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.UpdateManyCalendarEventParticipants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarEventParticipantsResponse(rsp)
}

// CreateOneCalendarEventParticipantWithBodyWithResponse request with arbitrary body returning *CreateOneCalendarEventParticipantResponse
func (c *ClientWithResponses) CreateOneCalendarEventParticipantWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarEventParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventParticipantResponse, error) {
	rsp, err := c.CreateOneCalendarEventParticipantWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarEventParticipantResponse(rsp)
}

func (c *ClientWithResponses) CreateOneCalendarEventParticipantWithResponse(ctx context.Context, params *CreateOneCalendarEventParticipantParams, body CreateOneCalendarEventParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventParticipantResponse, error) {
	rsp, err := c.CreateOneCalendarEventParticipant(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarEventParticipantResponse(rsp)
}

// FindCalendarEventParticipantDuplicatesWithBodyWithResponse request with arbitrary body returning *FindCalendarEventParticipantDuplicatesResponse
func (c *ClientWithResponses) FindCalendarEventParticipantDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarEventParticipantDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarEventParticipantDuplicatesResponse, error) {
	rsp, err := c.FindCalendarEventParticipantDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarEventParticipantDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindCalendarEventParticipantDuplicatesWithResponse(ctx context.Context, params *FindCalendarEventParticipantDuplicatesParams, body FindCalendarEventParticipantDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarEventParticipantDuplicatesResponse, error) {
	rsp, err := c.FindCalendarEventParticipantDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarEventParticipantDuplicatesResponse(rsp)
}

// MergeManyCalendarEventParticipantsWithBodyWithResponse request with arbitrary body returning *MergeManyCalendarEventParticipantsResponse
func (c *ClientWithResponses) MergeManyCalendarEventParticipantsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarEventParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.MergeManyCalendarEventParticipantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarEventParticipantsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyCalendarEventParticipantsWithResponse(ctx context.Context, params *MergeManyCalendarEventParticipantsParams, body MergeManyCalendarEventParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.MergeManyCalendarEventParticipants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarEventParticipantsResponse(rsp)
}

// DeleteOneCalendarEventParticipantWithResponse request returning *DeleteOneCalendarEventParticipantResponse
func (c *ClientWithResponses) DeleteOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarEventParticipantResponse, error) {
	rsp, err := c.DeleteOneCalendarEventParticipant(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneCalendarEventParticipantResponse(rsp)
}

// FindOneCalendarEventParticipantWithResponse request returning *FindOneCalendarEventParticipantResponse
func (c *ClientWithResponses) FindOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*FindOneCalendarEventParticipantResponse, error) {
	rsp, err := c.FindOneCalendarEventParticipant(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneCalendarEventParticipantResponse(rsp)
}

// UpdateOneCalendarEventParticipantWithBodyWithResponse request with arbitrary body returning *UpdateOneCalendarEventParticipantResponse
func (c *ClientWithResponses) UpdateOneCalendarEventParticipantWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventParticipantResponse, error) {
	rsp, err := c.UpdateOneCalendarEventParticipantWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarEventParticipantResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParticipantParams, body UpdateOneCalendarEventParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventParticipantResponse, error) {
	rsp, err := c.UpdateOneCalendarEventParticipant(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarEventParticipantResponse(rsp)
}

// DeleteManyCalendarEventsWithResponse request returning *DeleteManyCalendarEventsResponse
func (c *ClientWithResponses) DeleteManyCalendarEventsWithResponse(ctx context.Context, params *DeleteManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*DeleteManyCalendarEventsResponse, error) {
	rsp, err := c.DeleteManyCalendarEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyCalendarEventsResponse(rsp)
}

// FindManyCalendarEventsWithResponse request returning *FindManyCalendarEventsResponse
func (c *ClientWithResponses) FindManyCalendarEventsWithResponse(ctx context.Context, params *FindManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*FindManyCalendarEventsResponse, error) {
	rsp, err := c.FindManyCalendarEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyCalendarEventsResponse(rsp)
}

// UpdateManyCalendarEventsWithBodyWithResponse request with arbitrary body returning *UpdateManyCalendarEventsResponse
func (c *ClientWithResponses) UpdateManyCalendarEventsWithBodyWithResponse(ctx context.Context, params *UpdateManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventsResponse, error) {
	rsp, err := c.UpdateManyCalendarEventsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarEventsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyCalendarEventsWithResponse(ctx context.Context, params *UpdateManyCalendarEventsParams, body UpdateManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCalendarEventsResponse, error) {
	rsp, err := c.UpdateManyCalendarEvents(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCalendarEventsResponse(rsp)
}

// CreateOneCalendarEventWithBodyWithResponse request with arbitrary body returning *CreateOneCalendarEventResponse
func (c *ClientWithResponses) CreateOneCalendarEventWithBodyWithResponse(ctx context.Context, params *CreateOneCalendarEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventResponse, error) {
	rsp, err := c.CreateOneCalendarEventWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarEventResponse(rsp)
}

func (c *ClientWithResponses) CreateOneCalendarEventWithResponse(ctx context.Context, params *CreateOneCalendarEventParams, body CreateOneCalendarEventJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCalendarEventResponse, error) {
	rsp, err := c.CreateOneCalendarEvent(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCalendarEventResponse(rsp)
}

// FindCalendarEventDuplicatesWithBodyWithResponse request with arbitrary body returning *FindCalendarEventDuplicatesResponse
func (c *ClientWithResponses) FindCalendarEventDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCalendarEventDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCalendarEventDuplicatesResponse, error) {
	rsp, err := c.FindCalendarEventDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarEventDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindCalendarEventDuplicatesWithResponse(ctx context.Context, params *FindCalendarEventDuplicatesParams, body FindCalendarEventDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCalendarEventDuplicatesResponse, error) {
	rsp, err := c.FindCalendarEventDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCalendarEventDuplicatesResponse(rsp)
}

// MergeManyCalendarEventsWithBodyWithResponse request with arbitrary body returning *MergeManyCalendarEventsResponse
func (c *ClientWithResponses) MergeManyCalendarEventsWithBodyWithResponse(ctx context.Context, params *MergeManyCalendarEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventsResponse, error) {
	rsp, err := c.MergeManyCalendarEventsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarEventsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyCalendarEventsWithResponse(ctx context.Context, params *MergeManyCalendarEventsParams, body MergeManyCalendarEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCalendarEventsResponse, error) {
	rsp, err := c.MergeManyCalendarEvents(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCalendarEventsResponse(rsp)
}

// DeleteOneCalendarEventWithResponse request returning *DeleteOneCalendarEventResponse
func (c *ClientWithResponses) DeleteOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *DeleteOneCalendarEventParams, reqEditors ...RequestEditorFn) (*DeleteOneCalendarEventResponse, error) {
	rsp, err := c.DeleteOneCalendarEvent(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneCalendarEventResponse(rsp)
}

// FindOneCalendarEventWithResponse request returning *FindOneCalendarEventResponse
func (c *ClientWithResponses) FindOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *FindOneCalendarEventParams, reqEditors ...RequestEditorFn) (*FindOneCalendarEventResponse, error) {
	rsp, err := c.FindOneCalendarEvent(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneCalendarEventResponse(rsp)
}

// UpdateOneCalendarEventWithBodyWithResponse request with arbitrary body returning *UpdateOneCalendarEventResponse
func (c *ClientWithResponses) UpdateOneCalendarEventWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventResponse, error) {
	rsp, err := c.UpdateOneCalendarEventWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarEventResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *UpdateOneCalendarEventParams, body UpdateOneCalendarEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCalendarEventResponse, error) {
	rsp, err := c.UpdateOneCalendarEvent(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCalendarEventResponse(rsp)
}

// DeleteManyCompaniesWithResponse request returning *DeleteManyCompaniesResponse
func (c *ClientWithResponses) DeleteManyCompaniesWithResponse(ctx context.Context, params *DeleteManyCompaniesParams, reqEditors ...RequestEditorFn) (*DeleteManyCompaniesResponse, error) {
	rsp, err := c.DeleteManyCompanies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyCompaniesResponse(rsp)
}

// FindManyCompaniesWithResponse request returning *FindManyCompaniesResponse
func (c *ClientWithResponses) FindManyCompaniesWithResponse(ctx context.Context, params *FindManyCompaniesParams, reqEditors ...RequestEditorFn) (*FindManyCompaniesResponse, error) {
	rsp, err := c.FindManyCompanies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyCompaniesResponse(rsp)
}

// UpdateManyCompaniesWithBodyWithResponse request with arbitrary body returning *UpdateManyCompaniesResponse
func (c *ClientWithResponses) UpdateManyCompaniesWithBodyWithResponse(ctx context.Context, params *UpdateManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyCompaniesResponse, error) {
	rsp, err := c.UpdateManyCompaniesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCompaniesResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyCompaniesWithResponse(ctx context.Context, params *UpdateManyCompaniesParams, body UpdateManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyCompaniesResponse, error) {
	rsp, err := c.UpdateManyCompanies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyCompaniesResponse(rsp)
}

// CreateOneCompanyWithBodyWithResponse request with arbitrary body returning *CreateOneCompanyResponse
func (c *ClientWithResponses) CreateOneCompanyWithBodyWithResponse(ctx context.Context, params *CreateOneCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneCompanyResponse, error) {
	rsp, err := c.CreateOneCompanyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCompanyResponse(rsp)
}

func (c *ClientWithResponses) CreateOneCompanyWithResponse(ctx context.Context, params *CreateOneCompanyParams, body CreateOneCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneCompanyResponse, error) {
	rsp, err := c.CreateOneCompany(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneCompanyResponse(rsp)
}

// FindCompanyDuplicatesWithBodyWithResponse request with arbitrary body returning *FindCompanyDuplicatesResponse
func (c *ClientWithResponses) FindCompanyDuplicatesWithBodyWithResponse(ctx context.Context, params *FindCompanyDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindCompanyDuplicatesResponse, error) {
	rsp, err := c.FindCompanyDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCompanyDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindCompanyDuplicatesWithResponse(ctx context.Context, params *FindCompanyDuplicatesParams, body FindCompanyDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindCompanyDuplicatesResponse, error) {
	rsp, err := c.FindCompanyDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCompanyDuplicatesResponse(rsp)
}

// MergeManyCompaniesWithBodyWithResponse request with arbitrary body returning *MergeManyCompaniesResponse
func (c *ClientWithResponses) MergeManyCompaniesWithBodyWithResponse(ctx context.Context, params *MergeManyCompaniesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyCompaniesResponse, error) {
	rsp, err := c.MergeManyCompaniesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCompaniesResponse(rsp)
}

func (c *ClientWithResponses) MergeManyCompaniesWithResponse(ctx context.Context, params *MergeManyCompaniesParams, body MergeManyCompaniesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyCompaniesResponse, error) {
	rsp, err := c.MergeManyCompanies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyCompaniesResponse(rsp)
}

// DeleteOneCompanyWithResponse request returning *DeleteOneCompanyResponse
func (c *ClientWithResponses) DeleteOneCompanyWithResponse(ctx context.Context, id IdPath, params *DeleteOneCompanyParams, reqEditors ...RequestEditorFn) (*DeleteOneCompanyResponse, error) {
	rsp, err := c.DeleteOneCompany(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneCompanyResponse(rsp)
}

// FindOneCompanyWithResponse request returning *FindOneCompanyResponse
func (c *ClientWithResponses) FindOneCompanyWithResponse(ctx context.Context, id IdPath, params *FindOneCompanyParams, reqEditors ...RequestEditorFn) (*FindOneCompanyResponse, error) {
	rsp, err := c.FindOneCompany(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneCompanyResponse(rsp)
}

// UpdateOneCompanyWithBodyWithResponse request with arbitrary body returning *UpdateOneCompanyResponse
func (c *ClientWithResponses) UpdateOneCompanyWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneCompanyResponse, error) {
	rsp, err := c.UpdateOneCompanyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCompanyResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneCompanyWithResponse(ctx context.Context, id IdPath, params *UpdateOneCompanyParams, body UpdateOneCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneCompanyResponse, error) {
	rsp, err := c.UpdateOneCompany(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneCompanyResponse(rsp)
}

// DeleteManyConnectedAccountsWithResponse request returning *DeleteManyConnectedAccountsResponse
func (c *ClientWithResponses) DeleteManyConnectedAccountsWithResponse(ctx context.Context, params *DeleteManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*DeleteManyConnectedAccountsResponse, error) {
	rsp, err := c.DeleteManyConnectedAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyConnectedAccountsResponse(rsp)
}

// FindManyConnectedAccountsWithResponse request returning *FindManyConnectedAccountsResponse
func (c *ClientWithResponses) FindManyConnectedAccountsWithResponse(ctx context.Context, params *FindManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*FindManyConnectedAccountsResponse, error) {
	rsp, err := c.FindManyConnectedAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyConnectedAccountsResponse(rsp)
}

// UpdateManyConnectedAccountsWithBodyWithResponse request with arbitrary body returning *UpdateManyConnectedAccountsResponse
func (c *ClientWithResponses) UpdateManyConnectedAccountsWithBodyWithResponse(ctx context.Context, params *UpdateManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyConnectedAccountsResponse, error) {
	rsp, err := c.UpdateManyConnectedAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyConnectedAccountsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyConnectedAccountsWithResponse(ctx context.Context, params *UpdateManyConnectedAccountsParams, body UpdateManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyConnectedAccountsResponse, error) {
	rsp, err := c.UpdateManyConnectedAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyConnectedAccountsResponse(rsp)
}

// CreateOneConnectedAccountWithBodyWithResponse request with arbitrary body returning *CreateOneConnectedAccountResponse
func (c *ClientWithResponses) CreateOneConnectedAccountWithBodyWithResponse(ctx context.Context, params *CreateOneConnectedAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneConnectedAccountResponse, error) {
	rsp, err := c.CreateOneConnectedAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneConnectedAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateOneConnectedAccountWithResponse(ctx context.Context, params *CreateOneConnectedAccountParams, body CreateOneConnectedAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneConnectedAccountResponse, error) {
	rsp, err := c.CreateOneConnectedAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneConnectedAccountResponse(rsp)
}

// FindConnectedAccountDuplicatesWithBodyWithResponse request with arbitrary body returning *FindConnectedAccountDuplicatesResponse
func (c *ClientWithResponses) FindConnectedAccountDuplicatesWithBodyWithResponse(ctx context.Context, params *FindConnectedAccountDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindConnectedAccountDuplicatesResponse, error) {
	rsp, err := c.FindConnectedAccountDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindConnectedAccountDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindConnectedAccountDuplicatesWithResponse(ctx context.Context, params *FindConnectedAccountDuplicatesParams, body FindConnectedAccountDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindConnectedAccountDuplicatesResponse, error) {
	rsp, err := c.FindConnectedAccountDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindConnectedAccountDuplicatesResponse(rsp)
}

// MergeManyConnectedAccountsWithBodyWithResponse request with arbitrary body returning *MergeManyConnectedAccountsResponse
func (c *ClientWithResponses) MergeManyConnectedAccountsWithBodyWithResponse(ctx context.Context, params *MergeManyConnectedAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyConnectedAccountsResponse, error) {
	rsp, err := c.MergeManyConnectedAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyConnectedAccountsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyConnectedAccountsWithResponse(ctx context.Context, params *MergeManyConnectedAccountsParams, body MergeManyConnectedAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyConnectedAccountsResponse, error) {
	rsp, err := c.MergeManyConnectedAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyConnectedAccountsResponse(rsp)
}

// DeleteOneConnectedAccountWithResponse request returning *DeleteOneConnectedAccountResponse
func (c *ClientWithResponses) DeleteOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *DeleteOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*DeleteOneConnectedAccountResponse, error) {
	rsp, err := c.DeleteOneConnectedAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneConnectedAccountResponse(rsp)
}

// FindOneConnectedAccountWithResponse request returning *FindOneConnectedAccountResponse
func (c *ClientWithResponses) FindOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *FindOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*FindOneConnectedAccountResponse, error) {
	rsp, err := c.FindOneConnectedAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneConnectedAccountResponse(rsp)
}

// UpdateOneConnectedAccountWithBodyWithResponse request with arbitrary body returning *UpdateOneConnectedAccountResponse
func (c *ClientWithResponses) UpdateOneConnectedAccountWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneConnectedAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneConnectedAccountResponse, error) {
	rsp, err := c.UpdateOneConnectedAccountWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneConnectedAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *UpdateOneConnectedAccountParams, body UpdateOneConnectedAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneConnectedAccountResponse, error) {
	rsp, err := c.UpdateOneConnectedAccount(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneConnectedAccountResponse(rsp)
}

// DeleteManyDashboardsWithResponse request returning *DeleteManyDashboardsResponse
func (c *ClientWithResponses) DeleteManyDashboardsWithResponse(ctx context.Context, params *DeleteManyDashboardsParams, reqEditors ...RequestEditorFn) (*DeleteManyDashboardsResponse, error) {
	rsp, err := c.DeleteManyDashboards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyDashboardsResponse(rsp)
}

// FindManyDashboardsWithResponse request returning *FindManyDashboardsResponse
func (c *ClientWithResponses) FindManyDashboardsWithResponse(ctx context.Context, params *FindManyDashboardsParams, reqEditors ...RequestEditorFn) (*FindManyDashboardsResponse, error) {
	rsp, err := c.FindManyDashboards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyDashboardsResponse(rsp)
}

// UpdateManyDashboardsWithBodyWithResponse request with arbitrary body returning *UpdateManyDashboardsResponse
func (c *ClientWithResponses) UpdateManyDashboardsWithBodyWithResponse(ctx context.Context, params *UpdateManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyDashboardsResponse, error) {
	rsp, err := c.UpdateManyDashboardsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyDashboardsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyDashboardsWithResponse(ctx context.Context, params *UpdateManyDashboardsParams, body UpdateManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyDashboardsResponse, error) {
	rsp, err := c.UpdateManyDashboards(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyDashboardsResponse(rsp)
}

// CreateOneDashboardWithBodyWithResponse request with arbitrary body returning *CreateOneDashboardResponse
func (c *ClientWithResponses) CreateOneDashboardWithBodyWithResponse(ctx context.Context, params *CreateOneDashboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneDashboardResponse, error) {
	rsp, err := c.CreateOneDashboardWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneDashboardResponse(rsp)
}

func (c *ClientWithResponses) CreateOneDashboardWithResponse(ctx context.Context, params *CreateOneDashboardParams, body CreateOneDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneDashboardResponse, error) {
	rsp, err := c.CreateOneDashboard(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneDashboardResponse(rsp)
}

// FindDashboardDuplicatesWithBodyWithResponse request with arbitrary body returning *FindDashboardDuplicatesResponse
func (c *ClientWithResponses) FindDashboardDuplicatesWithBodyWithResponse(ctx context.Context, params *FindDashboardDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindDashboardDuplicatesResponse, error) {
	rsp, err := c.FindDashboardDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDashboardDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindDashboardDuplicatesWithResponse(ctx context.Context, params *FindDashboardDuplicatesParams, body FindDashboardDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindDashboardDuplicatesResponse, error) {
	rsp, err := c.FindDashboardDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDashboardDuplicatesResponse(rsp)
}

// MergeManyDashboardsWithBodyWithResponse request with arbitrary body returning *MergeManyDashboardsResponse
func (c *ClientWithResponses) MergeManyDashboardsWithBodyWithResponse(ctx context.Context, params *MergeManyDashboardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyDashboardsResponse, error) {
	rsp, err := c.MergeManyDashboardsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyDashboardsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyDashboardsWithResponse(ctx context.Context, params *MergeManyDashboardsParams, body MergeManyDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyDashboardsResponse, error) {
	rsp, err := c.MergeManyDashboards(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyDashboardsResponse(rsp)
}

// DeleteOneDashboardWithResponse request returning *DeleteOneDashboardResponse
func (c *ClientWithResponses) DeleteOneDashboardWithResponse(ctx context.Context, id IdPath, params *DeleteOneDashboardParams, reqEditors ...RequestEditorFn) (*DeleteOneDashboardResponse, error) {
	rsp, err := c.DeleteOneDashboard(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneDashboardResponse(rsp)
}

// FindOneDashboardWithResponse request returning *FindOneDashboardResponse
func (c *ClientWithResponses) FindOneDashboardWithResponse(ctx context.Context, id IdPath, params *FindOneDashboardParams, reqEditors ...RequestEditorFn) (*FindOneDashboardResponse, error) {
	rsp, err := c.FindOneDashboard(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneDashboardResponse(rsp)
}

// UpdateOneDashboardWithBodyWithResponse request with arbitrary body returning *UpdateOneDashboardResponse
func (c *ClientWithResponses) UpdateOneDashboardWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneDashboardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneDashboardResponse, error) {
	rsp, err := c.UpdateOneDashboardWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneDashboardResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneDashboardWithResponse(ctx context.Context, id IdPath, params *UpdateOneDashboardParams, body UpdateOneDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneDashboardResponse, error) {
	rsp, err := c.UpdateOneDashboard(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneDashboardResponse(rsp)
}

// DuplicateDashboardWithResponse request returning *DuplicateDashboardResponse
func (c *ClientWithResponses) DuplicateDashboardWithResponse(ctx context.Context, id IdPath, reqEditors ...RequestEditorFn) (*DuplicateDashboardResponse, error) {
	rsp, err := c.DuplicateDashboard(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuplicateDashboardResponse(rsp)
}

// DeleteManyFavoriteFoldersWithResponse request returning *DeleteManyFavoriteFoldersResponse
func (c *ClientWithResponses) DeleteManyFavoriteFoldersWithResponse(ctx context.Context, params *DeleteManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*DeleteManyFavoriteFoldersResponse, error) {
	rsp, err := c.DeleteManyFavoriteFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyFavoriteFoldersResponse(rsp)
}

// FindManyFavoriteFoldersWithResponse request returning *FindManyFavoriteFoldersResponse
func (c *ClientWithResponses) FindManyFavoriteFoldersWithResponse(ctx context.Context, params *FindManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*FindManyFavoriteFoldersResponse, error) {
	rsp, err := c.FindManyFavoriteFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyFavoriteFoldersResponse(rsp)
}

// UpdateManyFavoriteFoldersWithBodyWithResponse request with arbitrary body returning *UpdateManyFavoriteFoldersResponse
func (c *ClientWithResponses) UpdateManyFavoriteFoldersWithBodyWithResponse(ctx context.Context, params *UpdateManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyFavoriteFoldersResponse, error) {
	rsp, err := c.UpdateManyFavoriteFoldersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyFavoriteFoldersResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyFavoriteFoldersWithResponse(ctx context.Context, params *UpdateManyFavoriteFoldersParams, body UpdateManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyFavoriteFoldersResponse, error) {
	rsp, err := c.UpdateManyFavoriteFolders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyFavoriteFoldersResponse(rsp)
}

// CreateOneFavoriteFolderWithBodyWithResponse request with arbitrary body returning *CreateOneFavoriteFolderResponse
func (c *ClientWithResponses) CreateOneFavoriteFolderWithBodyWithResponse(ctx context.Context, params *CreateOneFavoriteFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneFavoriteFolderResponse, error) {
	rsp, err := c.CreateOneFavoriteFolderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneFavoriteFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateOneFavoriteFolderWithResponse(ctx context.Context, params *CreateOneFavoriteFolderParams, body CreateOneFavoriteFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneFavoriteFolderResponse, error) {
	rsp, err := c.CreateOneFavoriteFolder(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneFavoriteFolderResponse(rsp)
}

// FindFavoriteFolderDuplicatesWithBodyWithResponse request with arbitrary body returning *FindFavoriteFolderDuplicatesResponse
func (c *ClientWithResponses) FindFavoriteFolderDuplicatesWithBodyWithResponse(ctx context.Context, params *FindFavoriteFolderDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindFavoriteFolderDuplicatesResponse, error) {
	rsp, err := c.FindFavoriteFolderDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindFavoriteFolderDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindFavoriteFolderDuplicatesWithResponse(ctx context.Context, params *FindFavoriteFolderDuplicatesParams, body FindFavoriteFolderDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindFavoriteFolderDuplicatesResponse, error) {
	rsp, err := c.FindFavoriteFolderDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindFavoriteFolderDuplicatesResponse(rsp)
}

// MergeManyFavoriteFoldersWithBodyWithResponse request with arbitrary body returning *MergeManyFavoriteFoldersResponse
func (c *ClientWithResponses) MergeManyFavoriteFoldersWithBodyWithResponse(ctx context.Context, params *MergeManyFavoriteFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyFavoriteFoldersResponse, error) {
	rsp, err := c.MergeManyFavoriteFoldersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyFavoriteFoldersResponse(rsp)
}

func (c *ClientWithResponses) MergeManyFavoriteFoldersWithResponse(ctx context.Context, params *MergeManyFavoriteFoldersParams, body MergeManyFavoriteFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyFavoriteFoldersResponse, error) {
	rsp, err := c.MergeManyFavoriteFolders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyFavoriteFoldersResponse(rsp)
}

// DeleteOneFavoriteFolderWithResponse request returning *DeleteOneFavoriteFolderResponse
func (c *ClientWithResponses) DeleteOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *DeleteOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*DeleteOneFavoriteFolderResponse, error) {
	rsp, err := c.DeleteOneFavoriteFolder(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneFavoriteFolderResponse(rsp)
}

// FindOneFavoriteFolderWithResponse request returning *FindOneFavoriteFolderResponse
func (c *ClientWithResponses) FindOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *FindOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*FindOneFavoriteFolderResponse, error) {
	rsp, err := c.FindOneFavoriteFolder(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneFavoriteFolderResponse(rsp)
}

// UpdateOneFavoriteFolderWithBodyWithResponse request with arbitrary body returning *UpdateOneFavoriteFolderResponse
func (c *ClientWithResponses) UpdateOneFavoriteFolderWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteFolderResponse, error) {
	rsp, err := c.UpdateOneFavoriteFolderWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneFavoriteFolderResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteFolderParams, body UpdateOneFavoriteFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteFolderResponse, error) {
	rsp, err := c.UpdateOneFavoriteFolder(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneFavoriteFolderResponse(rsp)
}

// DeleteManyFavoritesWithResponse request returning *DeleteManyFavoritesResponse
func (c *ClientWithResponses) DeleteManyFavoritesWithResponse(ctx context.Context, params *DeleteManyFavoritesParams, reqEditors ...RequestEditorFn) (*DeleteManyFavoritesResponse, error) {
	rsp, err := c.DeleteManyFavorites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyFavoritesResponse(rsp)
}

// FindManyFavoritesWithResponse request returning *FindManyFavoritesResponse
func (c *ClientWithResponses) FindManyFavoritesWithResponse(ctx context.Context, params *FindManyFavoritesParams, reqEditors ...RequestEditorFn) (*FindManyFavoritesResponse, error) {
	rsp, err := c.FindManyFavorites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyFavoritesResponse(rsp)
}

// UpdateManyFavoritesWithBodyWithResponse request with arbitrary body returning *UpdateManyFavoritesResponse
func (c *ClientWithResponses) UpdateManyFavoritesWithBodyWithResponse(ctx context.Context, params *UpdateManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyFavoritesResponse, error) {
	rsp, err := c.UpdateManyFavoritesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyFavoritesResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyFavoritesWithResponse(ctx context.Context, params *UpdateManyFavoritesParams, body UpdateManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyFavoritesResponse, error) {
	rsp, err := c.UpdateManyFavorites(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyFavoritesResponse(rsp)
}

// CreateOneFavoriteWithBodyWithResponse request with arbitrary body returning *CreateOneFavoriteResponse
func (c *ClientWithResponses) CreateOneFavoriteWithBodyWithResponse(ctx context.Context, params *CreateOneFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneFavoriteResponse, error) {
	rsp, err := c.CreateOneFavoriteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneFavoriteResponse(rsp)
}

func (c *ClientWithResponses) CreateOneFavoriteWithResponse(ctx context.Context, params *CreateOneFavoriteParams, body CreateOneFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneFavoriteResponse, error) {
	rsp, err := c.CreateOneFavorite(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneFavoriteResponse(rsp)
}

// FindFavoriteDuplicatesWithBodyWithResponse request with arbitrary body returning *FindFavoriteDuplicatesResponse
func (c *ClientWithResponses) FindFavoriteDuplicatesWithBodyWithResponse(ctx context.Context, params *FindFavoriteDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindFavoriteDuplicatesResponse, error) {
	rsp, err := c.FindFavoriteDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindFavoriteDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindFavoriteDuplicatesWithResponse(ctx context.Context, params *FindFavoriteDuplicatesParams, body FindFavoriteDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindFavoriteDuplicatesResponse, error) {
	rsp, err := c.FindFavoriteDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindFavoriteDuplicatesResponse(rsp)
}

// MergeManyFavoritesWithBodyWithResponse request with arbitrary body returning *MergeManyFavoritesResponse
func (c *ClientWithResponses) MergeManyFavoritesWithBodyWithResponse(ctx context.Context, params *MergeManyFavoritesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyFavoritesResponse, error) {
	rsp, err := c.MergeManyFavoritesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyFavoritesResponse(rsp)
}

func (c *ClientWithResponses) MergeManyFavoritesWithResponse(ctx context.Context, params *MergeManyFavoritesParams, body MergeManyFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyFavoritesResponse, error) {
	rsp, err := c.MergeManyFavorites(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyFavoritesResponse(rsp)
}

// DeleteOneFavoriteWithResponse request returning *DeleteOneFavoriteResponse
func (c *ClientWithResponses) DeleteOneFavoriteWithResponse(ctx context.Context, id IdPath, params *DeleteOneFavoriteParams, reqEditors ...RequestEditorFn) (*DeleteOneFavoriteResponse, error) {
	rsp, err := c.DeleteOneFavorite(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneFavoriteResponse(rsp)
}

// FindOneFavoriteWithResponse request returning *FindOneFavoriteResponse
func (c *ClientWithResponses) FindOneFavoriteWithResponse(ctx context.Context, id IdPath, params *FindOneFavoriteParams, reqEditors ...RequestEditorFn) (*FindOneFavoriteResponse, error) {
	rsp, err := c.FindOneFavorite(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneFavoriteResponse(rsp)
}

// UpdateOneFavoriteWithBodyWithResponse request with arbitrary body returning *UpdateOneFavoriteResponse
func (c *ClientWithResponses) UpdateOneFavoriteWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteResponse, error) {
	rsp, err := c.UpdateOneFavoriteWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneFavoriteResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneFavoriteWithResponse(ctx context.Context, id IdPath, params *UpdateOneFavoriteParams, body UpdateOneFavoriteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneFavoriteResponse, error) {
	rsp, err := c.UpdateOneFavorite(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneFavoriteResponse(rsp)
}

// DeleteManyMessageChannelMessageAssociationsWithResponse request returning *DeleteManyMessageChannelMessageAssociationsResponse
func (c *ClientWithResponses) DeleteManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *DeleteManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.DeleteManyMessageChannelMessageAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyMessageChannelMessageAssociationsResponse(rsp)
}

// FindManyMessageChannelMessageAssociationsWithResponse request returning *FindManyMessageChannelMessageAssociationsResponse
func (c *ClientWithResponses) FindManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *FindManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*FindManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.FindManyMessageChannelMessageAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyMessageChannelMessageAssociationsResponse(rsp)
}

// UpdateManyMessageChannelMessageAssociationsWithBodyWithResponse request with arbitrary body returning *UpdateManyMessageChannelMessageAssociationsResponse
func (c *ClientWithResponses) UpdateManyMessageChannelMessageAssociationsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.UpdateManyMessageChannelMessageAssociationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageChannelMessageAssociationsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *UpdateManyMessageChannelMessageAssociationsParams, body UpdateManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.UpdateManyMessageChannelMessageAssociations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageChannelMessageAssociationsResponse(rsp)
}

// CreateOneMessageChannelMessageAssociationWithBodyWithResponse request with arbitrary body returning *CreateOneMessageChannelMessageAssociationResponse
func (c *ClientWithResponses) CreateOneMessageChannelMessageAssociationWithBodyWithResponse(ctx context.Context, params *CreateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelMessageAssociationResponse, error) {
	rsp, err := c.CreateOneMessageChannelMessageAssociationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageChannelMessageAssociationResponse(rsp)
}

func (c *ClientWithResponses) CreateOneMessageChannelMessageAssociationWithResponse(ctx context.Context, params *CreateOneMessageChannelMessageAssociationParams, body CreateOneMessageChannelMessageAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelMessageAssociationResponse, error) {
	rsp, err := c.CreateOneMessageChannelMessageAssociation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageChannelMessageAssociationResponse(rsp)
}

// FindMessageChannelMessageAssociationDuplicatesWithBodyWithResponse request with arbitrary body returning *FindMessageChannelMessageAssociationDuplicatesResponse
func (c *ClientWithResponses) FindMessageChannelMessageAssociationDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageChannelMessageAssociationDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageChannelMessageAssociationDuplicatesResponse, error) {
	rsp, err := c.FindMessageChannelMessageAssociationDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageChannelMessageAssociationDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindMessageChannelMessageAssociationDuplicatesWithResponse(ctx context.Context, params *FindMessageChannelMessageAssociationDuplicatesParams, body FindMessageChannelMessageAssociationDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageChannelMessageAssociationDuplicatesResponse, error) {
	rsp, err := c.FindMessageChannelMessageAssociationDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageChannelMessageAssociationDuplicatesResponse(rsp)
}

// MergeManyMessageChannelMessageAssociationsWithBodyWithResponse request with arbitrary body returning *MergeManyMessageChannelMessageAssociationsResponse
func (c *ClientWithResponses) MergeManyMessageChannelMessageAssociationsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageChannelMessageAssociationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.MergeManyMessageChannelMessageAssociationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageChannelMessageAssociationsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *MergeManyMessageChannelMessageAssociationsParams, body MergeManyMessageChannelMessageAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.MergeManyMessageChannelMessageAssociations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageChannelMessageAssociationsResponse(rsp)
}

// DeleteOneMessageChannelMessageAssociationWithResponse request returning *DeleteOneMessageChannelMessageAssociationResponse
func (c *ClientWithResponses) DeleteOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageChannelMessageAssociationResponse, error) {
	rsp, err := c.DeleteOneMessageChannelMessageAssociation(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneMessageChannelMessageAssociationResponse(rsp)
}

// FindOneMessageChannelMessageAssociationWithResponse request returning *FindOneMessageChannelMessageAssociationResponse
func (c *ClientWithResponses) FindOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *FindOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*FindOneMessageChannelMessageAssociationResponse, error) {
	rsp, err := c.FindOneMessageChannelMessageAssociation(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneMessageChannelMessageAssociationResponse(rsp)
}

// UpdateOneMessageChannelMessageAssociationWithBodyWithResponse request with arbitrary body returning *UpdateOneMessageChannelMessageAssociationResponse
func (c *ClientWithResponses) UpdateOneMessageChannelMessageAssociationWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelMessageAssociationResponse, error) {
	rsp, err := c.UpdateOneMessageChannelMessageAssociationWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageChannelMessageAssociationResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelMessageAssociationParams, body UpdateOneMessageChannelMessageAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelMessageAssociationResponse, error) {
	rsp, err := c.UpdateOneMessageChannelMessageAssociation(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageChannelMessageAssociationResponse(rsp)
}

// DeleteManyMessageChannelsWithResponse request returning *DeleteManyMessageChannelsResponse
func (c *ClientWithResponses) DeleteManyMessageChannelsWithResponse(ctx context.Context, params *DeleteManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageChannelsResponse, error) {
	rsp, err := c.DeleteManyMessageChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyMessageChannelsResponse(rsp)
}

// FindManyMessageChannelsWithResponse request returning *FindManyMessageChannelsResponse
func (c *ClientWithResponses) FindManyMessageChannelsWithResponse(ctx context.Context, params *FindManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*FindManyMessageChannelsResponse, error) {
	rsp, err := c.FindManyMessageChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyMessageChannelsResponse(rsp)
}

// UpdateManyMessageChannelsWithBodyWithResponse request with arbitrary body returning *UpdateManyMessageChannelsResponse
func (c *ClientWithResponses) UpdateManyMessageChannelsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelsResponse, error) {
	rsp, err := c.UpdateManyMessageChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageChannelsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyMessageChannelsWithResponse(ctx context.Context, params *UpdateManyMessageChannelsParams, body UpdateManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageChannelsResponse, error) {
	rsp, err := c.UpdateManyMessageChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageChannelsResponse(rsp)
}

// CreateOneMessageChannelWithBodyWithResponse request with arbitrary body returning *CreateOneMessageChannelResponse
func (c *ClientWithResponses) CreateOneMessageChannelWithBodyWithResponse(ctx context.Context, params *CreateOneMessageChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelResponse, error) {
	rsp, err := c.CreateOneMessageChannelWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateOneMessageChannelWithResponse(ctx context.Context, params *CreateOneMessageChannelParams, body CreateOneMessageChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageChannelResponse, error) {
	rsp, err := c.CreateOneMessageChannel(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageChannelResponse(rsp)
}

// FindMessageChannelDuplicatesWithBodyWithResponse request with arbitrary body returning *FindMessageChannelDuplicatesResponse
func (c *ClientWithResponses) FindMessageChannelDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageChannelDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageChannelDuplicatesResponse, error) {
	rsp, err := c.FindMessageChannelDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageChannelDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindMessageChannelDuplicatesWithResponse(ctx context.Context, params *FindMessageChannelDuplicatesParams, body FindMessageChannelDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageChannelDuplicatesResponse, error) {
	rsp, err := c.FindMessageChannelDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageChannelDuplicatesResponse(rsp)
}

// MergeManyMessageChannelsWithBodyWithResponse request with arbitrary body returning *MergeManyMessageChannelsResponse
func (c *ClientWithResponses) MergeManyMessageChannelsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelsResponse, error) {
	rsp, err := c.MergeManyMessageChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageChannelsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyMessageChannelsWithResponse(ctx context.Context, params *MergeManyMessageChannelsParams, body MergeManyMessageChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageChannelsResponse, error) {
	rsp, err := c.MergeManyMessageChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageChannelsResponse(rsp)
}

// DeleteOneMessageChannelWithResponse request returning *DeleteOneMessageChannelResponse
func (c *ClientWithResponses) DeleteOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageChannelParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageChannelResponse, error) {
	rsp, err := c.DeleteOneMessageChannel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneMessageChannelResponse(rsp)
}

// FindOneMessageChannelWithResponse request returning *FindOneMessageChannelResponse
func (c *ClientWithResponses) FindOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *FindOneMessageChannelParams, reqEditors ...RequestEditorFn) (*FindOneMessageChannelResponse, error) {
	rsp, err := c.FindOneMessageChannel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneMessageChannelResponse(rsp)
}

// UpdateOneMessageChannelWithBodyWithResponse request with arbitrary body returning *UpdateOneMessageChannelResponse
func (c *ClientWithResponses) UpdateOneMessageChannelWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelResponse, error) {
	rsp, err := c.UpdateOneMessageChannelWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageChannelResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageChannelParams, body UpdateOneMessageChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageChannelResponse, error) {
	rsp, err := c.UpdateOneMessageChannel(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageChannelResponse(rsp)
}

// DeleteManyMessageFoldersWithResponse request returning *DeleteManyMessageFoldersResponse
func (c *ClientWithResponses) DeleteManyMessageFoldersWithResponse(ctx context.Context, params *DeleteManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageFoldersResponse, error) {
	rsp, err := c.DeleteManyMessageFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyMessageFoldersResponse(rsp)
}

// FindManyMessageFoldersWithResponse request returning *FindManyMessageFoldersResponse
func (c *ClientWithResponses) FindManyMessageFoldersWithResponse(ctx context.Context, params *FindManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*FindManyMessageFoldersResponse, error) {
	rsp, err := c.FindManyMessageFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyMessageFoldersResponse(rsp)
}

// UpdateManyMessageFoldersWithBodyWithResponse request with arbitrary body returning *UpdateManyMessageFoldersResponse
func (c *ClientWithResponses) UpdateManyMessageFoldersWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageFoldersResponse, error) {
	rsp, err := c.UpdateManyMessageFoldersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageFoldersResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyMessageFoldersWithResponse(ctx context.Context, params *UpdateManyMessageFoldersParams, body UpdateManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageFoldersResponse, error) {
	rsp, err := c.UpdateManyMessageFolders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageFoldersResponse(rsp)
}

// CreateOneMessageFolderWithBodyWithResponse request with arbitrary body returning *CreateOneMessageFolderResponse
func (c *ClientWithResponses) CreateOneMessageFolderWithBodyWithResponse(ctx context.Context, params *CreateOneMessageFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageFolderResponse, error) {
	rsp, err := c.CreateOneMessageFolderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateOneMessageFolderWithResponse(ctx context.Context, params *CreateOneMessageFolderParams, body CreateOneMessageFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageFolderResponse, error) {
	rsp, err := c.CreateOneMessageFolder(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageFolderResponse(rsp)
}

// FindMessageFolderDuplicatesWithBodyWithResponse request with arbitrary body returning *FindMessageFolderDuplicatesResponse
func (c *ClientWithResponses) FindMessageFolderDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageFolderDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageFolderDuplicatesResponse, error) {
	rsp, err := c.FindMessageFolderDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageFolderDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindMessageFolderDuplicatesWithResponse(ctx context.Context, params *FindMessageFolderDuplicatesParams, body FindMessageFolderDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageFolderDuplicatesResponse, error) {
	rsp, err := c.FindMessageFolderDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageFolderDuplicatesResponse(rsp)
}

// MergeManyMessageFoldersWithBodyWithResponse request with arbitrary body returning *MergeManyMessageFoldersResponse
func (c *ClientWithResponses) MergeManyMessageFoldersWithBodyWithResponse(ctx context.Context, params *MergeManyMessageFoldersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageFoldersResponse, error) {
	rsp, err := c.MergeManyMessageFoldersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageFoldersResponse(rsp)
}

func (c *ClientWithResponses) MergeManyMessageFoldersWithResponse(ctx context.Context, params *MergeManyMessageFoldersParams, body MergeManyMessageFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageFoldersResponse, error) {
	rsp, err := c.MergeManyMessageFolders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageFoldersResponse(rsp)
}

// DeleteOneMessageFolderWithResponse request returning *DeleteOneMessageFolderResponse
func (c *ClientWithResponses) DeleteOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageFolderParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageFolderResponse, error) {
	rsp, err := c.DeleteOneMessageFolder(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneMessageFolderResponse(rsp)
}

// FindOneMessageFolderWithResponse request returning *FindOneMessageFolderResponse
func (c *ClientWithResponses) FindOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *FindOneMessageFolderParams, reqEditors ...RequestEditorFn) (*FindOneMessageFolderResponse, error) {
	rsp, err := c.FindOneMessageFolder(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneMessageFolderResponse(rsp)
}

// UpdateOneMessageFolderWithBodyWithResponse request with arbitrary body returning *UpdateOneMessageFolderResponse
func (c *ClientWithResponses) UpdateOneMessageFolderWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageFolderResponse, error) {
	rsp, err := c.UpdateOneMessageFolderWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageFolderResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageFolderParams, body UpdateOneMessageFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageFolderResponse, error) {
	rsp, err := c.UpdateOneMessageFolder(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageFolderResponse(rsp)
}

// DeleteManyMessageParticipantsWithResponse request returning *DeleteManyMessageParticipantsResponse
func (c *ClientWithResponses) DeleteManyMessageParticipantsWithResponse(ctx context.Context, params *DeleteManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageParticipantsResponse, error) {
	rsp, err := c.DeleteManyMessageParticipants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyMessageParticipantsResponse(rsp)
}

// FindManyMessageParticipantsWithResponse request returning *FindManyMessageParticipantsResponse
func (c *ClientWithResponses) FindManyMessageParticipantsWithResponse(ctx context.Context, params *FindManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*FindManyMessageParticipantsResponse, error) {
	rsp, err := c.FindManyMessageParticipants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyMessageParticipantsResponse(rsp)
}

// UpdateManyMessageParticipantsWithBodyWithResponse request with arbitrary body returning *UpdateManyMessageParticipantsResponse
func (c *ClientWithResponses) UpdateManyMessageParticipantsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageParticipantsResponse, error) {
	rsp, err := c.UpdateManyMessageParticipantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageParticipantsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyMessageParticipantsWithResponse(ctx context.Context, params *UpdateManyMessageParticipantsParams, body UpdateManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageParticipantsResponse, error) {
	rsp, err := c.UpdateManyMessageParticipants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageParticipantsResponse(rsp)
}

// CreateOneMessageParticipantWithBodyWithResponse request with arbitrary body returning *CreateOneMessageParticipantResponse
func (c *ClientWithResponses) CreateOneMessageParticipantWithBodyWithResponse(ctx context.Context, params *CreateOneMessageParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageParticipantResponse, error) {
	rsp, err := c.CreateOneMessageParticipantWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageParticipantResponse(rsp)
}

func (c *ClientWithResponses) CreateOneMessageParticipantWithResponse(ctx context.Context, params *CreateOneMessageParticipantParams, body CreateOneMessageParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageParticipantResponse, error) {
	rsp, err := c.CreateOneMessageParticipant(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageParticipantResponse(rsp)
}

// FindMessageParticipantDuplicatesWithBodyWithResponse request with arbitrary body returning *FindMessageParticipantDuplicatesResponse
func (c *ClientWithResponses) FindMessageParticipantDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageParticipantDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageParticipantDuplicatesResponse, error) {
	rsp, err := c.FindMessageParticipantDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageParticipantDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindMessageParticipantDuplicatesWithResponse(ctx context.Context, params *FindMessageParticipantDuplicatesParams, body FindMessageParticipantDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageParticipantDuplicatesResponse, error) {
	rsp, err := c.FindMessageParticipantDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageParticipantDuplicatesResponse(rsp)
}

// MergeManyMessageParticipantsWithBodyWithResponse request with arbitrary body returning *MergeManyMessageParticipantsResponse
func (c *ClientWithResponses) MergeManyMessageParticipantsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageParticipantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageParticipantsResponse, error) {
	rsp, err := c.MergeManyMessageParticipantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageParticipantsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyMessageParticipantsWithResponse(ctx context.Context, params *MergeManyMessageParticipantsParams, body MergeManyMessageParticipantsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageParticipantsResponse, error) {
	rsp, err := c.MergeManyMessageParticipants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageParticipantsResponse(rsp)
}

// DeleteOneMessageParticipantWithResponse request returning *DeleteOneMessageParticipantResponse
func (c *ClientWithResponses) DeleteOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageParticipantResponse, error) {
	rsp, err := c.DeleteOneMessageParticipant(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneMessageParticipantResponse(rsp)
}

// FindOneMessageParticipantWithResponse request returning *FindOneMessageParticipantResponse
func (c *ClientWithResponses) FindOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *FindOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*FindOneMessageParticipantResponse, error) {
	rsp, err := c.FindOneMessageParticipant(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneMessageParticipantResponse(rsp)
}

// UpdateOneMessageParticipantWithBodyWithResponse request with arbitrary body returning *UpdateOneMessageParticipantResponse
func (c *ClientWithResponses) UpdateOneMessageParticipantWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParticipantParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageParticipantResponse, error) {
	rsp, err := c.UpdateOneMessageParticipantWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageParticipantResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParticipantParams, body UpdateOneMessageParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageParticipantResponse, error) {
	rsp, err := c.UpdateOneMessageParticipant(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageParticipantResponse(rsp)
}

// DeleteManyMessageThreadsWithResponse request returning *DeleteManyMessageThreadsResponse
func (c *ClientWithResponses) DeleteManyMessageThreadsWithResponse(ctx context.Context, params *DeleteManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*DeleteManyMessageThreadsResponse, error) {
	rsp, err := c.DeleteManyMessageThreads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyMessageThreadsResponse(rsp)
}

// FindManyMessageThreadsWithResponse request returning *FindManyMessageThreadsResponse
func (c *ClientWithResponses) FindManyMessageThreadsWithResponse(ctx context.Context, params *FindManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*FindManyMessageThreadsResponse, error) {
	rsp, err := c.FindManyMessageThreads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyMessageThreadsResponse(rsp)
}

// UpdateManyMessageThreadsWithBodyWithResponse request with arbitrary body returning *UpdateManyMessageThreadsResponse
func (c *ClientWithResponses) UpdateManyMessageThreadsWithBodyWithResponse(ctx context.Context, params *UpdateManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessageThreadsResponse, error) {
	rsp, err := c.UpdateManyMessageThreadsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageThreadsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyMessageThreadsWithResponse(ctx context.Context, params *UpdateManyMessageThreadsParams, body UpdateManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessageThreadsResponse, error) {
	rsp, err := c.UpdateManyMessageThreads(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessageThreadsResponse(rsp)
}

// CreateOneMessageThreadWithBodyWithResponse request with arbitrary body returning *CreateOneMessageThreadResponse
func (c *ClientWithResponses) CreateOneMessageThreadWithBodyWithResponse(ctx context.Context, params *CreateOneMessageThreadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageThreadResponse, error) {
	rsp, err := c.CreateOneMessageThreadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageThreadResponse(rsp)
}

func (c *ClientWithResponses) CreateOneMessageThreadWithResponse(ctx context.Context, params *CreateOneMessageThreadParams, body CreateOneMessageThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageThreadResponse, error) {
	rsp, err := c.CreateOneMessageThread(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageThreadResponse(rsp)
}

// FindMessageThreadDuplicatesWithBodyWithResponse request with arbitrary body returning *FindMessageThreadDuplicatesResponse
func (c *ClientWithResponses) FindMessageThreadDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageThreadDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageThreadDuplicatesResponse, error) {
	rsp, err := c.FindMessageThreadDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageThreadDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindMessageThreadDuplicatesWithResponse(ctx context.Context, params *FindMessageThreadDuplicatesParams, body FindMessageThreadDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageThreadDuplicatesResponse, error) {
	rsp, err := c.FindMessageThreadDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageThreadDuplicatesResponse(rsp)
}

// MergeManyMessageThreadsWithBodyWithResponse request with arbitrary body returning *MergeManyMessageThreadsResponse
func (c *ClientWithResponses) MergeManyMessageThreadsWithBodyWithResponse(ctx context.Context, params *MergeManyMessageThreadsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessageThreadsResponse, error) {
	rsp, err := c.MergeManyMessageThreadsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageThreadsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyMessageThreadsWithResponse(ctx context.Context, params *MergeManyMessageThreadsParams, body MergeManyMessageThreadsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessageThreadsResponse, error) {
	rsp, err := c.MergeManyMessageThreads(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessageThreadsResponse(rsp)
}

// DeleteOneMessageThreadWithResponse request returning *DeleteOneMessageThreadResponse
func (c *ClientWithResponses) DeleteOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageThreadParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageThreadResponse, error) {
	rsp, err := c.DeleteOneMessageThread(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneMessageThreadResponse(rsp)
}

// FindOneMessageThreadWithResponse request returning *FindOneMessageThreadResponse
func (c *ClientWithResponses) FindOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *FindOneMessageThreadParams, reqEditors ...RequestEditorFn) (*FindOneMessageThreadResponse, error) {
	rsp, err := c.FindOneMessageThread(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneMessageThreadResponse(rsp)
}

// UpdateOneMessageThreadWithBodyWithResponse request with arbitrary body returning *UpdateOneMessageThreadResponse
func (c *ClientWithResponses) UpdateOneMessageThreadWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageThreadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageThreadResponse, error) {
	rsp, err := c.UpdateOneMessageThreadWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageThreadResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageThreadParams, body UpdateOneMessageThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageThreadResponse, error) {
	rsp, err := c.UpdateOneMessageThread(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageThreadResponse(rsp)
}

// DeleteManyMessagesWithResponse request returning *DeleteManyMessagesResponse
func (c *ClientWithResponses) DeleteManyMessagesWithResponse(ctx context.Context, params *DeleteManyMessagesParams, reqEditors ...RequestEditorFn) (*DeleteManyMessagesResponse, error) {
	rsp, err := c.DeleteManyMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyMessagesResponse(rsp)
}

// FindManyMessagesWithResponse request returning *FindManyMessagesResponse
func (c *ClientWithResponses) FindManyMessagesWithResponse(ctx context.Context, params *FindManyMessagesParams, reqEditors ...RequestEditorFn) (*FindManyMessagesResponse, error) {
	rsp, err := c.FindManyMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyMessagesResponse(rsp)
}

// UpdateManyMessagesWithBodyWithResponse request with arbitrary body returning *UpdateManyMessagesResponse
func (c *ClientWithResponses) UpdateManyMessagesWithBodyWithResponse(ctx context.Context, params *UpdateManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyMessagesResponse, error) {
	rsp, err := c.UpdateManyMessagesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessagesResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyMessagesWithResponse(ctx context.Context, params *UpdateManyMessagesParams, body UpdateManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyMessagesResponse, error) {
	rsp, err := c.UpdateManyMessages(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyMessagesResponse(rsp)
}

// CreateOneMessageWithBodyWithResponse request with arbitrary body returning *CreateOneMessageResponse
func (c *ClientWithResponses) CreateOneMessageWithBodyWithResponse(ctx context.Context, params *CreateOneMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneMessageResponse, error) {
	rsp, err := c.CreateOneMessageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageResponse(rsp)
}

func (c *ClientWithResponses) CreateOneMessageWithResponse(ctx context.Context, params *CreateOneMessageParams, body CreateOneMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneMessageResponse, error) {
	rsp, err := c.CreateOneMessage(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneMessageResponse(rsp)
}

// FindMessageDuplicatesWithBodyWithResponse request with arbitrary body returning *FindMessageDuplicatesResponse
func (c *ClientWithResponses) FindMessageDuplicatesWithBodyWithResponse(ctx context.Context, params *FindMessageDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindMessageDuplicatesResponse, error) {
	rsp, err := c.FindMessageDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindMessageDuplicatesWithResponse(ctx context.Context, params *FindMessageDuplicatesParams, body FindMessageDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindMessageDuplicatesResponse, error) {
	rsp, err := c.FindMessageDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMessageDuplicatesResponse(rsp)
}

// MergeManyMessagesWithBodyWithResponse request with arbitrary body returning *MergeManyMessagesResponse
func (c *ClientWithResponses) MergeManyMessagesWithBodyWithResponse(ctx context.Context, params *MergeManyMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyMessagesResponse, error) {
	rsp, err := c.MergeManyMessagesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessagesResponse(rsp)
}

func (c *ClientWithResponses) MergeManyMessagesWithResponse(ctx context.Context, params *MergeManyMessagesParams, body MergeManyMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyMessagesResponse, error) {
	rsp, err := c.MergeManyMessages(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyMessagesResponse(rsp)
}

// DeleteOneMessageWithResponse request returning *DeleteOneMessageResponse
func (c *ClientWithResponses) DeleteOneMessageWithResponse(ctx context.Context, id IdPath, params *DeleteOneMessageParams, reqEditors ...RequestEditorFn) (*DeleteOneMessageResponse, error) {
	rsp, err := c.DeleteOneMessage(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneMessageResponse(rsp)
}

// FindOneMessageWithResponse request returning *FindOneMessageResponse
func (c *ClientWithResponses) FindOneMessageWithResponse(ctx context.Context, id IdPath, params *FindOneMessageParams, reqEditors ...RequestEditorFn) (*FindOneMessageResponse, error) {
	rsp, err := c.FindOneMessage(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneMessageResponse(rsp)
}

// UpdateOneMessageWithBodyWithResponse request with arbitrary body returning *UpdateOneMessageResponse
func (c *ClientWithResponses) UpdateOneMessageWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneMessageResponse, error) {
	rsp, err := c.UpdateOneMessageWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneMessageWithResponse(ctx context.Context, id IdPath, params *UpdateOneMessageParams, body UpdateOneMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneMessageResponse, error) {
	rsp, err := c.UpdateOneMessage(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneMessageResponse(rsp)
}

// DeleteManyNoteTargetsWithResponse request returning *DeleteManyNoteTargetsResponse
func (c *ClientWithResponses) DeleteManyNoteTargetsWithResponse(ctx context.Context, params *DeleteManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*DeleteManyNoteTargetsResponse, error) {
	rsp, err := c.DeleteManyNoteTargets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyNoteTargetsResponse(rsp)
}

// FindManyNoteTargetsWithResponse request returning *FindManyNoteTargetsResponse
func (c *ClientWithResponses) FindManyNoteTargetsWithResponse(ctx context.Context, params *FindManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*FindManyNoteTargetsResponse, error) {
	rsp, err := c.FindManyNoteTargets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyNoteTargetsResponse(rsp)
}

// UpdateManyNoteTargetsWithBodyWithResponse request with arbitrary body returning *UpdateManyNoteTargetsResponse
func (c *ClientWithResponses) UpdateManyNoteTargetsWithBodyWithResponse(ctx context.Context, params *UpdateManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyNoteTargetsResponse, error) {
	rsp, err := c.UpdateManyNoteTargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyNoteTargetsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyNoteTargetsWithResponse(ctx context.Context, params *UpdateManyNoteTargetsParams, body UpdateManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyNoteTargetsResponse, error) {
	rsp, err := c.UpdateManyNoteTargets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyNoteTargetsResponse(rsp)
}

// CreateOneNoteTargetWithBodyWithResponse request with arbitrary body returning *CreateOneNoteTargetResponse
func (c *ClientWithResponses) CreateOneNoteTargetWithBodyWithResponse(ctx context.Context, params *CreateOneNoteTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneNoteTargetResponse, error) {
	rsp, err := c.CreateOneNoteTargetWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneNoteTargetResponse(rsp)
}

func (c *ClientWithResponses) CreateOneNoteTargetWithResponse(ctx context.Context, params *CreateOneNoteTargetParams, body CreateOneNoteTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneNoteTargetResponse, error) {
	rsp, err := c.CreateOneNoteTarget(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneNoteTargetResponse(rsp)
}

// FindNoteTargetDuplicatesWithBodyWithResponse request with arbitrary body returning *FindNoteTargetDuplicatesResponse
func (c *ClientWithResponses) FindNoteTargetDuplicatesWithBodyWithResponse(ctx context.Context, params *FindNoteTargetDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindNoteTargetDuplicatesResponse, error) {
	rsp, err := c.FindNoteTargetDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindNoteTargetDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindNoteTargetDuplicatesWithResponse(ctx context.Context, params *FindNoteTargetDuplicatesParams, body FindNoteTargetDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindNoteTargetDuplicatesResponse, error) {
	rsp, err := c.FindNoteTargetDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindNoteTargetDuplicatesResponse(rsp)
}

// MergeManyNoteTargetsWithBodyWithResponse request with arbitrary body returning *MergeManyNoteTargetsResponse
func (c *ClientWithResponses) MergeManyNoteTargetsWithBodyWithResponse(ctx context.Context, params *MergeManyNoteTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyNoteTargetsResponse, error) {
	rsp, err := c.MergeManyNoteTargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyNoteTargetsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyNoteTargetsWithResponse(ctx context.Context, params *MergeManyNoteTargetsParams, body MergeManyNoteTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyNoteTargetsResponse, error) {
	rsp, err := c.MergeManyNoteTargets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyNoteTargetsResponse(rsp)
}

// DeleteOneNoteTargetWithResponse request returning *DeleteOneNoteTargetResponse
func (c *ClientWithResponses) DeleteOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *DeleteOneNoteTargetParams, reqEditors ...RequestEditorFn) (*DeleteOneNoteTargetResponse, error) {
	rsp, err := c.DeleteOneNoteTarget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneNoteTargetResponse(rsp)
}

// FindOneNoteTargetWithResponse request returning *FindOneNoteTargetResponse
func (c *ClientWithResponses) FindOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *FindOneNoteTargetParams, reqEditors ...RequestEditorFn) (*FindOneNoteTargetResponse, error) {
	rsp, err := c.FindOneNoteTarget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneNoteTargetResponse(rsp)
}

// UpdateOneNoteTargetWithBodyWithResponse request with arbitrary body returning *UpdateOneNoteTargetResponse
func (c *ClientWithResponses) UpdateOneNoteTargetWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneNoteTargetResponse, error) {
	rsp, err := c.UpdateOneNoteTargetWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneNoteTargetResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteTargetParams, body UpdateOneNoteTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneNoteTargetResponse, error) {
	rsp, err := c.UpdateOneNoteTarget(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneNoteTargetResponse(rsp)
}

// DeleteManyNotesWithResponse request returning *DeleteManyNotesResponse
func (c *ClientWithResponses) DeleteManyNotesWithResponse(ctx context.Context, params *DeleteManyNotesParams, reqEditors ...RequestEditorFn) (*DeleteManyNotesResponse, error) {
	rsp, err := c.DeleteManyNotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyNotesResponse(rsp)
}

// FindManyNotesWithResponse request returning *FindManyNotesResponse
func (c *ClientWithResponses) FindManyNotesWithResponse(ctx context.Context, params *FindManyNotesParams, reqEditors ...RequestEditorFn) (*FindManyNotesResponse, error) {
	rsp, err := c.FindManyNotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyNotesResponse(rsp)
}

// UpdateManyNotesWithBodyWithResponse request with arbitrary body returning *UpdateManyNotesResponse
func (c *ClientWithResponses) UpdateManyNotesWithBodyWithResponse(ctx context.Context, params *UpdateManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyNotesResponse, error) {
	rsp, err := c.UpdateManyNotesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyNotesResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyNotesWithResponse(ctx context.Context, params *UpdateManyNotesParams, body UpdateManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyNotesResponse, error) {
	rsp, err := c.UpdateManyNotes(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyNotesResponse(rsp)
}

// CreateOneNoteWithBodyWithResponse request with arbitrary body returning *CreateOneNoteResponse
func (c *ClientWithResponses) CreateOneNoteWithBodyWithResponse(ctx context.Context, params *CreateOneNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneNoteResponse, error) {
	rsp, err := c.CreateOneNoteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneNoteResponse(rsp)
}

func (c *ClientWithResponses) CreateOneNoteWithResponse(ctx context.Context, params *CreateOneNoteParams, body CreateOneNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneNoteResponse, error) {
	rsp, err := c.CreateOneNote(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneNoteResponse(rsp)
}

// FindNoteDuplicatesWithBodyWithResponse request with arbitrary body returning *FindNoteDuplicatesResponse
func (c *ClientWithResponses) FindNoteDuplicatesWithBodyWithResponse(ctx context.Context, params *FindNoteDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindNoteDuplicatesResponse, error) {
	rsp, err := c.FindNoteDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindNoteDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindNoteDuplicatesWithResponse(ctx context.Context, params *FindNoteDuplicatesParams, body FindNoteDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindNoteDuplicatesResponse, error) {
	rsp, err := c.FindNoteDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindNoteDuplicatesResponse(rsp)
}

// MergeManyNotesWithBodyWithResponse request with arbitrary body returning *MergeManyNotesResponse
func (c *ClientWithResponses) MergeManyNotesWithBodyWithResponse(ctx context.Context, params *MergeManyNotesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyNotesResponse, error) {
	rsp, err := c.MergeManyNotesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyNotesResponse(rsp)
}

func (c *ClientWithResponses) MergeManyNotesWithResponse(ctx context.Context, params *MergeManyNotesParams, body MergeManyNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyNotesResponse, error) {
	rsp, err := c.MergeManyNotes(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyNotesResponse(rsp)
}

// DeleteOneNoteWithResponse request returning *DeleteOneNoteResponse
func (c *ClientWithResponses) DeleteOneNoteWithResponse(ctx context.Context, id IdPath, params *DeleteOneNoteParams, reqEditors ...RequestEditorFn) (*DeleteOneNoteResponse, error) {
	rsp, err := c.DeleteOneNote(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneNoteResponse(rsp)
}

// FindOneNoteWithResponse request returning *FindOneNoteResponse
func (c *ClientWithResponses) FindOneNoteWithResponse(ctx context.Context, id IdPath, params *FindOneNoteParams, reqEditors ...RequestEditorFn) (*FindOneNoteResponse, error) {
	rsp, err := c.FindOneNote(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneNoteResponse(rsp)
}

// UpdateOneNoteWithBodyWithResponse request with arbitrary body returning *UpdateOneNoteResponse
func (c *ClientWithResponses) UpdateOneNoteWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneNoteResponse, error) {
	rsp, err := c.UpdateOneNoteWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneNoteResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneNoteWithResponse(ctx context.Context, id IdPath, params *UpdateOneNoteParams, body UpdateOneNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneNoteResponse, error) {
	rsp, err := c.UpdateOneNote(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneNoteResponse(rsp)
}

// GetOpenApiSchemaWithResponse request returning *GetOpenApiSchemaResponse
func (c *ClientWithResponses) GetOpenApiSchemaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiSchemaResponse, error) {
	rsp, err := c.GetOpenApiSchema(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenApiSchemaResponse(rsp)
}

// DeleteManyOpportunitiesWithResponse request returning *DeleteManyOpportunitiesResponse
func (c *ClientWithResponses) DeleteManyOpportunitiesWithResponse(ctx context.Context, params *DeleteManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*DeleteManyOpportunitiesResponse, error) {
	rsp, err := c.DeleteManyOpportunities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyOpportunitiesResponse(rsp)
}

// FindManyOpportunitiesWithResponse request returning *FindManyOpportunitiesResponse
func (c *ClientWithResponses) FindManyOpportunitiesWithResponse(ctx context.Context, params *FindManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*FindManyOpportunitiesResponse, error) {
	rsp, err := c.FindManyOpportunities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyOpportunitiesResponse(rsp)
}

// UpdateManyOpportunitiesWithBodyWithResponse request with arbitrary body returning *UpdateManyOpportunitiesResponse
func (c *ClientWithResponses) UpdateManyOpportunitiesWithBodyWithResponse(ctx context.Context, params *UpdateManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyOpportunitiesResponse, error) {
	rsp, err := c.UpdateManyOpportunitiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyOpportunitiesResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyOpportunitiesWithResponse(ctx context.Context, params *UpdateManyOpportunitiesParams, body UpdateManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyOpportunitiesResponse, error) {
	rsp, err := c.UpdateManyOpportunities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyOpportunitiesResponse(rsp)
}

// CreateOneOpportunityWithBodyWithResponse request with arbitrary body returning *CreateOneOpportunityResponse
func (c *ClientWithResponses) CreateOneOpportunityWithBodyWithResponse(ctx context.Context, params *CreateOneOpportunityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneOpportunityResponse, error) {
	rsp, err := c.CreateOneOpportunityWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneOpportunityResponse(rsp)
}

func (c *ClientWithResponses) CreateOneOpportunityWithResponse(ctx context.Context, params *CreateOneOpportunityParams, body CreateOneOpportunityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneOpportunityResponse, error) {
	rsp, err := c.CreateOneOpportunity(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneOpportunityResponse(rsp)
}

// FindOpportunityDuplicatesWithBodyWithResponse request with arbitrary body returning *FindOpportunityDuplicatesResponse
func (c *ClientWithResponses) FindOpportunityDuplicatesWithBodyWithResponse(ctx context.Context, params *FindOpportunityDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindOpportunityDuplicatesResponse, error) {
	rsp, err := c.FindOpportunityDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOpportunityDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindOpportunityDuplicatesWithResponse(ctx context.Context, params *FindOpportunityDuplicatesParams, body FindOpportunityDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindOpportunityDuplicatesResponse, error) {
	rsp, err := c.FindOpportunityDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOpportunityDuplicatesResponse(rsp)
}

// MergeManyOpportunitiesWithBodyWithResponse request with arbitrary body returning *MergeManyOpportunitiesResponse
func (c *ClientWithResponses) MergeManyOpportunitiesWithBodyWithResponse(ctx context.Context, params *MergeManyOpportunitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyOpportunitiesResponse, error) {
	rsp, err := c.MergeManyOpportunitiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyOpportunitiesResponse(rsp)
}

func (c *ClientWithResponses) MergeManyOpportunitiesWithResponse(ctx context.Context, params *MergeManyOpportunitiesParams, body MergeManyOpportunitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyOpportunitiesResponse, error) {
	rsp, err := c.MergeManyOpportunities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyOpportunitiesResponse(rsp)
}

// DeleteOneOpportunityWithResponse request returning *DeleteOneOpportunityResponse
func (c *ClientWithResponses) DeleteOneOpportunityWithResponse(ctx context.Context, id IdPath, params *DeleteOneOpportunityParams, reqEditors ...RequestEditorFn) (*DeleteOneOpportunityResponse, error) {
	rsp, err := c.DeleteOneOpportunity(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneOpportunityResponse(rsp)
}

// FindOneOpportunityWithResponse request returning *FindOneOpportunityResponse
func (c *ClientWithResponses) FindOneOpportunityWithResponse(ctx context.Context, id IdPath, params *FindOneOpportunityParams, reqEditors ...RequestEditorFn) (*FindOneOpportunityResponse, error) {
	rsp, err := c.FindOneOpportunity(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneOpportunityResponse(rsp)
}

// UpdateOneOpportunityWithBodyWithResponse request with arbitrary body returning *UpdateOneOpportunityResponse
func (c *ClientWithResponses) UpdateOneOpportunityWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneOpportunityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneOpportunityResponse, error) {
	rsp, err := c.UpdateOneOpportunityWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneOpportunityResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneOpportunityWithResponse(ctx context.Context, id IdPath, params *UpdateOneOpportunityParams, body UpdateOneOpportunityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneOpportunityResponse, error) {
	rsp, err := c.UpdateOneOpportunity(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneOpportunityResponse(rsp)
}

// DeleteManyPeopleWithResponse request returning *DeleteManyPeopleResponse
func (c *ClientWithResponses) DeleteManyPeopleWithResponse(ctx context.Context, params *DeleteManyPeopleParams, reqEditors ...RequestEditorFn) (*DeleteManyPeopleResponse, error) {
	rsp, err := c.DeleteManyPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyPeopleResponse(rsp)
}

// FindManyPeopleWithResponse request returning *FindManyPeopleResponse
func (c *ClientWithResponses) FindManyPeopleWithResponse(ctx context.Context, params *FindManyPeopleParams, reqEditors ...RequestEditorFn) (*FindManyPeopleResponse, error) {
	rsp, err := c.FindManyPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyPeopleResponse(rsp)
}

// UpdateManyPeopleWithBodyWithResponse request with arbitrary body returning *UpdateManyPeopleResponse
func (c *ClientWithResponses) UpdateManyPeopleWithBodyWithResponse(ctx context.Context, params *UpdateManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyPeopleResponse, error) {
	rsp, err := c.UpdateManyPeopleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyPeopleResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyPeopleWithResponse(ctx context.Context, params *UpdateManyPeopleParams, body UpdateManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyPeopleResponse, error) {
	rsp, err := c.UpdateManyPeople(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyPeopleResponse(rsp)
}

// CreateOnePersonWithBodyWithResponse request with arbitrary body returning *CreateOnePersonResponse
func (c *ClientWithResponses) CreateOnePersonWithBodyWithResponse(ctx context.Context, params *CreateOnePersonParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnePersonResponse, error) {
	rsp, err := c.CreateOnePersonWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnePersonResponse(rsp)
}

func (c *ClientWithResponses) CreateOnePersonWithResponse(ctx context.Context, params *CreateOnePersonParams, body CreateOnePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnePersonResponse, error) {
	rsp, err := c.CreateOnePerson(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnePersonResponse(rsp)
}

// FindPersonDuplicatesWithBodyWithResponse request with arbitrary body returning *FindPersonDuplicatesResponse
func (c *ClientWithResponses) FindPersonDuplicatesWithBodyWithResponse(ctx context.Context, params *FindPersonDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindPersonDuplicatesResponse, error) {
	rsp, err := c.FindPersonDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPersonDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindPersonDuplicatesWithResponse(ctx context.Context, params *FindPersonDuplicatesParams, body FindPersonDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindPersonDuplicatesResponse, error) {
	rsp, err := c.FindPersonDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPersonDuplicatesResponse(rsp)
}

// MergeManyPeopleWithBodyWithResponse request with arbitrary body returning *MergeManyPeopleResponse
func (c *ClientWithResponses) MergeManyPeopleWithBodyWithResponse(ctx context.Context, params *MergeManyPeopleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyPeopleResponse, error) {
	rsp, err := c.MergeManyPeopleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyPeopleResponse(rsp)
}

func (c *ClientWithResponses) MergeManyPeopleWithResponse(ctx context.Context, params *MergeManyPeopleParams, body MergeManyPeopleJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyPeopleResponse, error) {
	rsp, err := c.MergeManyPeople(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyPeopleResponse(rsp)
}

// DeleteOnePersonWithResponse request returning *DeleteOnePersonResponse
func (c *ClientWithResponses) DeleteOnePersonWithResponse(ctx context.Context, id IdPath, params *DeleteOnePersonParams, reqEditors ...RequestEditorFn) (*DeleteOnePersonResponse, error) {
	rsp, err := c.DeleteOnePerson(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOnePersonResponse(rsp)
}

// FindOnePersonWithResponse request returning *FindOnePersonResponse
func (c *ClientWithResponses) FindOnePersonWithResponse(ctx context.Context, id IdPath, params *FindOnePersonParams, reqEditors ...RequestEditorFn) (*FindOnePersonResponse, error) {
	rsp, err := c.FindOnePerson(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOnePersonResponse(rsp)
}

// UpdateOnePersonWithBodyWithResponse request with arbitrary body returning *UpdateOnePersonResponse
func (c *ClientWithResponses) UpdateOnePersonWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOnePersonParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOnePersonResponse, error) {
	rsp, err := c.UpdateOnePersonWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOnePersonResponse(rsp)
}

func (c *ClientWithResponses) UpdateOnePersonWithResponse(ctx context.Context, id IdPath, params *UpdateOnePersonParams, body UpdateOnePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOnePersonResponse, error) {
	rsp, err := c.UpdateOnePerson(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOnePersonResponse(rsp)
}

// RestoreManyAttachmentsWithResponse request returning *RestoreManyAttachmentsResponse
func (c *ClientWithResponses) RestoreManyAttachmentsWithResponse(ctx context.Context, params *RestoreManyAttachmentsParams, reqEditors ...RequestEditorFn) (*RestoreManyAttachmentsResponse, error) {
	rsp, err := c.RestoreManyAttachments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyAttachmentsResponse(rsp)
}

// RestoreOneAttachmentWithResponse request returning *RestoreOneAttachmentResponse
func (c *ClientWithResponses) RestoreOneAttachmentWithResponse(ctx context.Context, id IdPath, params *RestoreOneAttachmentParams, reqEditors ...RequestEditorFn) (*RestoreOneAttachmentResponse, error) {
	rsp, err := c.RestoreOneAttachment(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneAttachmentResponse(rsp)
}

// RestoreManyBlocklistsWithResponse request returning *RestoreManyBlocklistsResponse
func (c *ClientWithResponses) RestoreManyBlocklistsWithResponse(ctx context.Context, params *RestoreManyBlocklistsParams, reqEditors ...RequestEditorFn) (*RestoreManyBlocklistsResponse, error) {
	rsp, err := c.RestoreManyBlocklists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyBlocklistsResponse(rsp)
}

// RestoreOneBlocklistWithResponse request returning *RestoreOneBlocklistResponse
func (c *ClientWithResponses) RestoreOneBlocklistWithResponse(ctx context.Context, id IdPath, params *RestoreOneBlocklistParams, reqEditors ...RequestEditorFn) (*RestoreOneBlocklistResponse, error) {
	rsp, err := c.RestoreOneBlocklist(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneBlocklistResponse(rsp)
}

// RestoreManyCalendarChannelEventAssociationsWithResponse request returning *RestoreManyCalendarChannelEventAssociationsResponse
func (c *ClientWithResponses) RestoreManyCalendarChannelEventAssociationsWithResponse(ctx context.Context, params *RestoreManyCalendarChannelEventAssociationsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarChannelEventAssociationsResponse, error) {
	rsp, err := c.RestoreManyCalendarChannelEventAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyCalendarChannelEventAssociationsResponse(rsp)
}

// RestoreOneCalendarChannelEventAssociationWithResponse request returning *RestoreOneCalendarChannelEventAssociationResponse
func (c *ClientWithResponses) RestoreOneCalendarChannelEventAssociationWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarChannelEventAssociationParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarChannelEventAssociationResponse, error) {
	rsp, err := c.RestoreOneCalendarChannelEventAssociation(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneCalendarChannelEventAssociationResponse(rsp)
}

// RestoreManyCalendarChannelsWithResponse request returning *RestoreManyCalendarChannelsResponse
func (c *ClientWithResponses) RestoreManyCalendarChannelsWithResponse(ctx context.Context, params *RestoreManyCalendarChannelsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarChannelsResponse, error) {
	rsp, err := c.RestoreManyCalendarChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyCalendarChannelsResponse(rsp)
}

// RestoreOneCalendarChannelWithResponse request returning *RestoreOneCalendarChannelResponse
func (c *ClientWithResponses) RestoreOneCalendarChannelWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarChannelParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarChannelResponse, error) {
	rsp, err := c.RestoreOneCalendarChannel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneCalendarChannelResponse(rsp)
}

// RestoreManyCalendarEventParticipantsWithResponse request returning *RestoreManyCalendarEventParticipantsResponse
func (c *ClientWithResponses) RestoreManyCalendarEventParticipantsWithResponse(ctx context.Context, params *RestoreManyCalendarEventParticipantsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarEventParticipantsResponse, error) {
	rsp, err := c.RestoreManyCalendarEventParticipants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyCalendarEventParticipantsResponse(rsp)
}

// RestoreOneCalendarEventParticipantWithResponse request returning *RestoreOneCalendarEventParticipantResponse
func (c *ClientWithResponses) RestoreOneCalendarEventParticipantWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarEventParticipantParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarEventParticipantResponse, error) {
	rsp, err := c.RestoreOneCalendarEventParticipant(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneCalendarEventParticipantResponse(rsp)
}

// RestoreManyCalendarEventsWithResponse request returning *RestoreManyCalendarEventsResponse
func (c *ClientWithResponses) RestoreManyCalendarEventsWithResponse(ctx context.Context, params *RestoreManyCalendarEventsParams, reqEditors ...RequestEditorFn) (*RestoreManyCalendarEventsResponse, error) {
	rsp, err := c.RestoreManyCalendarEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyCalendarEventsResponse(rsp)
}

// RestoreOneCalendarEventWithResponse request returning *RestoreOneCalendarEventResponse
func (c *ClientWithResponses) RestoreOneCalendarEventWithResponse(ctx context.Context, id IdPath, params *RestoreOneCalendarEventParams, reqEditors ...RequestEditorFn) (*RestoreOneCalendarEventResponse, error) {
	rsp, err := c.RestoreOneCalendarEvent(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneCalendarEventResponse(rsp)
}

// RestoreManyCompaniesWithResponse request returning *RestoreManyCompaniesResponse
func (c *ClientWithResponses) RestoreManyCompaniesWithResponse(ctx context.Context, params *RestoreManyCompaniesParams, reqEditors ...RequestEditorFn) (*RestoreManyCompaniesResponse, error) {
	rsp, err := c.RestoreManyCompanies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyCompaniesResponse(rsp)
}

// RestoreOneCompanyWithResponse request returning *RestoreOneCompanyResponse
func (c *ClientWithResponses) RestoreOneCompanyWithResponse(ctx context.Context, id IdPath, params *RestoreOneCompanyParams, reqEditors ...RequestEditorFn) (*RestoreOneCompanyResponse, error) {
	rsp, err := c.RestoreOneCompany(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneCompanyResponse(rsp)
}

// RestoreManyConnectedAccountsWithResponse request returning *RestoreManyConnectedAccountsResponse
func (c *ClientWithResponses) RestoreManyConnectedAccountsWithResponse(ctx context.Context, params *RestoreManyConnectedAccountsParams, reqEditors ...RequestEditorFn) (*RestoreManyConnectedAccountsResponse, error) {
	rsp, err := c.RestoreManyConnectedAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyConnectedAccountsResponse(rsp)
}

// RestoreOneConnectedAccountWithResponse request returning *RestoreOneConnectedAccountResponse
func (c *ClientWithResponses) RestoreOneConnectedAccountWithResponse(ctx context.Context, id IdPath, params *RestoreOneConnectedAccountParams, reqEditors ...RequestEditorFn) (*RestoreOneConnectedAccountResponse, error) {
	rsp, err := c.RestoreOneConnectedAccount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneConnectedAccountResponse(rsp)
}

// RestoreManyDashboardsWithResponse request returning *RestoreManyDashboardsResponse
func (c *ClientWithResponses) RestoreManyDashboardsWithResponse(ctx context.Context, params *RestoreManyDashboardsParams, reqEditors ...RequestEditorFn) (*RestoreManyDashboardsResponse, error) {
	rsp, err := c.RestoreManyDashboards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyDashboardsResponse(rsp)
}

// RestoreOneDashboardWithResponse request returning *RestoreOneDashboardResponse
func (c *ClientWithResponses) RestoreOneDashboardWithResponse(ctx context.Context, id IdPath, params *RestoreOneDashboardParams, reqEditors ...RequestEditorFn) (*RestoreOneDashboardResponse, error) {
	rsp, err := c.RestoreOneDashboard(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneDashboardResponse(rsp)
}

// RestoreManyFavoriteFoldersWithResponse request returning *RestoreManyFavoriteFoldersResponse
func (c *ClientWithResponses) RestoreManyFavoriteFoldersWithResponse(ctx context.Context, params *RestoreManyFavoriteFoldersParams, reqEditors ...RequestEditorFn) (*RestoreManyFavoriteFoldersResponse, error) {
	rsp, err := c.RestoreManyFavoriteFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyFavoriteFoldersResponse(rsp)
}

// RestoreOneFavoriteFolderWithResponse request returning *RestoreOneFavoriteFolderResponse
func (c *ClientWithResponses) RestoreOneFavoriteFolderWithResponse(ctx context.Context, id IdPath, params *RestoreOneFavoriteFolderParams, reqEditors ...RequestEditorFn) (*RestoreOneFavoriteFolderResponse, error) {
	rsp, err := c.RestoreOneFavoriteFolder(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneFavoriteFolderResponse(rsp)
}

// RestoreManyFavoritesWithResponse request returning *RestoreManyFavoritesResponse
func (c *ClientWithResponses) RestoreManyFavoritesWithResponse(ctx context.Context, params *RestoreManyFavoritesParams, reqEditors ...RequestEditorFn) (*RestoreManyFavoritesResponse, error) {
	rsp, err := c.RestoreManyFavorites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyFavoritesResponse(rsp)
}

// RestoreOneFavoriteWithResponse request returning *RestoreOneFavoriteResponse
func (c *ClientWithResponses) RestoreOneFavoriteWithResponse(ctx context.Context, id IdPath, params *RestoreOneFavoriteParams, reqEditors ...RequestEditorFn) (*RestoreOneFavoriteResponse, error) {
	rsp, err := c.RestoreOneFavorite(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneFavoriteResponse(rsp)
}

// RestoreManyMessageChannelMessageAssociationsWithResponse request returning *RestoreManyMessageChannelMessageAssociationsResponse
func (c *ClientWithResponses) RestoreManyMessageChannelMessageAssociationsWithResponse(ctx context.Context, params *RestoreManyMessageChannelMessageAssociationsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageChannelMessageAssociationsResponse, error) {
	rsp, err := c.RestoreManyMessageChannelMessageAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyMessageChannelMessageAssociationsResponse(rsp)
}

// RestoreOneMessageChannelMessageAssociationWithResponse request returning *RestoreOneMessageChannelMessageAssociationResponse
func (c *ClientWithResponses) RestoreOneMessageChannelMessageAssociationWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageChannelMessageAssociationParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageChannelMessageAssociationResponse, error) {
	rsp, err := c.RestoreOneMessageChannelMessageAssociation(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneMessageChannelMessageAssociationResponse(rsp)
}

// RestoreManyMessageChannelsWithResponse request returning *RestoreManyMessageChannelsResponse
func (c *ClientWithResponses) RestoreManyMessageChannelsWithResponse(ctx context.Context, params *RestoreManyMessageChannelsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageChannelsResponse, error) {
	rsp, err := c.RestoreManyMessageChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyMessageChannelsResponse(rsp)
}

// RestoreOneMessageChannelWithResponse request returning *RestoreOneMessageChannelResponse
func (c *ClientWithResponses) RestoreOneMessageChannelWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageChannelParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageChannelResponse, error) {
	rsp, err := c.RestoreOneMessageChannel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneMessageChannelResponse(rsp)
}

// RestoreManyMessageFoldersWithResponse request returning *RestoreManyMessageFoldersResponse
func (c *ClientWithResponses) RestoreManyMessageFoldersWithResponse(ctx context.Context, params *RestoreManyMessageFoldersParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageFoldersResponse, error) {
	rsp, err := c.RestoreManyMessageFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyMessageFoldersResponse(rsp)
}

// RestoreOneMessageFolderWithResponse request returning *RestoreOneMessageFolderResponse
func (c *ClientWithResponses) RestoreOneMessageFolderWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageFolderParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageFolderResponse, error) {
	rsp, err := c.RestoreOneMessageFolder(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneMessageFolderResponse(rsp)
}

// RestoreManyMessageParticipantsWithResponse request returning *RestoreManyMessageParticipantsResponse
func (c *ClientWithResponses) RestoreManyMessageParticipantsWithResponse(ctx context.Context, params *RestoreManyMessageParticipantsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageParticipantsResponse, error) {
	rsp, err := c.RestoreManyMessageParticipants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyMessageParticipantsResponse(rsp)
}

// RestoreOneMessageParticipantWithResponse request returning *RestoreOneMessageParticipantResponse
func (c *ClientWithResponses) RestoreOneMessageParticipantWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageParticipantParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageParticipantResponse, error) {
	rsp, err := c.RestoreOneMessageParticipant(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneMessageParticipantResponse(rsp)
}

// RestoreManyMessageThreadsWithResponse request returning *RestoreManyMessageThreadsResponse
func (c *ClientWithResponses) RestoreManyMessageThreadsWithResponse(ctx context.Context, params *RestoreManyMessageThreadsParams, reqEditors ...RequestEditorFn) (*RestoreManyMessageThreadsResponse, error) {
	rsp, err := c.RestoreManyMessageThreads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyMessageThreadsResponse(rsp)
}

// RestoreOneMessageThreadWithResponse request returning *RestoreOneMessageThreadResponse
func (c *ClientWithResponses) RestoreOneMessageThreadWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageThreadParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageThreadResponse, error) {
	rsp, err := c.RestoreOneMessageThread(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneMessageThreadResponse(rsp)
}

// RestoreManyMessagesWithResponse request returning *RestoreManyMessagesResponse
func (c *ClientWithResponses) RestoreManyMessagesWithResponse(ctx context.Context, params *RestoreManyMessagesParams, reqEditors ...RequestEditorFn) (*RestoreManyMessagesResponse, error) {
	rsp, err := c.RestoreManyMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyMessagesResponse(rsp)
}

// RestoreOneMessageWithResponse request returning *RestoreOneMessageResponse
func (c *ClientWithResponses) RestoreOneMessageWithResponse(ctx context.Context, id IdPath, params *RestoreOneMessageParams, reqEditors ...RequestEditorFn) (*RestoreOneMessageResponse, error) {
	rsp, err := c.RestoreOneMessage(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneMessageResponse(rsp)
}

// RestoreManyNoteTargetsWithResponse request returning *RestoreManyNoteTargetsResponse
func (c *ClientWithResponses) RestoreManyNoteTargetsWithResponse(ctx context.Context, params *RestoreManyNoteTargetsParams, reqEditors ...RequestEditorFn) (*RestoreManyNoteTargetsResponse, error) {
	rsp, err := c.RestoreManyNoteTargets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyNoteTargetsResponse(rsp)
}

// RestoreOneNoteTargetWithResponse request returning *RestoreOneNoteTargetResponse
func (c *ClientWithResponses) RestoreOneNoteTargetWithResponse(ctx context.Context, id IdPath, params *RestoreOneNoteTargetParams, reqEditors ...RequestEditorFn) (*RestoreOneNoteTargetResponse, error) {
	rsp, err := c.RestoreOneNoteTarget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneNoteTargetResponse(rsp)
}

// RestoreManyNotesWithResponse request returning *RestoreManyNotesResponse
func (c *ClientWithResponses) RestoreManyNotesWithResponse(ctx context.Context, params *RestoreManyNotesParams, reqEditors ...RequestEditorFn) (*RestoreManyNotesResponse, error) {
	rsp, err := c.RestoreManyNotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyNotesResponse(rsp)
}

// RestoreOneNoteWithResponse request returning *RestoreOneNoteResponse
func (c *ClientWithResponses) RestoreOneNoteWithResponse(ctx context.Context, id IdPath, params *RestoreOneNoteParams, reqEditors ...RequestEditorFn) (*RestoreOneNoteResponse, error) {
	rsp, err := c.RestoreOneNote(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneNoteResponse(rsp)
}

// RestoreManyOpportunitiesWithResponse request returning *RestoreManyOpportunitiesResponse
func (c *ClientWithResponses) RestoreManyOpportunitiesWithResponse(ctx context.Context, params *RestoreManyOpportunitiesParams, reqEditors ...RequestEditorFn) (*RestoreManyOpportunitiesResponse, error) {
	rsp, err := c.RestoreManyOpportunities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyOpportunitiesResponse(rsp)
}

// RestoreOneOpportunityWithResponse request returning *RestoreOneOpportunityResponse
func (c *ClientWithResponses) RestoreOneOpportunityWithResponse(ctx context.Context, id IdPath, params *RestoreOneOpportunityParams, reqEditors ...RequestEditorFn) (*RestoreOneOpportunityResponse, error) {
	rsp, err := c.RestoreOneOpportunity(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneOpportunityResponse(rsp)
}

// RestoreManyPeopleWithResponse request returning *RestoreManyPeopleResponse
func (c *ClientWithResponses) RestoreManyPeopleWithResponse(ctx context.Context, params *RestoreManyPeopleParams, reqEditors ...RequestEditorFn) (*RestoreManyPeopleResponse, error) {
	rsp, err := c.RestoreManyPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyPeopleResponse(rsp)
}

// RestoreOnePersonWithResponse request returning *RestoreOnePersonResponse
func (c *ClientWithResponses) RestoreOnePersonWithResponse(ctx context.Context, id IdPath, params *RestoreOnePersonParams, reqEditors ...RequestEditorFn) (*RestoreOnePersonResponse, error) {
	rsp, err := c.RestoreOnePerson(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOnePersonResponse(rsp)
}

// RestoreManyTaskTargetsWithResponse request returning *RestoreManyTaskTargetsResponse
func (c *ClientWithResponses) RestoreManyTaskTargetsWithResponse(ctx context.Context, params *RestoreManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*RestoreManyTaskTargetsResponse, error) {
	rsp, err := c.RestoreManyTaskTargets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyTaskTargetsResponse(rsp)
}

// RestoreOneTaskTargetWithResponse request returning *RestoreOneTaskTargetResponse
func (c *ClientWithResponses) RestoreOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *RestoreOneTaskTargetParams, reqEditors ...RequestEditorFn) (*RestoreOneTaskTargetResponse, error) {
	rsp, err := c.RestoreOneTaskTarget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneTaskTargetResponse(rsp)
}

// RestoreManyTasksWithResponse request returning *RestoreManyTasksResponse
func (c *ClientWithResponses) RestoreManyTasksWithResponse(ctx context.Context, params *RestoreManyTasksParams, reqEditors ...RequestEditorFn) (*RestoreManyTasksResponse, error) {
	rsp, err := c.RestoreManyTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyTasksResponse(rsp)
}

// RestoreOneTaskWithResponse request returning *RestoreOneTaskResponse
func (c *ClientWithResponses) RestoreOneTaskWithResponse(ctx context.Context, id IdPath, params *RestoreOneTaskParams, reqEditors ...RequestEditorFn) (*RestoreOneTaskResponse, error) {
	rsp, err := c.RestoreOneTask(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneTaskResponse(rsp)
}

// RestoreManyTimelineActivitiesWithResponse request returning *RestoreManyTimelineActivitiesResponse
func (c *ClientWithResponses) RestoreManyTimelineActivitiesWithResponse(ctx context.Context, params *RestoreManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*RestoreManyTimelineActivitiesResponse, error) {
	rsp, err := c.RestoreManyTimelineActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyTimelineActivitiesResponse(rsp)
}

// RestoreOneTimelineActivityWithResponse request returning *RestoreOneTimelineActivityResponse
func (c *ClientWithResponses) RestoreOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *RestoreOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*RestoreOneTimelineActivityResponse, error) {
	rsp, err := c.RestoreOneTimelineActivity(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneTimelineActivityResponse(rsp)
}

// RestoreManyWorkflowAutomatedTriggersWithResponse request returning *RestoreManyWorkflowAutomatedTriggersResponse
func (c *ClientWithResponses) RestoreManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *RestoreManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.RestoreManyWorkflowAutomatedTriggers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyWorkflowAutomatedTriggersResponse(rsp)
}

// RestoreOneWorkflowAutomatedTriggerWithResponse request returning *RestoreOneWorkflowAutomatedTriggerResponse
func (c *ClientWithResponses) RestoreOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowAutomatedTriggerResponse, error) {
	rsp, err := c.RestoreOneWorkflowAutomatedTrigger(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneWorkflowAutomatedTriggerResponse(rsp)
}

// RestoreManyWorkflowRunsWithResponse request returning *RestoreManyWorkflowRunsResponse
func (c *ClientWithResponses) RestoreManyWorkflowRunsWithResponse(ctx context.Context, params *RestoreManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowRunsResponse, error) {
	rsp, err := c.RestoreManyWorkflowRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyWorkflowRunsResponse(rsp)
}

// RestoreOneWorkflowRunWithResponse request returning *RestoreOneWorkflowRunResponse
func (c *ClientWithResponses) RestoreOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowRunResponse, error) {
	rsp, err := c.RestoreOneWorkflowRun(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneWorkflowRunResponse(rsp)
}

// RestoreManyWorkflowVersionsWithResponse request returning *RestoreManyWorkflowVersionsResponse
func (c *ClientWithResponses) RestoreManyWorkflowVersionsWithResponse(ctx context.Context, params *RestoreManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowVersionsResponse, error) {
	rsp, err := c.RestoreManyWorkflowVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyWorkflowVersionsResponse(rsp)
}

// RestoreOneWorkflowVersionWithResponse request returning *RestoreOneWorkflowVersionResponse
func (c *ClientWithResponses) RestoreOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowVersionResponse, error) {
	rsp, err := c.RestoreOneWorkflowVersion(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneWorkflowVersionResponse(rsp)
}

// RestoreManyWorkflowsWithResponse request returning *RestoreManyWorkflowsResponse
func (c *ClientWithResponses) RestoreManyWorkflowsWithResponse(ctx context.Context, params *RestoreManyWorkflowsParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkflowsResponse, error) {
	rsp, err := c.RestoreManyWorkflows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyWorkflowsResponse(rsp)
}

// RestoreOneWorkflowWithResponse request returning *RestoreOneWorkflowResponse
func (c *ClientWithResponses) RestoreOneWorkflowWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkflowParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkflowResponse, error) {
	rsp, err := c.RestoreOneWorkflow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneWorkflowResponse(rsp)
}

// RestoreManyWorkspaceMembersWithResponse request returning *RestoreManyWorkspaceMembersResponse
func (c *ClientWithResponses) RestoreManyWorkspaceMembersWithResponse(ctx context.Context, params *RestoreManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*RestoreManyWorkspaceMembersResponse, error) {
	rsp, err := c.RestoreManyWorkspaceMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreManyWorkspaceMembersResponse(rsp)
}

// RestoreOneWorkspaceMemberWithResponse request returning *RestoreOneWorkspaceMemberResponse
func (c *ClientWithResponses) RestoreOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *RestoreOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*RestoreOneWorkspaceMemberResponse, error) {
	rsp, err := c.RestoreOneWorkspaceMember(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreOneWorkspaceMemberResponse(rsp)
}

// DeleteManyTaskTargetsWithResponse request returning *DeleteManyTaskTargetsResponse
func (c *ClientWithResponses) DeleteManyTaskTargetsWithResponse(ctx context.Context, params *DeleteManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*DeleteManyTaskTargetsResponse, error) {
	rsp, err := c.DeleteManyTaskTargets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyTaskTargetsResponse(rsp)
}

// FindManyTaskTargetsWithResponse request returning *FindManyTaskTargetsResponse
func (c *ClientWithResponses) FindManyTaskTargetsWithResponse(ctx context.Context, params *FindManyTaskTargetsParams, reqEditors ...RequestEditorFn) (*FindManyTaskTargetsResponse, error) {
	rsp, err := c.FindManyTaskTargets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyTaskTargetsResponse(rsp)
}

// UpdateManyTaskTargetsWithBodyWithResponse request with arbitrary body returning *UpdateManyTaskTargetsResponse
func (c *ClientWithResponses) UpdateManyTaskTargetsWithBodyWithResponse(ctx context.Context, params *UpdateManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyTaskTargetsResponse, error) {
	rsp, err := c.UpdateManyTaskTargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyTaskTargetsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyTaskTargetsWithResponse(ctx context.Context, params *UpdateManyTaskTargetsParams, body UpdateManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyTaskTargetsResponse, error) {
	rsp, err := c.UpdateManyTaskTargets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyTaskTargetsResponse(rsp)
}

// CreateOneTaskTargetWithBodyWithResponse request with arbitrary body returning *CreateOneTaskTargetResponse
func (c *ClientWithResponses) CreateOneTaskTargetWithBodyWithResponse(ctx context.Context, params *CreateOneTaskTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneTaskTargetResponse, error) {
	rsp, err := c.CreateOneTaskTargetWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneTaskTargetResponse(rsp)
}

func (c *ClientWithResponses) CreateOneTaskTargetWithResponse(ctx context.Context, params *CreateOneTaskTargetParams, body CreateOneTaskTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneTaskTargetResponse, error) {
	rsp, err := c.CreateOneTaskTarget(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneTaskTargetResponse(rsp)
}

// FindTaskTargetDuplicatesWithBodyWithResponse request with arbitrary body returning *FindTaskTargetDuplicatesResponse
func (c *ClientWithResponses) FindTaskTargetDuplicatesWithBodyWithResponse(ctx context.Context, params *FindTaskTargetDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTaskTargetDuplicatesResponse, error) {
	rsp, err := c.FindTaskTargetDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTaskTargetDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindTaskTargetDuplicatesWithResponse(ctx context.Context, params *FindTaskTargetDuplicatesParams, body FindTaskTargetDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTaskTargetDuplicatesResponse, error) {
	rsp, err := c.FindTaskTargetDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTaskTargetDuplicatesResponse(rsp)
}

// MergeManyTaskTargetsWithBodyWithResponse request with arbitrary body returning *MergeManyTaskTargetsResponse
func (c *ClientWithResponses) MergeManyTaskTargetsWithBodyWithResponse(ctx context.Context, params *MergeManyTaskTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyTaskTargetsResponse, error) {
	rsp, err := c.MergeManyTaskTargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyTaskTargetsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyTaskTargetsWithResponse(ctx context.Context, params *MergeManyTaskTargetsParams, body MergeManyTaskTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyTaskTargetsResponse, error) {
	rsp, err := c.MergeManyTaskTargets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyTaskTargetsResponse(rsp)
}

// DeleteOneTaskTargetWithResponse request returning *DeleteOneTaskTargetResponse
func (c *ClientWithResponses) DeleteOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *DeleteOneTaskTargetParams, reqEditors ...RequestEditorFn) (*DeleteOneTaskTargetResponse, error) {
	rsp, err := c.DeleteOneTaskTarget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneTaskTargetResponse(rsp)
}

// FindOneTaskTargetWithResponse request returning *FindOneTaskTargetResponse
func (c *ClientWithResponses) FindOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *FindOneTaskTargetParams, reqEditors ...RequestEditorFn) (*FindOneTaskTargetResponse, error) {
	rsp, err := c.FindOneTaskTarget(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneTaskTargetResponse(rsp)
}

// UpdateOneTaskTargetWithBodyWithResponse request with arbitrary body returning *UpdateOneTaskTargetResponse
func (c *ClientWithResponses) UpdateOneTaskTargetWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskTargetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneTaskTargetResponse, error) {
	rsp, err := c.UpdateOneTaskTargetWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneTaskTargetResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneTaskTargetWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskTargetParams, body UpdateOneTaskTargetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneTaskTargetResponse, error) {
	rsp, err := c.UpdateOneTaskTarget(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneTaskTargetResponse(rsp)
}

// DeleteManyTasksWithResponse request returning *DeleteManyTasksResponse
func (c *ClientWithResponses) DeleteManyTasksWithResponse(ctx context.Context, params *DeleteManyTasksParams, reqEditors ...RequestEditorFn) (*DeleteManyTasksResponse, error) {
	rsp, err := c.DeleteManyTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyTasksResponse(rsp)
}

// FindManyTasksWithResponse request returning *FindManyTasksResponse
func (c *ClientWithResponses) FindManyTasksWithResponse(ctx context.Context, params *FindManyTasksParams, reqEditors ...RequestEditorFn) (*FindManyTasksResponse, error) {
	rsp, err := c.FindManyTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyTasksResponse(rsp)
}

// UpdateManyTasksWithBodyWithResponse request with arbitrary body returning *UpdateManyTasksResponse
func (c *ClientWithResponses) UpdateManyTasksWithBodyWithResponse(ctx context.Context, params *UpdateManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyTasksResponse, error) {
	rsp, err := c.UpdateManyTasksWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyTasksResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyTasksWithResponse(ctx context.Context, params *UpdateManyTasksParams, body UpdateManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyTasksResponse, error) {
	rsp, err := c.UpdateManyTasks(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyTasksResponse(rsp)
}

// CreateOneTaskWithBodyWithResponse request with arbitrary body returning *CreateOneTaskResponse
func (c *ClientWithResponses) CreateOneTaskWithBodyWithResponse(ctx context.Context, params *CreateOneTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneTaskResponse, error) {
	rsp, err := c.CreateOneTaskWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneTaskResponse(rsp)
}

func (c *ClientWithResponses) CreateOneTaskWithResponse(ctx context.Context, params *CreateOneTaskParams, body CreateOneTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneTaskResponse, error) {
	rsp, err := c.CreateOneTask(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneTaskResponse(rsp)
}

// FindTaskDuplicatesWithBodyWithResponse request with arbitrary body returning *FindTaskDuplicatesResponse
func (c *ClientWithResponses) FindTaskDuplicatesWithBodyWithResponse(ctx context.Context, params *FindTaskDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTaskDuplicatesResponse, error) {
	rsp, err := c.FindTaskDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTaskDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindTaskDuplicatesWithResponse(ctx context.Context, params *FindTaskDuplicatesParams, body FindTaskDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTaskDuplicatesResponse, error) {
	rsp, err := c.FindTaskDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTaskDuplicatesResponse(rsp)
}

// MergeManyTasksWithBodyWithResponse request with arbitrary body returning *MergeManyTasksResponse
func (c *ClientWithResponses) MergeManyTasksWithBodyWithResponse(ctx context.Context, params *MergeManyTasksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyTasksResponse, error) {
	rsp, err := c.MergeManyTasksWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyTasksResponse(rsp)
}

func (c *ClientWithResponses) MergeManyTasksWithResponse(ctx context.Context, params *MergeManyTasksParams, body MergeManyTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyTasksResponse, error) {
	rsp, err := c.MergeManyTasks(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyTasksResponse(rsp)
}

// DeleteOneTaskWithResponse request returning *DeleteOneTaskResponse
func (c *ClientWithResponses) DeleteOneTaskWithResponse(ctx context.Context, id IdPath, params *DeleteOneTaskParams, reqEditors ...RequestEditorFn) (*DeleteOneTaskResponse, error) {
	rsp, err := c.DeleteOneTask(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneTaskResponse(rsp)
}

// FindOneTaskWithResponse request returning *FindOneTaskResponse
func (c *ClientWithResponses) FindOneTaskWithResponse(ctx context.Context, id IdPath, params *FindOneTaskParams, reqEditors ...RequestEditorFn) (*FindOneTaskResponse, error) {
	rsp, err := c.FindOneTask(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneTaskResponse(rsp)
}

// UpdateOneTaskWithBodyWithResponse request with arbitrary body returning *UpdateOneTaskResponse
func (c *ClientWithResponses) UpdateOneTaskWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneTaskResponse, error) {
	rsp, err := c.UpdateOneTaskWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneTaskWithResponse(ctx context.Context, id IdPath, params *UpdateOneTaskParams, body UpdateOneTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneTaskResponse, error) {
	rsp, err := c.UpdateOneTask(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneTaskResponse(rsp)
}

// DeleteManyTimelineActivitiesWithResponse request returning *DeleteManyTimelineActivitiesResponse
func (c *ClientWithResponses) DeleteManyTimelineActivitiesWithResponse(ctx context.Context, params *DeleteManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*DeleteManyTimelineActivitiesResponse, error) {
	rsp, err := c.DeleteManyTimelineActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyTimelineActivitiesResponse(rsp)
}

// FindManyTimelineActivitiesWithResponse request returning *FindManyTimelineActivitiesResponse
func (c *ClientWithResponses) FindManyTimelineActivitiesWithResponse(ctx context.Context, params *FindManyTimelineActivitiesParams, reqEditors ...RequestEditorFn) (*FindManyTimelineActivitiesResponse, error) {
	rsp, err := c.FindManyTimelineActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyTimelineActivitiesResponse(rsp)
}

// UpdateManyTimelineActivitiesWithBodyWithResponse request with arbitrary body returning *UpdateManyTimelineActivitiesResponse
func (c *ClientWithResponses) UpdateManyTimelineActivitiesWithBodyWithResponse(ctx context.Context, params *UpdateManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyTimelineActivitiesResponse, error) {
	rsp, err := c.UpdateManyTimelineActivitiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyTimelineActivitiesResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyTimelineActivitiesWithResponse(ctx context.Context, params *UpdateManyTimelineActivitiesParams, body UpdateManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyTimelineActivitiesResponse, error) {
	rsp, err := c.UpdateManyTimelineActivities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyTimelineActivitiesResponse(rsp)
}

// CreateOneTimelineActivityWithBodyWithResponse request with arbitrary body returning *CreateOneTimelineActivityResponse
func (c *ClientWithResponses) CreateOneTimelineActivityWithBodyWithResponse(ctx context.Context, params *CreateOneTimelineActivityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneTimelineActivityResponse, error) {
	rsp, err := c.CreateOneTimelineActivityWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneTimelineActivityResponse(rsp)
}

func (c *ClientWithResponses) CreateOneTimelineActivityWithResponse(ctx context.Context, params *CreateOneTimelineActivityParams, body CreateOneTimelineActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneTimelineActivityResponse, error) {
	rsp, err := c.CreateOneTimelineActivity(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneTimelineActivityResponse(rsp)
}

// FindTimelineActivityDuplicatesWithBodyWithResponse request with arbitrary body returning *FindTimelineActivityDuplicatesResponse
func (c *ClientWithResponses) FindTimelineActivityDuplicatesWithBodyWithResponse(ctx context.Context, params *FindTimelineActivityDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTimelineActivityDuplicatesResponse, error) {
	rsp, err := c.FindTimelineActivityDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTimelineActivityDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindTimelineActivityDuplicatesWithResponse(ctx context.Context, params *FindTimelineActivityDuplicatesParams, body FindTimelineActivityDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTimelineActivityDuplicatesResponse, error) {
	rsp, err := c.FindTimelineActivityDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTimelineActivityDuplicatesResponse(rsp)
}

// MergeManyTimelineActivitiesWithBodyWithResponse request with arbitrary body returning *MergeManyTimelineActivitiesResponse
func (c *ClientWithResponses) MergeManyTimelineActivitiesWithBodyWithResponse(ctx context.Context, params *MergeManyTimelineActivitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyTimelineActivitiesResponse, error) {
	rsp, err := c.MergeManyTimelineActivitiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyTimelineActivitiesResponse(rsp)
}

func (c *ClientWithResponses) MergeManyTimelineActivitiesWithResponse(ctx context.Context, params *MergeManyTimelineActivitiesParams, body MergeManyTimelineActivitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyTimelineActivitiesResponse, error) {
	rsp, err := c.MergeManyTimelineActivities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyTimelineActivitiesResponse(rsp)
}

// DeleteOneTimelineActivityWithResponse request returning *DeleteOneTimelineActivityResponse
func (c *ClientWithResponses) DeleteOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *DeleteOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*DeleteOneTimelineActivityResponse, error) {
	rsp, err := c.DeleteOneTimelineActivity(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneTimelineActivityResponse(rsp)
}

// FindOneTimelineActivityWithResponse request returning *FindOneTimelineActivityResponse
func (c *ClientWithResponses) FindOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *FindOneTimelineActivityParams, reqEditors ...RequestEditorFn) (*FindOneTimelineActivityResponse, error) {
	rsp, err := c.FindOneTimelineActivity(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneTimelineActivityResponse(rsp)
}

// UpdateOneTimelineActivityWithBodyWithResponse request with arbitrary body returning *UpdateOneTimelineActivityResponse
func (c *ClientWithResponses) UpdateOneTimelineActivityWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneTimelineActivityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneTimelineActivityResponse, error) {
	rsp, err := c.UpdateOneTimelineActivityWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneTimelineActivityResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneTimelineActivityWithResponse(ctx context.Context, id IdPath, params *UpdateOneTimelineActivityParams, body UpdateOneTimelineActivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneTimelineActivityResponse, error) {
	rsp, err := c.UpdateOneTimelineActivity(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneTimelineActivityResponse(rsp)
}

// DeleteManyWorkflowAutomatedTriggersWithResponse request returning *DeleteManyWorkflowAutomatedTriggersResponse
func (c *ClientWithResponses) DeleteManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *DeleteManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.DeleteManyWorkflowAutomatedTriggers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyWorkflowAutomatedTriggersResponse(rsp)
}

// FindManyWorkflowAutomatedTriggersWithResponse request returning *FindManyWorkflowAutomatedTriggersResponse
func (c *ClientWithResponses) FindManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *FindManyWorkflowAutomatedTriggersParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.FindManyWorkflowAutomatedTriggers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyWorkflowAutomatedTriggersResponse(rsp)
}

// UpdateManyWorkflowAutomatedTriggersWithBodyWithResponse request with arbitrary body returning *UpdateManyWorkflowAutomatedTriggersResponse
func (c *ClientWithResponses) UpdateManyWorkflowAutomatedTriggersWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.UpdateManyWorkflowAutomatedTriggersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowAutomatedTriggersResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *UpdateManyWorkflowAutomatedTriggersParams, body UpdateManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.UpdateManyWorkflowAutomatedTriggers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowAutomatedTriggersResponse(rsp)
}

// CreateOneWorkflowAutomatedTriggerWithBodyWithResponse request with arbitrary body returning *CreateOneWorkflowAutomatedTriggerResponse
func (c *ClientWithResponses) CreateOneWorkflowAutomatedTriggerWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowAutomatedTriggerResponse, error) {
	rsp, err := c.CreateOneWorkflowAutomatedTriggerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowAutomatedTriggerResponse(rsp)
}

func (c *ClientWithResponses) CreateOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, params *CreateOneWorkflowAutomatedTriggerParams, body CreateOneWorkflowAutomatedTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowAutomatedTriggerResponse, error) {
	rsp, err := c.CreateOneWorkflowAutomatedTrigger(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowAutomatedTriggerResponse(rsp)
}

// FindWorkflowAutomatedTriggerDuplicatesWithBodyWithResponse request with arbitrary body returning *FindWorkflowAutomatedTriggerDuplicatesResponse
func (c *ClientWithResponses) FindWorkflowAutomatedTriggerDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowAutomatedTriggerDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowAutomatedTriggerDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowAutomatedTriggerDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowAutomatedTriggerDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindWorkflowAutomatedTriggerDuplicatesWithResponse(ctx context.Context, params *FindWorkflowAutomatedTriggerDuplicatesParams, body FindWorkflowAutomatedTriggerDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowAutomatedTriggerDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowAutomatedTriggerDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowAutomatedTriggerDuplicatesResponse(rsp)
}

// MergeManyWorkflowAutomatedTriggersWithBodyWithResponse request with arbitrary body returning *MergeManyWorkflowAutomatedTriggersResponse
func (c *ClientWithResponses) MergeManyWorkflowAutomatedTriggersWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowAutomatedTriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.MergeManyWorkflowAutomatedTriggersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowAutomatedTriggersResponse(rsp)
}

func (c *ClientWithResponses) MergeManyWorkflowAutomatedTriggersWithResponse(ctx context.Context, params *MergeManyWorkflowAutomatedTriggersParams, body MergeManyWorkflowAutomatedTriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowAutomatedTriggersResponse, error) {
	rsp, err := c.MergeManyWorkflowAutomatedTriggers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowAutomatedTriggersResponse(rsp)
}

// DeleteOneWorkflowAutomatedTriggerWithResponse request returning *DeleteOneWorkflowAutomatedTriggerResponse
func (c *ClientWithResponses) DeleteOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowAutomatedTriggerResponse, error) {
	rsp, err := c.DeleteOneWorkflowAutomatedTrigger(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneWorkflowAutomatedTriggerResponse(rsp)
}

// FindOneWorkflowAutomatedTriggerWithResponse request returning *FindOneWorkflowAutomatedTriggerResponse
func (c *ClientWithResponses) FindOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowAutomatedTriggerParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowAutomatedTriggerResponse, error) {
	rsp, err := c.FindOneWorkflowAutomatedTrigger(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneWorkflowAutomatedTriggerResponse(rsp)
}

// UpdateOneWorkflowAutomatedTriggerWithBodyWithResponse request with arbitrary body returning *UpdateOneWorkflowAutomatedTriggerResponse
func (c *ClientWithResponses) UpdateOneWorkflowAutomatedTriggerWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowAutomatedTriggerResponse, error) {
	rsp, err := c.UpdateOneWorkflowAutomatedTriggerWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowAutomatedTriggerResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneWorkflowAutomatedTriggerWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowAutomatedTriggerParams, body UpdateOneWorkflowAutomatedTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowAutomatedTriggerResponse, error) {
	rsp, err := c.UpdateOneWorkflowAutomatedTrigger(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowAutomatedTriggerResponse(rsp)
}

// DeleteManyWorkflowRunsWithResponse request returning *DeleteManyWorkflowRunsResponse
func (c *ClientWithResponses) DeleteManyWorkflowRunsWithResponse(ctx context.Context, params *DeleteManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowRunsResponse, error) {
	rsp, err := c.DeleteManyWorkflowRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyWorkflowRunsResponse(rsp)
}

// FindManyWorkflowRunsWithResponse request returning *FindManyWorkflowRunsResponse
func (c *ClientWithResponses) FindManyWorkflowRunsWithResponse(ctx context.Context, params *FindManyWorkflowRunsParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowRunsResponse, error) {
	rsp, err := c.FindManyWorkflowRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyWorkflowRunsResponse(rsp)
}

// UpdateManyWorkflowRunsWithBodyWithResponse request with arbitrary body returning *UpdateManyWorkflowRunsResponse
func (c *ClientWithResponses) UpdateManyWorkflowRunsWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowRunsResponse, error) {
	rsp, err := c.UpdateManyWorkflowRunsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowRunsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyWorkflowRunsWithResponse(ctx context.Context, params *UpdateManyWorkflowRunsParams, body UpdateManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowRunsResponse, error) {
	rsp, err := c.UpdateManyWorkflowRuns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowRunsResponse(rsp)
}

// CreateOneWorkflowRunWithBodyWithResponse request with arbitrary body returning *CreateOneWorkflowRunResponse
func (c *ClientWithResponses) CreateOneWorkflowRunWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowRunResponse, error) {
	rsp, err := c.CreateOneWorkflowRunWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowRunResponse(rsp)
}

func (c *ClientWithResponses) CreateOneWorkflowRunWithResponse(ctx context.Context, params *CreateOneWorkflowRunParams, body CreateOneWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowRunResponse, error) {
	rsp, err := c.CreateOneWorkflowRun(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowRunResponse(rsp)
}

// FindWorkflowRunDuplicatesWithBodyWithResponse request with arbitrary body returning *FindWorkflowRunDuplicatesResponse
func (c *ClientWithResponses) FindWorkflowRunDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowRunDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowRunDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowRunDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowRunDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindWorkflowRunDuplicatesWithResponse(ctx context.Context, params *FindWorkflowRunDuplicatesParams, body FindWorkflowRunDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowRunDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowRunDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowRunDuplicatesResponse(rsp)
}

// MergeManyWorkflowRunsWithBodyWithResponse request with arbitrary body returning *MergeManyWorkflowRunsResponse
func (c *ClientWithResponses) MergeManyWorkflowRunsWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowRunsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowRunsResponse, error) {
	rsp, err := c.MergeManyWorkflowRunsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowRunsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyWorkflowRunsWithResponse(ctx context.Context, params *MergeManyWorkflowRunsParams, body MergeManyWorkflowRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowRunsResponse, error) {
	rsp, err := c.MergeManyWorkflowRuns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowRunsResponse(rsp)
}

// DeleteOneWorkflowRunWithResponse request returning *DeleteOneWorkflowRunResponse
func (c *ClientWithResponses) DeleteOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowRunResponse, error) {
	rsp, err := c.DeleteOneWorkflowRun(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneWorkflowRunResponse(rsp)
}

// FindOneWorkflowRunWithResponse request returning *FindOneWorkflowRunResponse
func (c *ClientWithResponses) FindOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowRunParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowRunResponse, error) {
	rsp, err := c.FindOneWorkflowRun(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneWorkflowRunResponse(rsp)
}

// UpdateOneWorkflowRunWithBodyWithResponse request with arbitrary body returning *UpdateOneWorkflowRunResponse
func (c *ClientWithResponses) UpdateOneWorkflowRunWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowRunResponse, error) {
	rsp, err := c.UpdateOneWorkflowRunWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowRunResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneWorkflowRunWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowRunParams, body UpdateOneWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowRunResponse, error) {
	rsp, err := c.UpdateOneWorkflowRun(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowRunResponse(rsp)
}

// DeleteManyWorkflowVersionsWithResponse request returning *DeleteManyWorkflowVersionsResponse
func (c *ClientWithResponses) DeleteManyWorkflowVersionsWithResponse(ctx context.Context, params *DeleteManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowVersionsResponse, error) {
	rsp, err := c.DeleteManyWorkflowVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyWorkflowVersionsResponse(rsp)
}

// FindManyWorkflowVersionsWithResponse request returning *FindManyWorkflowVersionsResponse
func (c *ClientWithResponses) FindManyWorkflowVersionsWithResponse(ctx context.Context, params *FindManyWorkflowVersionsParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowVersionsResponse, error) {
	rsp, err := c.FindManyWorkflowVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyWorkflowVersionsResponse(rsp)
}

// UpdateManyWorkflowVersionsWithBodyWithResponse request with arbitrary body returning *UpdateManyWorkflowVersionsResponse
func (c *ClientWithResponses) UpdateManyWorkflowVersionsWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowVersionsResponse, error) {
	rsp, err := c.UpdateManyWorkflowVersionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowVersionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyWorkflowVersionsWithResponse(ctx context.Context, params *UpdateManyWorkflowVersionsParams, body UpdateManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowVersionsResponse, error) {
	rsp, err := c.UpdateManyWorkflowVersions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowVersionsResponse(rsp)
}

// CreateOneWorkflowVersionWithBodyWithResponse request with arbitrary body returning *CreateOneWorkflowVersionResponse
func (c *ClientWithResponses) CreateOneWorkflowVersionWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowVersionResponse, error) {
	rsp, err := c.CreateOneWorkflowVersionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowVersionResponse(rsp)
}

func (c *ClientWithResponses) CreateOneWorkflowVersionWithResponse(ctx context.Context, params *CreateOneWorkflowVersionParams, body CreateOneWorkflowVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowVersionResponse, error) {
	rsp, err := c.CreateOneWorkflowVersion(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowVersionResponse(rsp)
}

// FindWorkflowVersionDuplicatesWithBodyWithResponse request with arbitrary body returning *FindWorkflowVersionDuplicatesResponse
func (c *ClientWithResponses) FindWorkflowVersionDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowVersionDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowVersionDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowVersionDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowVersionDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindWorkflowVersionDuplicatesWithResponse(ctx context.Context, params *FindWorkflowVersionDuplicatesParams, body FindWorkflowVersionDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowVersionDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowVersionDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowVersionDuplicatesResponse(rsp)
}

// MergeManyWorkflowVersionsWithBodyWithResponse request with arbitrary body returning *MergeManyWorkflowVersionsResponse
func (c *ClientWithResponses) MergeManyWorkflowVersionsWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowVersionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowVersionsResponse, error) {
	rsp, err := c.MergeManyWorkflowVersionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowVersionsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyWorkflowVersionsWithResponse(ctx context.Context, params *MergeManyWorkflowVersionsParams, body MergeManyWorkflowVersionsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowVersionsResponse, error) {
	rsp, err := c.MergeManyWorkflowVersions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowVersionsResponse(rsp)
}

// DeleteOneWorkflowVersionWithResponse request returning *DeleteOneWorkflowVersionResponse
func (c *ClientWithResponses) DeleteOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowVersionResponse, error) {
	rsp, err := c.DeleteOneWorkflowVersion(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneWorkflowVersionResponse(rsp)
}

// FindOneWorkflowVersionWithResponse request returning *FindOneWorkflowVersionResponse
func (c *ClientWithResponses) FindOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowVersionParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowVersionResponse, error) {
	rsp, err := c.FindOneWorkflowVersion(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneWorkflowVersionResponse(rsp)
}

// UpdateOneWorkflowVersionWithBodyWithResponse request with arbitrary body returning *UpdateOneWorkflowVersionResponse
func (c *ClientWithResponses) UpdateOneWorkflowVersionWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowVersionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowVersionResponse, error) {
	rsp, err := c.UpdateOneWorkflowVersionWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowVersionResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneWorkflowVersionWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowVersionParams, body UpdateOneWorkflowVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowVersionResponse, error) {
	rsp, err := c.UpdateOneWorkflowVersion(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowVersionResponse(rsp)
}

// DeleteManyWorkflowsWithResponse request returning *DeleteManyWorkflowsResponse
func (c *ClientWithResponses) DeleteManyWorkflowsWithResponse(ctx context.Context, params *DeleteManyWorkflowsParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkflowsResponse, error) {
	rsp, err := c.DeleteManyWorkflows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyWorkflowsResponse(rsp)
}

// FindManyWorkflowsWithResponse request returning *FindManyWorkflowsResponse
func (c *ClientWithResponses) FindManyWorkflowsWithResponse(ctx context.Context, params *FindManyWorkflowsParams, reqEditors ...RequestEditorFn) (*FindManyWorkflowsResponse, error) {
	rsp, err := c.FindManyWorkflows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyWorkflowsResponse(rsp)
}

// UpdateManyWorkflowsWithBodyWithResponse request with arbitrary body returning *UpdateManyWorkflowsResponse
func (c *ClientWithResponses) UpdateManyWorkflowsWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowsResponse, error) {
	rsp, err := c.UpdateManyWorkflowsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowsResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyWorkflowsWithResponse(ctx context.Context, params *UpdateManyWorkflowsParams, body UpdateManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkflowsResponse, error) {
	rsp, err := c.UpdateManyWorkflows(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkflowsResponse(rsp)
}

// CreateOneWorkflowWithBodyWithResponse request with arbitrary body returning *CreateOneWorkflowResponse
func (c *ClientWithResponses) CreateOneWorkflowWithBodyWithResponse(ctx context.Context, params *CreateOneWorkflowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkflowResponse, error) {
	rsp, err := c.CreateOneWorkflowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowResponse(rsp)
}

func (c *ClientWithResponses) CreateOneWorkflowWithResponse(ctx context.Context, params *CreateOneWorkflowParams, body CreateOneWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkflowResponse, error) {
	rsp, err := c.CreateOneWorkflow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkflowResponse(rsp)
}

// FindWorkflowDuplicatesWithBodyWithResponse request with arbitrary body returning *FindWorkflowDuplicatesResponse
func (c *ClientWithResponses) FindWorkflowDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkflowDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkflowDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindWorkflowDuplicatesWithResponse(ctx context.Context, params *FindWorkflowDuplicatesParams, body FindWorkflowDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkflowDuplicatesResponse, error) {
	rsp, err := c.FindWorkflowDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkflowDuplicatesResponse(rsp)
}

// MergeManyWorkflowsWithBodyWithResponse request with arbitrary body returning *MergeManyWorkflowsResponse
func (c *ClientWithResponses) MergeManyWorkflowsWithBodyWithResponse(ctx context.Context, params *MergeManyWorkflowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkflowsResponse, error) {
	rsp, err := c.MergeManyWorkflowsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowsResponse(rsp)
}

func (c *ClientWithResponses) MergeManyWorkflowsWithResponse(ctx context.Context, params *MergeManyWorkflowsParams, body MergeManyWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkflowsResponse, error) {
	rsp, err := c.MergeManyWorkflows(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkflowsResponse(rsp)
}

// DeleteOneWorkflowWithResponse request returning *DeleteOneWorkflowResponse
func (c *ClientWithResponses) DeleteOneWorkflowWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkflowParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkflowResponse, error) {
	rsp, err := c.DeleteOneWorkflow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneWorkflowResponse(rsp)
}

// FindOneWorkflowWithResponse request returning *FindOneWorkflowResponse
func (c *ClientWithResponses) FindOneWorkflowWithResponse(ctx context.Context, id IdPath, params *FindOneWorkflowParams, reqEditors ...RequestEditorFn) (*FindOneWorkflowResponse, error) {
	rsp, err := c.FindOneWorkflow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneWorkflowResponse(rsp)
}

// UpdateOneWorkflowWithBodyWithResponse request with arbitrary body returning *UpdateOneWorkflowResponse
func (c *ClientWithResponses) UpdateOneWorkflowWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowResponse, error) {
	rsp, err := c.UpdateOneWorkflowWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneWorkflowWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkflowParams, body UpdateOneWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkflowResponse, error) {
	rsp, err := c.UpdateOneWorkflow(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkflowResponse(rsp)
}

// DeleteManyWorkspaceMembersWithResponse request returning *DeleteManyWorkspaceMembersResponse
func (c *ClientWithResponses) DeleteManyWorkspaceMembersWithResponse(ctx context.Context, params *DeleteManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*DeleteManyWorkspaceMembersResponse, error) {
	rsp, err := c.DeleteManyWorkspaceMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManyWorkspaceMembersResponse(rsp)
}

// FindManyWorkspaceMembersWithResponse request returning *FindManyWorkspaceMembersResponse
func (c *ClientWithResponses) FindManyWorkspaceMembersWithResponse(ctx context.Context, params *FindManyWorkspaceMembersParams, reqEditors ...RequestEditorFn) (*FindManyWorkspaceMembersResponse, error) {
	rsp, err := c.FindManyWorkspaceMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManyWorkspaceMembersResponse(rsp)
}

// UpdateManyWorkspaceMembersWithBodyWithResponse request with arbitrary body returning *UpdateManyWorkspaceMembersResponse
func (c *ClientWithResponses) UpdateManyWorkspaceMembersWithBodyWithResponse(ctx context.Context, params *UpdateManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManyWorkspaceMembersResponse, error) {
	rsp, err := c.UpdateManyWorkspaceMembersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkspaceMembersResponse(rsp)
}

func (c *ClientWithResponses) UpdateManyWorkspaceMembersWithResponse(ctx context.Context, params *UpdateManyWorkspaceMembersParams, body UpdateManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManyWorkspaceMembersResponse, error) {
	rsp, err := c.UpdateManyWorkspaceMembers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManyWorkspaceMembersResponse(rsp)
}

// CreateOneWorkspaceMemberWithBodyWithResponse request with arbitrary body returning *CreateOneWorkspaceMemberResponse
func (c *ClientWithResponses) CreateOneWorkspaceMemberWithBodyWithResponse(ctx context.Context, params *CreateOneWorkspaceMemberParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOneWorkspaceMemberResponse, error) {
	rsp, err := c.CreateOneWorkspaceMemberWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkspaceMemberResponse(rsp)
}

func (c *ClientWithResponses) CreateOneWorkspaceMemberWithResponse(ctx context.Context, params *CreateOneWorkspaceMemberParams, body CreateOneWorkspaceMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOneWorkspaceMemberResponse, error) {
	rsp, err := c.CreateOneWorkspaceMember(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOneWorkspaceMemberResponse(rsp)
}

// FindWorkspaceMemberDuplicatesWithBodyWithResponse request with arbitrary body returning *FindWorkspaceMemberDuplicatesResponse
func (c *ClientWithResponses) FindWorkspaceMemberDuplicatesWithBodyWithResponse(ctx context.Context, params *FindWorkspaceMemberDuplicatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindWorkspaceMemberDuplicatesResponse, error) {
	rsp, err := c.FindWorkspaceMemberDuplicatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkspaceMemberDuplicatesResponse(rsp)
}

func (c *ClientWithResponses) FindWorkspaceMemberDuplicatesWithResponse(ctx context.Context, params *FindWorkspaceMemberDuplicatesParams, body FindWorkspaceMemberDuplicatesJSONRequestBody, reqEditors ...RequestEditorFn) (*FindWorkspaceMemberDuplicatesResponse, error) {
	rsp, err := c.FindWorkspaceMemberDuplicates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindWorkspaceMemberDuplicatesResponse(rsp)
}

// MergeManyWorkspaceMembersWithBodyWithResponse request with arbitrary body returning *MergeManyWorkspaceMembersResponse
func (c *ClientWithResponses) MergeManyWorkspaceMembersWithBodyWithResponse(ctx context.Context, params *MergeManyWorkspaceMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeManyWorkspaceMembersResponse, error) {
	rsp, err := c.MergeManyWorkspaceMembersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkspaceMembersResponse(rsp)
}

func (c *ClientWithResponses) MergeManyWorkspaceMembersWithResponse(ctx context.Context, params *MergeManyWorkspaceMembersParams, body MergeManyWorkspaceMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeManyWorkspaceMembersResponse, error) {
	rsp, err := c.MergeManyWorkspaceMembers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeManyWorkspaceMembersResponse(rsp)
}

// DeleteOneWorkspaceMemberWithResponse request returning *DeleteOneWorkspaceMemberResponse
func (c *ClientWithResponses) DeleteOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *DeleteOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*DeleteOneWorkspaceMemberResponse, error) {
	rsp, err := c.DeleteOneWorkspaceMember(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOneWorkspaceMemberResponse(rsp)
}

// FindOneWorkspaceMemberWithResponse request returning *FindOneWorkspaceMemberResponse
func (c *ClientWithResponses) FindOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *FindOneWorkspaceMemberParams, reqEditors ...RequestEditorFn) (*FindOneWorkspaceMemberResponse, error) {
	rsp, err := c.FindOneWorkspaceMember(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOneWorkspaceMemberResponse(rsp)
}

// UpdateOneWorkspaceMemberWithBodyWithResponse request with arbitrary body returning *UpdateOneWorkspaceMemberResponse
func (c *ClientWithResponses) UpdateOneWorkspaceMemberWithBodyWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkspaceMemberParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOneWorkspaceMemberResponse, error) {
	rsp, err := c.UpdateOneWorkspaceMemberWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkspaceMemberResponse(rsp)
}

func (c *ClientWithResponses) UpdateOneWorkspaceMemberWithResponse(ctx context.Context, id IdPath, params *UpdateOneWorkspaceMemberParams, body UpdateOneWorkspaceMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOneWorkspaceMemberResponse, error) {
	rsp, err := c.UpdateOneWorkspaceMember(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOneWorkspaceMemberResponse(rsp)
}

// ParseDeleteManyAttachmentsResponse parses an HTTP response from a DeleteManyAttachmentsWithResponse call
func ParseDeleteManyAttachmentsResponse(rsp *http.Response) (*DeleteManyAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteAttachments *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteAttachments,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyAttachmentsResponse parses an HTTP response from a FindManyAttachmentsWithResponse call
func ParseFindManyAttachmentsResponse(rsp *http.Response) (*FindManyAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Attachments *[]AttachmentForResponse `json:"attachments,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyAttachmentsResponse parses an HTTP response from a UpdateManyAttachmentsWithResponse call
func ParseUpdateManyAttachmentsResponse(rsp *http.Response) (*UpdateManyAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateAttachments *[]AttachmentForResponse `json:"updateAttachments,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneAttachmentResponse parses an HTTP response from a CreateOneAttachmentWithResponse call
func ParseCreateOneAttachmentResponse(rsp *http.Response) (*CreateOneAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateAttachment An attachment
				CreateAttachment *AttachmentForResponse `json:"createAttachment,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindAttachmentDuplicatesResponse parses an HTTP response from a FindAttachmentDuplicatesWithResponse call
func ParseFindAttachmentDuplicatesResponse(rsp *http.Response) (*FindAttachmentDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAttachmentDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AttachmentDuplicates *[]AttachmentForResponse `json:"attachmentDuplicates,omitempty"`
				PageInfo             *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyAttachmentsResponse parses an HTTP response from a MergeManyAttachmentsWithResponse call
func ParseMergeManyAttachmentsResponse(rsp *http.Response) (*MergeManyAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeAttachments An attachment
				MergeAttachments *AttachmentForResponse `json:"mergeAttachments,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneAttachmentResponse parses an HTTP response from a DeleteOneAttachmentWithResponse call
func ParseDeleteOneAttachmentResponse(rsp *http.Response) (*DeleteOneAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteAttachment *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteAttachment,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneAttachmentResponse parses an HTTP response from a FindOneAttachmentWithResponse call
func ParseFindOneAttachmentResponse(rsp *http.Response) (*FindOneAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Attachment An attachment
				Attachment *AttachmentForResponse `json:"attachment,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneAttachmentResponse parses an HTTP response from a UpdateOneAttachmentWithResponse call
func ParseUpdateOneAttachmentResponse(rsp *http.Response) (*UpdateOneAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateAttachment An attachment
				UpdateAttachment *AttachmentForResponse `json:"updateAttachment,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyAttachmentsResponse parses an HTTP response from a CreateManyAttachmentsWithResponse call
func ParseCreateManyAttachmentsResponse(rsp *http.Response) (*CreateManyAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateAttachments *[]AttachmentForResponse `json:"createAttachments,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyBlocklistsResponse parses an HTTP response from a CreateManyBlocklistsWithResponse call
func ParseCreateManyBlocklistsResponse(rsp *http.Response) (*CreateManyBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateBlocklists *[]BlocklistForResponse `json:"createBlocklists,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyCalendarChannelEventAssociationsResponse parses an HTTP response from a CreateManyCalendarChannelEventAssociationsWithResponse call
func ParseCreateManyCalendarChannelEventAssociationsResponse(rsp *http.Response) (*CreateManyCalendarChannelEventAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyCalendarChannelEventAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateCalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"createCalendarChannelEventAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyCalendarChannelsResponse parses an HTTP response from a CreateManyCalendarChannelsWithResponse call
func ParseCreateManyCalendarChannelsResponse(rsp *http.Response) (*CreateManyCalendarChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyCalendarChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateCalendarChannels *[]CalendarChannelForResponse `json:"createCalendarChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyCalendarEventParticipantsResponse parses an HTTP response from a CreateManyCalendarEventParticipantsWithResponse call
func ParseCreateManyCalendarEventParticipantsResponse(rsp *http.Response) (*CreateManyCalendarEventParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyCalendarEventParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateCalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"createCalendarEventParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyCalendarEventsResponse parses an HTTP response from a CreateManyCalendarEventsWithResponse call
func ParseCreateManyCalendarEventsResponse(rsp *http.Response) (*CreateManyCalendarEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyCalendarEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateCalendarEvents *[]CalendarEventForResponse `json:"createCalendarEvents,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyCompaniesResponse parses an HTTP response from a CreateManyCompaniesWithResponse call
func ParseCreateManyCompaniesResponse(rsp *http.Response) (*CreateManyCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateCompanies *[]CompanyForResponse `json:"createCompanies,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyConnectedAccountsResponse parses an HTTP response from a CreateManyConnectedAccountsWithResponse call
func ParseCreateManyConnectedAccountsResponse(rsp *http.Response) (*CreateManyConnectedAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyConnectedAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateConnectedAccounts *[]ConnectedAccountForResponse `json:"createConnectedAccounts,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyDashboardsResponse parses an HTTP response from a CreateManyDashboardsWithResponse call
func ParseCreateManyDashboardsResponse(rsp *http.Response) (*CreateManyDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateDashboards *[]DashboardForResponse `json:"createDashboards,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyFavoriteFoldersResponse parses an HTTP response from a CreateManyFavoriteFoldersWithResponse call
func ParseCreateManyFavoriteFoldersResponse(rsp *http.Response) (*CreateManyFavoriteFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyFavoriteFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateFavoriteFolders *[]FavoriteFolderForResponse `json:"createFavoriteFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyFavoritesResponse parses an HTTP response from a CreateManyFavoritesWithResponse call
func ParseCreateManyFavoritesResponse(rsp *http.Response) (*CreateManyFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateFavorites *[]FavoriteForResponse `json:"createFavorites,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyMessageChannelMessageAssociationsResponse parses an HTTP response from a CreateManyMessageChannelMessageAssociationsWithResponse call
func ParseCreateManyMessageChannelMessageAssociationsResponse(rsp *http.Response) (*CreateManyMessageChannelMessageAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyMessageChannelMessageAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateMessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"createMessageChannelMessageAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyMessageChannelsResponse parses an HTTP response from a CreateManyMessageChannelsWithResponse call
func ParseCreateManyMessageChannelsResponse(rsp *http.Response) (*CreateManyMessageChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyMessageChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateMessageChannels *[]MessageChannelForResponse `json:"createMessageChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyMessageFoldersResponse parses an HTTP response from a CreateManyMessageFoldersWithResponse call
func ParseCreateManyMessageFoldersResponse(rsp *http.Response) (*CreateManyMessageFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyMessageFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateMessageFolders *[]MessageFolderForResponse `json:"createMessageFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyMessageParticipantsResponse parses an HTTP response from a CreateManyMessageParticipantsWithResponse call
func ParseCreateManyMessageParticipantsResponse(rsp *http.Response) (*CreateManyMessageParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyMessageParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateMessageParticipants *[]MessageParticipantForResponse `json:"createMessageParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyMessageThreadsResponse parses an HTTP response from a CreateManyMessageThreadsWithResponse call
func ParseCreateManyMessageThreadsResponse(rsp *http.Response) (*CreateManyMessageThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyMessageThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateMessageThreads *[]MessageThreadForResponse `json:"createMessageThreads,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyMessagesResponse parses an HTTP response from a CreateManyMessagesWithResponse call
func ParseCreateManyMessagesResponse(rsp *http.Response) (*CreateManyMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateMessages *[]MessageForResponse `json:"createMessages,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyNoteTargetsResponse parses an HTTP response from a CreateManyNoteTargetsWithResponse call
func ParseCreateManyNoteTargetsResponse(rsp *http.Response) (*CreateManyNoteTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyNoteTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateNoteTargets *[]NoteTargetForResponse `json:"createNoteTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyNotesResponse parses an HTTP response from a CreateManyNotesWithResponse call
func ParseCreateManyNotesResponse(rsp *http.Response) (*CreateManyNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateNotes *[]NoteForResponse `json:"createNotes,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyOpportunitiesResponse parses an HTTP response from a CreateManyOpportunitiesWithResponse call
func ParseCreateManyOpportunitiesResponse(rsp *http.Response) (*CreateManyOpportunitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyOpportunitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateOpportunities *[]OpportunityForResponse `json:"createOpportunities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyPeopleResponse parses an HTTP response from a CreateManyPeopleWithResponse call
func ParseCreateManyPeopleResponse(rsp *http.Response) (*CreateManyPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreatePeople *[]PersonForResponse `json:"createPeople,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyTaskTargetsResponse parses an HTTP response from a CreateManyTaskTargetsWithResponse call
func ParseCreateManyTaskTargetsResponse(rsp *http.Response) (*CreateManyTaskTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyTaskTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateTaskTargets *[]TaskTargetForResponse `json:"createTaskTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyTasksResponse parses an HTTP response from a CreateManyTasksWithResponse call
func ParseCreateManyTasksResponse(rsp *http.Response) (*CreateManyTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateTasks *[]TaskForResponse `json:"createTasks,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyTimelineActivitiesResponse parses an HTTP response from a CreateManyTimelineActivitiesWithResponse call
func ParseCreateManyTimelineActivitiesResponse(rsp *http.Response) (*CreateManyTimelineActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyTimelineActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateTimelineActivities *[]TimelineActivityForResponse `json:"createTimelineActivities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyWorkflowAutomatedTriggersResponse parses an HTTP response from a CreateManyWorkflowAutomatedTriggersWithResponse call
func ParseCreateManyWorkflowAutomatedTriggersResponse(rsp *http.Response) (*CreateManyWorkflowAutomatedTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyWorkflowAutomatedTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateWorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"createWorkflowAutomatedTriggers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyWorkflowRunsResponse parses an HTTP response from a CreateManyWorkflowRunsWithResponse call
func ParseCreateManyWorkflowRunsResponse(rsp *http.Response) (*CreateManyWorkflowRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateWorkflowRuns *[]WorkflowRunForResponse `json:"createWorkflowRuns,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyWorkflowVersionsResponse parses an HTTP response from a CreateManyWorkflowVersionsWithResponse call
func ParseCreateManyWorkflowVersionsResponse(rsp *http.Response) (*CreateManyWorkflowVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyWorkflowVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateWorkflowVersions *[]WorkflowVersionForResponse `json:"createWorkflowVersions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyWorkflowsResponse parses an HTTP response from a CreateManyWorkflowsWithResponse call
func ParseCreateManyWorkflowsResponse(rsp *http.Response) (*CreateManyWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateWorkflows *[]WorkflowForResponse `json:"createWorkflows,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateManyWorkspaceMembersResponse parses an HTTP response from a CreateManyWorkspaceMembersWithResponse call
func ParseCreateManyWorkspaceMembersResponse(rsp *http.Response) (*CreateManyWorkspaceMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManyWorkspaceMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				CreateWorkspaceMembers *[]WorkspaceMemberForResponse `json:"createWorkspaceMembers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyBlocklistsResponse parses an HTTP response from a DeleteManyBlocklistsWithResponse call
func ParseDeleteManyBlocklistsResponse(rsp *http.Response) (*DeleteManyBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteBlocklists *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteBlocklists,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyBlocklistsResponse parses an HTTP response from a FindManyBlocklistsWithResponse call
func ParseFindManyBlocklistsResponse(rsp *http.Response) (*FindManyBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Blocklists *[]BlocklistForResponse `json:"blocklists,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyBlocklistsResponse parses an HTTP response from a UpdateManyBlocklistsWithResponse call
func ParseUpdateManyBlocklistsResponse(rsp *http.Response) (*UpdateManyBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateBlocklists *[]BlocklistForResponse `json:"updateBlocklists,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneBlocklistResponse parses an HTTP response from a CreateOneBlocklistWithResponse call
func ParseCreateOneBlocklistResponse(rsp *http.Response) (*CreateOneBlocklistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneBlocklistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateBlocklist Blocklist
				CreateBlocklist *BlocklistForResponse `json:"createBlocklist,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindBlocklistDuplicatesResponse parses an HTTP response from a FindBlocklistDuplicatesWithResponse call
func ParseFindBlocklistDuplicatesResponse(rsp *http.Response) (*FindBlocklistDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindBlocklistDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				BlocklistDuplicates *[]BlocklistForResponse `json:"blocklistDuplicates,omitempty"`
				PageInfo            *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyBlocklistsResponse parses an HTTP response from a MergeManyBlocklistsWithResponse call
func ParseMergeManyBlocklistsResponse(rsp *http.Response) (*MergeManyBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeBlocklists Blocklist
				MergeBlocklists *BlocklistForResponse `json:"mergeBlocklists,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneBlocklistResponse parses an HTTP response from a DeleteOneBlocklistWithResponse call
func ParseDeleteOneBlocklistResponse(rsp *http.Response) (*DeleteOneBlocklistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneBlocklistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteBlocklist *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteBlocklist,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneBlocklistResponse parses an HTTP response from a FindOneBlocklistWithResponse call
func ParseFindOneBlocklistResponse(rsp *http.Response) (*FindOneBlocklistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneBlocklistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Blocklist Blocklist
				Blocklist *BlocklistForResponse `json:"blocklist,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneBlocklistResponse parses an HTTP response from a UpdateOneBlocklistWithResponse call
func ParseUpdateOneBlocklistResponse(rsp *http.Response) (*UpdateOneBlocklistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneBlocklistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateBlocklist Blocklist
				UpdateBlocklist *BlocklistForResponse `json:"updateBlocklist,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyCalendarChannelEventAssociationsResponse parses an HTTP response from a DeleteManyCalendarChannelEventAssociationsWithResponse call
func ParseDeleteManyCalendarChannelEventAssociationsResponse(rsp *http.Response) (*DeleteManyCalendarChannelEventAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyCalendarChannelEventAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarChannelEventAssociations *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarChannelEventAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyCalendarChannelEventAssociationsResponse parses an HTTP response from a FindManyCalendarChannelEventAssociationsWithResponse call
func ParseFindManyCalendarChannelEventAssociationsResponse(rsp *http.Response) (*FindManyCalendarChannelEventAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyCalendarChannelEventAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				CalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"calendarChannelEventAssociations,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyCalendarChannelEventAssociationsResponse parses an HTTP response from a UpdateManyCalendarChannelEventAssociationsWithResponse call
func ParseUpdateManyCalendarChannelEventAssociationsResponse(rsp *http.Response) (*UpdateManyCalendarChannelEventAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyCalendarChannelEventAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateCalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"updateCalendarChannelEventAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneCalendarChannelEventAssociationResponse parses an HTTP response from a CreateOneCalendarChannelEventAssociationWithResponse call
func ParseCreateOneCalendarChannelEventAssociationResponse(rsp *http.Response) (*CreateOneCalendarChannelEventAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneCalendarChannelEventAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateCalendarChannelEventAssociation Calendar Channel Event Associations
				CreateCalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"createCalendarChannelEventAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindCalendarChannelEventAssociationDuplicatesResponse parses an HTTP response from a FindCalendarChannelEventAssociationDuplicatesWithResponse call
func ParseFindCalendarChannelEventAssociationDuplicatesResponse(rsp *http.Response) (*FindCalendarChannelEventAssociationDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCalendarChannelEventAssociationDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				CalendarChannelEventAssociationDuplicates *[]CalendarChannelEventAssociationForResponse `json:"calendarChannelEventAssociationDuplicates,omitempty"`
				PageInfo                                  *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyCalendarChannelEventAssociationsResponse parses an HTTP response from a MergeManyCalendarChannelEventAssociationsWithResponse call
func ParseMergeManyCalendarChannelEventAssociationsResponse(rsp *http.Response) (*MergeManyCalendarChannelEventAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyCalendarChannelEventAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeCalendarChannelEventAssociations Calendar Channel Event Associations
				MergeCalendarChannelEventAssociations *CalendarChannelEventAssociationForResponse `json:"mergeCalendarChannelEventAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneCalendarChannelEventAssociationResponse parses an HTTP response from a DeleteOneCalendarChannelEventAssociationWithResponse call
func ParseDeleteOneCalendarChannelEventAssociationResponse(rsp *http.Response) (*DeleteOneCalendarChannelEventAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneCalendarChannelEventAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarChannelEventAssociation *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarChannelEventAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneCalendarChannelEventAssociationResponse parses an HTTP response from a FindOneCalendarChannelEventAssociationWithResponse call
func ParseFindOneCalendarChannelEventAssociationResponse(rsp *http.Response) (*FindOneCalendarChannelEventAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneCalendarChannelEventAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// CalendarChannelEventAssociation Calendar Channel Event Associations
				CalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"calendarChannelEventAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneCalendarChannelEventAssociationResponse parses an HTTP response from a UpdateOneCalendarChannelEventAssociationWithResponse call
func ParseUpdateOneCalendarChannelEventAssociationResponse(rsp *http.Response) (*UpdateOneCalendarChannelEventAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneCalendarChannelEventAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateCalendarChannelEventAssociation Calendar Channel Event Associations
				UpdateCalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"updateCalendarChannelEventAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyCalendarChannelsResponse parses an HTTP response from a DeleteManyCalendarChannelsWithResponse call
func ParseDeleteManyCalendarChannelsResponse(rsp *http.Response) (*DeleteManyCalendarChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyCalendarChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarChannels *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyCalendarChannelsResponse parses an HTTP response from a FindManyCalendarChannelsWithResponse call
func ParseFindManyCalendarChannelsResponse(rsp *http.Response) (*FindManyCalendarChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyCalendarChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				CalendarChannels *[]CalendarChannelForResponse `json:"calendarChannels,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyCalendarChannelsResponse parses an HTTP response from a UpdateManyCalendarChannelsWithResponse call
func ParseUpdateManyCalendarChannelsResponse(rsp *http.Response) (*UpdateManyCalendarChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyCalendarChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateCalendarChannels *[]CalendarChannelForResponse `json:"updateCalendarChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneCalendarChannelResponse parses an HTTP response from a CreateOneCalendarChannelWithResponse call
func ParseCreateOneCalendarChannelResponse(rsp *http.Response) (*CreateOneCalendarChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneCalendarChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateCalendarChannel Calendar Channels
				CreateCalendarChannel *CalendarChannelForResponse `json:"createCalendarChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindCalendarChannelDuplicatesResponse parses an HTTP response from a FindCalendarChannelDuplicatesWithResponse call
func ParseFindCalendarChannelDuplicatesResponse(rsp *http.Response) (*FindCalendarChannelDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCalendarChannelDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				CalendarChannelDuplicates *[]CalendarChannelForResponse `json:"calendarChannelDuplicates,omitempty"`
				PageInfo                  *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyCalendarChannelsResponse parses an HTTP response from a MergeManyCalendarChannelsWithResponse call
func ParseMergeManyCalendarChannelsResponse(rsp *http.Response) (*MergeManyCalendarChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyCalendarChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeCalendarChannels Calendar Channels
				MergeCalendarChannels *CalendarChannelForResponse `json:"mergeCalendarChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneCalendarChannelResponse parses an HTTP response from a DeleteOneCalendarChannelWithResponse call
func ParseDeleteOneCalendarChannelResponse(rsp *http.Response) (*DeleteOneCalendarChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneCalendarChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarChannel *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneCalendarChannelResponse parses an HTTP response from a FindOneCalendarChannelWithResponse call
func ParseFindOneCalendarChannelResponse(rsp *http.Response) (*FindOneCalendarChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneCalendarChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// CalendarChannel Calendar Channels
				CalendarChannel *CalendarChannelForResponse `json:"calendarChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneCalendarChannelResponse parses an HTTP response from a UpdateOneCalendarChannelWithResponse call
func ParseUpdateOneCalendarChannelResponse(rsp *http.Response) (*UpdateOneCalendarChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneCalendarChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateCalendarChannel Calendar Channels
				UpdateCalendarChannel *CalendarChannelForResponse `json:"updateCalendarChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyCalendarEventParticipantsResponse parses an HTTP response from a DeleteManyCalendarEventParticipantsWithResponse call
func ParseDeleteManyCalendarEventParticipantsResponse(rsp *http.Response) (*DeleteManyCalendarEventParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyCalendarEventParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarEventParticipants *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarEventParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyCalendarEventParticipantsResponse parses an HTTP response from a FindManyCalendarEventParticipantsWithResponse call
func ParseFindManyCalendarEventParticipantsResponse(rsp *http.Response) (*FindManyCalendarEventParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyCalendarEventParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				CalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"calendarEventParticipants,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyCalendarEventParticipantsResponse parses an HTTP response from a UpdateManyCalendarEventParticipantsWithResponse call
func ParseUpdateManyCalendarEventParticipantsResponse(rsp *http.Response) (*UpdateManyCalendarEventParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyCalendarEventParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateCalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"updateCalendarEventParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneCalendarEventParticipantResponse parses an HTTP response from a CreateOneCalendarEventParticipantWithResponse call
func ParseCreateOneCalendarEventParticipantResponse(rsp *http.Response) (*CreateOneCalendarEventParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneCalendarEventParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateCalendarEventParticipant Calendar event participants
				CreateCalendarEventParticipant *CalendarEventParticipantForResponse `json:"createCalendarEventParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindCalendarEventParticipantDuplicatesResponse parses an HTTP response from a FindCalendarEventParticipantDuplicatesWithResponse call
func ParseFindCalendarEventParticipantDuplicatesResponse(rsp *http.Response) (*FindCalendarEventParticipantDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCalendarEventParticipantDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				CalendarEventParticipantDuplicates *[]CalendarEventParticipantForResponse `json:"calendarEventParticipantDuplicates,omitempty"`
				PageInfo                           *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyCalendarEventParticipantsResponse parses an HTTP response from a MergeManyCalendarEventParticipantsWithResponse call
func ParseMergeManyCalendarEventParticipantsResponse(rsp *http.Response) (*MergeManyCalendarEventParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyCalendarEventParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeCalendarEventParticipants Calendar event participants
				MergeCalendarEventParticipants *CalendarEventParticipantForResponse `json:"mergeCalendarEventParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneCalendarEventParticipantResponse parses an HTTP response from a DeleteOneCalendarEventParticipantWithResponse call
func ParseDeleteOneCalendarEventParticipantResponse(rsp *http.Response) (*DeleteOneCalendarEventParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneCalendarEventParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarEventParticipant *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarEventParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneCalendarEventParticipantResponse parses an HTTP response from a FindOneCalendarEventParticipantWithResponse call
func ParseFindOneCalendarEventParticipantResponse(rsp *http.Response) (*FindOneCalendarEventParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneCalendarEventParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// CalendarEventParticipant Calendar event participants
				CalendarEventParticipant *CalendarEventParticipantForResponse `json:"calendarEventParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneCalendarEventParticipantResponse parses an HTTP response from a UpdateOneCalendarEventParticipantWithResponse call
func ParseUpdateOneCalendarEventParticipantResponse(rsp *http.Response) (*UpdateOneCalendarEventParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneCalendarEventParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateCalendarEventParticipant Calendar event participants
				UpdateCalendarEventParticipant *CalendarEventParticipantForResponse `json:"updateCalendarEventParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyCalendarEventsResponse parses an HTTP response from a DeleteManyCalendarEventsWithResponse call
func ParseDeleteManyCalendarEventsResponse(rsp *http.Response) (*DeleteManyCalendarEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyCalendarEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarEvents *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarEvents,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyCalendarEventsResponse parses an HTTP response from a FindManyCalendarEventsWithResponse call
func ParseFindManyCalendarEventsResponse(rsp *http.Response) (*FindManyCalendarEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyCalendarEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				CalendarEvents *[]CalendarEventForResponse `json:"calendarEvents,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyCalendarEventsResponse parses an HTTP response from a UpdateManyCalendarEventsWithResponse call
func ParseUpdateManyCalendarEventsResponse(rsp *http.Response) (*UpdateManyCalendarEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyCalendarEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateCalendarEvents *[]CalendarEventForResponse `json:"updateCalendarEvents,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneCalendarEventResponse parses an HTTP response from a CreateOneCalendarEventWithResponse call
func ParseCreateOneCalendarEventResponse(rsp *http.Response) (*CreateOneCalendarEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneCalendarEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateCalendarEvent Calendar events
				CreateCalendarEvent *CalendarEventForResponse `json:"createCalendarEvent,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindCalendarEventDuplicatesResponse parses an HTTP response from a FindCalendarEventDuplicatesWithResponse call
func ParseFindCalendarEventDuplicatesResponse(rsp *http.Response) (*FindCalendarEventDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCalendarEventDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				CalendarEventDuplicates *[]CalendarEventForResponse `json:"calendarEventDuplicates,omitempty"`
				PageInfo                *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyCalendarEventsResponse parses an HTTP response from a MergeManyCalendarEventsWithResponse call
func ParseMergeManyCalendarEventsResponse(rsp *http.Response) (*MergeManyCalendarEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyCalendarEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeCalendarEvents Calendar events
				MergeCalendarEvents *CalendarEventForResponse `json:"mergeCalendarEvents,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneCalendarEventResponse parses an HTTP response from a DeleteOneCalendarEventWithResponse call
func ParseDeleteOneCalendarEventResponse(rsp *http.Response) (*DeleteOneCalendarEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneCalendarEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCalendarEvent *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCalendarEvent,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneCalendarEventResponse parses an HTTP response from a FindOneCalendarEventWithResponse call
func ParseFindOneCalendarEventResponse(rsp *http.Response) (*FindOneCalendarEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneCalendarEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// CalendarEvent Calendar events
				CalendarEvent *CalendarEventForResponse `json:"calendarEvent,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneCalendarEventResponse parses an HTTP response from a UpdateOneCalendarEventWithResponse call
func ParseUpdateOneCalendarEventResponse(rsp *http.Response) (*UpdateOneCalendarEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneCalendarEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateCalendarEvent Calendar events
				UpdateCalendarEvent *CalendarEventForResponse `json:"updateCalendarEvent,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyCompaniesResponse parses an HTTP response from a DeleteManyCompaniesWithResponse call
func ParseDeleteManyCompaniesResponse(rsp *http.Response) (*DeleteManyCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCompanies *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCompanies,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyCompaniesResponse parses an HTTP response from a FindManyCompaniesWithResponse call
func ParseFindManyCompaniesResponse(rsp *http.Response) (*FindManyCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Companies *[]CompanyForResponse `json:"companies,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyCompaniesResponse parses an HTTP response from a UpdateManyCompaniesWithResponse call
func ParseUpdateManyCompaniesResponse(rsp *http.Response) (*UpdateManyCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateCompanies *[]CompanyForResponse `json:"updateCompanies,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneCompanyResponse parses an HTTP response from a CreateOneCompanyWithResponse call
func ParseCreateOneCompanyResponse(rsp *http.Response) (*CreateOneCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateCompany A company
				CreateCompany *CompanyForResponse `json:"createCompany,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindCompanyDuplicatesResponse parses an HTTP response from a FindCompanyDuplicatesWithResponse call
func ParseFindCompanyDuplicatesResponse(rsp *http.Response) (*FindCompanyDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCompanyDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				CompanyDuplicates *[]CompanyForResponse `json:"companyDuplicates,omitempty"`
				PageInfo          *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyCompaniesResponse parses an HTTP response from a MergeManyCompaniesWithResponse call
func ParseMergeManyCompaniesResponse(rsp *http.Response) (*MergeManyCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeCompanies A company
				MergeCompanies *CompanyForResponse `json:"mergeCompanies,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneCompanyResponse parses an HTTP response from a DeleteOneCompanyWithResponse call
func ParseDeleteOneCompanyResponse(rsp *http.Response) (*DeleteOneCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteCompany *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteCompany,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneCompanyResponse parses an HTTP response from a FindOneCompanyWithResponse call
func ParseFindOneCompanyResponse(rsp *http.Response) (*FindOneCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Company A company
				Company *CompanyForResponse `json:"company,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneCompanyResponse parses an HTTP response from a UpdateOneCompanyWithResponse call
func ParseUpdateOneCompanyResponse(rsp *http.Response) (*UpdateOneCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateCompany A company
				UpdateCompany *CompanyForResponse `json:"updateCompany,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyConnectedAccountsResponse parses an HTTP response from a DeleteManyConnectedAccountsWithResponse call
func ParseDeleteManyConnectedAccountsResponse(rsp *http.Response) (*DeleteManyConnectedAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyConnectedAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteConnectedAccounts *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteConnectedAccounts,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyConnectedAccountsResponse parses an HTTP response from a FindManyConnectedAccountsWithResponse call
func ParseFindManyConnectedAccountsResponse(rsp *http.Response) (*FindManyConnectedAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyConnectedAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				ConnectedAccounts *[]ConnectedAccountForResponse `json:"connectedAccounts,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyConnectedAccountsResponse parses an HTTP response from a UpdateManyConnectedAccountsWithResponse call
func ParseUpdateManyConnectedAccountsResponse(rsp *http.Response) (*UpdateManyConnectedAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyConnectedAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateConnectedAccounts *[]ConnectedAccountForResponse `json:"updateConnectedAccounts,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneConnectedAccountResponse parses an HTTP response from a CreateOneConnectedAccountWithResponse call
func ParseCreateOneConnectedAccountResponse(rsp *http.Response) (*CreateOneConnectedAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneConnectedAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateConnectedAccount A connected account
				CreateConnectedAccount *ConnectedAccountForResponse `json:"createConnectedAccount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindConnectedAccountDuplicatesResponse parses an HTTP response from a FindConnectedAccountDuplicatesWithResponse call
func ParseFindConnectedAccountDuplicatesResponse(rsp *http.Response) (*FindConnectedAccountDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindConnectedAccountDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				ConnectedAccountDuplicates *[]ConnectedAccountForResponse `json:"connectedAccountDuplicates,omitempty"`
				PageInfo                   *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyConnectedAccountsResponse parses an HTTP response from a MergeManyConnectedAccountsWithResponse call
func ParseMergeManyConnectedAccountsResponse(rsp *http.Response) (*MergeManyConnectedAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyConnectedAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeConnectedAccounts A connected account
				MergeConnectedAccounts *ConnectedAccountForResponse `json:"mergeConnectedAccounts,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneConnectedAccountResponse parses an HTTP response from a DeleteOneConnectedAccountWithResponse call
func ParseDeleteOneConnectedAccountResponse(rsp *http.Response) (*DeleteOneConnectedAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneConnectedAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteConnectedAccount *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteConnectedAccount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneConnectedAccountResponse parses an HTTP response from a FindOneConnectedAccountWithResponse call
func ParseFindOneConnectedAccountResponse(rsp *http.Response) (*FindOneConnectedAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneConnectedAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// ConnectedAccount A connected account
				ConnectedAccount *ConnectedAccountForResponse `json:"connectedAccount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneConnectedAccountResponse parses an HTTP response from a UpdateOneConnectedAccountWithResponse call
func ParseUpdateOneConnectedAccountResponse(rsp *http.Response) (*UpdateOneConnectedAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneConnectedAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateConnectedAccount A connected account
				UpdateConnectedAccount *ConnectedAccountForResponse `json:"updateConnectedAccount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyDashboardsResponse parses an HTTP response from a DeleteManyDashboardsWithResponse call
func ParseDeleteManyDashboardsResponse(rsp *http.Response) (*DeleteManyDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteDashboards *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteDashboards,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyDashboardsResponse parses an HTTP response from a FindManyDashboardsWithResponse call
func ParseFindManyDashboardsResponse(rsp *http.Response) (*FindManyDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Dashboards *[]DashboardForResponse `json:"dashboards,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyDashboardsResponse parses an HTTP response from a UpdateManyDashboardsWithResponse call
func ParseUpdateManyDashboardsResponse(rsp *http.Response) (*UpdateManyDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateDashboards *[]DashboardForResponse `json:"updateDashboards,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneDashboardResponse parses an HTTP response from a CreateOneDashboardWithResponse call
func ParseCreateOneDashboardResponse(rsp *http.Response) (*CreateOneDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateDashboard A dashboard
				CreateDashboard *DashboardForResponse `json:"createDashboard,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindDashboardDuplicatesResponse parses an HTTP response from a FindDashboardDuplicatesWithResponse call
func ParseFindDashboardDuplicatesResponse(rsp *http.Response) (*FindDashboardDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindDashboardDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				DashboardDuplicates *[]DashboardForResponse `json:"dashboardDuplicates,omitempty"`
				PageInfo            *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyDashboardsResponse parses an HTTP response from a MergeManyDashboardsWithResponse call
func ParseMergeManyDashboardsResponse(rsp *http.Response) (*MergeManyDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeDashboards A dashboard
				MergeDashboards *DashboardForResponse `json:"mergeDashboards,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneDashboardResponse parses an HTTP response from a DeleteOneDashboardWithResponse call
func ParseDeleteOneDashboardResponse(rsp *http.Response) (*DeleteOneDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteDashboard *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteDashboard,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneDashboardResponse parses an HTTP response from a FindOneDashboardWithResponse call
func ParseFindOneDashboardResponse(rsp *http.Response) (*FindOneDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Dashboard A dashboard
				Dashboard *DashboardForResponse `json:"dashboard,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneDashboardResponse parses an HTTP response from a UpdateOneDashboardWithResponse call
func ParseUpdateOneDashboardResponse(rsp *http.Response) (*UpdateOneDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateDashboard A dashboard
				UpdateDashboard *DashboardForResponse `json:"updateDashboard,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDuplicateDashboardResponse parses an HTTP response from a DuplicateDashboardWithResponse call
func ParseDuplicateDashboardResponse(rsp *http.Response) (*DuplicateDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuplicateDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DashboardForResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyFavoriteFoldersResponse parses an HTTP response from a DeleteManyFavoriteFoldersWithResponse call
func ParseDeleteManyFavoriteFoldersResponse(rsp *http.Response) (*DeleteManyFavoriteFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyFavoriteFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteFavoriteFolders *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteFavoriteFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyFavoriteFoldersResponse parses an HTTP response from a FindManyFavoriteFoldersWithResponse call
func ParseFindManyFavoriteFoldersResponse(rsp *http.Response) (*FindManyFavoriteFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyFavoriteFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				FavoriteFolders *[]FavoriteFolderForResponse `json:"favoriteFolders,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyFavoriteFoldersResponse parses an HTTP response from a UpdateManyFavoriteFoldersWithResponse call
func ParseUpdateManyFavoriteFoldersResponse(rsp *http.Response) (*UpdateManyFavoriteFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyFavoriteFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateFavoriteFolders *[]FavoriteFolderForResponse `json:"updateFavoriteFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneFavoriteFolderResponse parses an HTTP response from a CreateOneFavoriteFolderWithResponse call
func ParseCreateOneFavoriteFolderResponse(rsp *http.Response) (*CreateOneFavoriteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneFavoriteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateFavoriteFolder A Folder of favorites
				CreateFavoriteFolder *FavoriteFolderForResponse `json:"createFavoriteFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindFavoriteFolderDuplicatesResponse parses an HTTP response from a FindFavoriteFolderDuplicatesWithResponse call
func ParseFindFavoriteFolderDuplicatesResponse(rsp *http.Response) (*FindFavoriteFolderDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindFavoriteFolderDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				FavoriteFolderDuplicates *[]FavoriteFolderForResponse `json:"favoriteFolderDuplicates,omitempty"`
				PageInfo                 *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyFavoriteFoldersResponse parses an HTTP response from a MergeManyFavoriteFoldersWithResponse call
func ParseMergeManyFavoriteFoldersResponse(rsp *http.Response) (*MergeManyFavoriteFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyFavoriteFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeFavoriteFolders A Folder of favorites
				MergeFavoriteFolders *FavoriteFolderForResponse `json:"mergeFavoriteFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneFavoriteFolderResponse parses an HTTP response from a DeleteOneFavoriteFolderWithResponse call
func ParseDeleteOneFavoriteFolderResponse(rsp *http.Response) (*DeleteOneFavoriteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneFavoriteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteFavoriteFolder *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteFavoriteFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneFavoriteFolderResponse parses an HTTP response from a FindOneFavoriteFolderWithResponse call
func ParseFindOneFavoriteFolderResponse(rsp *http.Response) (*FindOneFavoriteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneFavoriteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// FavoriteFolder A Folder of favorites
				FavoriteFolder *FavoriteFolderForResponse `json:"favoriteFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneFavoriteFolderResponse parses an HTTP response from a UpdateOneFavoriteFolderWithResponse call
func ParseUpdateOneFavoriteFolderResponse(rsp *http.Response) (*UpdateOneFavoriteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneFavoriteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateFavoriteFolder A Folder of favorites
				UpdateFavoriteFolder *FavoriteFolderForResponse `json:"updateFavoriteFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyFavoritesResponse parses an HTTP response from a DeleteManyFavoritesWithResponse call
func ParseDeleteManyFavoritesResponse(rsp *http.Response) (*DeleteManyFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteFavorites *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteFavorites,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyFavoritesResponse parses an HTTP response from a FindManyFavoritesWithResponse call
func ParseFindManyFavoritesResponse(rsp *http.Response) (*FindManyFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Favorites *[]FavoriteForResponse `json:"favorites,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyFavoritesResponse parses an HTTP response from a UpdateManyFavoritesWithResponse call
func ParseUpdateManyFavoritesResponse(rsp *http.Response) (*UpdateManyFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateFavorites *[]FavoriteForResponse `json:"updateFavorites,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneFavoriteResponse parses an HTTP response from a CreateOneFavoriteWithResponse call
func ParseCreateOneFavoriteResponse(rsp *http.Response) (*CreateOneFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateFavorite A favorite that can be accessed from the left menu
				CreateFavorite *FavoriteForResponse `json:"createFavorite,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindFavoriteDuplicatesResponse parses an HTTP response from a FindFavoriteDuplicatesWithResponse call
func ParseFindFavoriteDuplicatesResponse(rsp *http.Response) (*FindFavoriteDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindFavoriteDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				FavoriteDuplicates *[]FavoriteForResponse `json:"favoriteDuplicates,omitempty"`
				PageInfo           *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyFavoritesResponse parses an HTTP response from a MergeManyFavoritesWithResponse call
func ParseMergeManyFavoritesResponse(rsp *http.Response) (*MergeManyFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeFavorites A favorite that can be accessed from the left menu
				MergeFavorites *FavoriteForResponse `json:"mergeFavorites,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneFavoriteResponse parses an HTTP response from a DeleteOneFavoriteWithResponse call
func ParseDeleteOneFavoriteResponse(rsp *http.Response) (*DeleteOneFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteFavorite *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteFavorite,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneFavoriteResponse parses an HTTP response from a FindOneFavoriteWithResponse call
func ParseFindOneFavoriteResponse(rsp *http.Response) (*FindOneFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Favorite A favorite that can be accessed from the left menu
				Favorite *FavoriteForResponse `json:"favorite,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneFavoriteResponse parses an HTTP response from a UpdateOneFavoriteWithResponse call
func ParseUpdateOneFavoriteResponse(rsp *http.Response) (*UpdateOneFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateFavorite A favorite that can be accessed from the left menu
				UpdateFavorite *FavoriteForResponse `json:"updateFavorite,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyMessageChannelMessageAssociationsResponse parses an HTTP response from a DeleteManyMessageChannelMessageAssociationsWithResponse call
func ParseDeleteManyMessageChannelMessageAssociationsResponse(rsp *http.Response) (*DeleteManyMessageChannelMessageAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyMessageChannelMessageAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageChannelMessageAssociations *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageChannelMessageAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyMessageChannelMessageAssociationsResponse parses an HTTP response from a FindManyMessageChannelMessageAssociationsWithResponse call
func ParseFindManyMessageChannelMessageAssociationsResponse(rsp *http.Response) (*FindManyMessageChannelMessageAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyMessageChannelMessageAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				MessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"messageChannelMessageAssociations,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyMessageChannelMessageAssociationsResponse parses an HTTP response from a UpdateManyMessageChannelMessageAssociationsWithResponse call
func ParseUpdateManyMessageChannelMessageAssociationsResponse(rsp *http.Response) (*UpdateManyMessageChannelMessageAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyMessageChannelMessageAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateMessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"updateMessageChannelMessageAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneMessageChannelMessageAssociationResponse parses an HTTP response from a CreateOneMessageChannelMessageAssociationWithResponse call
func ParseCreateOneMessageChannelMessageAssociationResponse(rsp *http.Response) (*CreateOneMessageChannelMessageAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneMessageChannelMessageAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateMessageChannelMessageAssociation Message Synced with a Message Channel
				CreateMessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"createMessageChannelMessageAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindMessageChannelMessageAssociationDuplicatesResponse parses an HTTP response from a FindMessageChannelMessageAssociationDuplicatesWithResponse call
func ParseFindMessageChannelMessageAssociationDuplicatesResponse(rsp *http.Response) (*FindMessageChannelMessageAssociationDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMessageChannelMessageAssociationDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				MessageChannelMessageAssociationDuplicates *[]MessageChannelMessageAssociationForResponse `json:"messageChannelMessageAssociationDuplicates,omitempty"`
				PageInfo                                   *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyMessageChannelMessageAssociationsResponse parses an HTTP response from a MergeManyMessageChannelMessageAssociationsWithResponse call
func ParseMergeManyMessageChannelMessageAssociationsResponse(rsp *http.Response) (*MergeManyMessageChannelMessageAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyMessageChannelMessageAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeMessageChannelMessageAssociations Message Synced with a Message Channel
				MergeMessageChannelMessageAssociations *MessageChannelMessageAssociationForResponse `json:"mergeMessageChannelMessageAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneMessageChannelMessageAssociationResponse parses an HTTP response from a DeleteOneMessageChannelMessageAssociationWithResponse call
func ParseDeleteOneMessageChannelMessageAssociationResponse(rsp *http.Response) (*DeleteOneMessageChannelMessageAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneMessageChannelMessageAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageChannelMessageAssociation *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageChannelMessageAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneMessageChannelMessageAssociationResponse parses an HTTP response from a FindOneMessageChannelMessageAssociationWithResponse call
func ParseFindOneMessageChannelMessageAssociationResponse(rsp *http.Response) (*FindOneMessageChannelMessageAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneMessageChannelMessageAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MessageChannelMessageAssociation Message Synced with a Message Channel
				MessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"messageChannelMessageAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneMessageChannelMessageAssociationResponse parses an HTTP response from a UpdateOneMessageChannelMessageAssociationWithResponse call
func ParseUpdateOneMessageChannelMessageAssociationResponse(rsp *http.Response) (*UpdateOneMessageChannelMessageAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneMessageChannelMessageAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateMessageChannelMessageAssociation Message Synced with a Message Channel
				UpdateMessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"updateMessageChannelMessageAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyMessageChannelsResponse parses an HTTP response from a DeleteManyMessageChannelsWithResponse call
func ParseDeleteManyMessageChannelsResponse(rsp *http.Response) (*DeleteManyMessageChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyMessageChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageChannels *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyMessageChannelsResponse parses an HTTP response from a FindManyMessageChannelsWithResponse call
func ParseFindManyMessageChannelsResponse(rsp *http.Response) (*FindManyMessageChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyMessageChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				MessageChannels *[]MessageChannelForResponse `json:"messageChannels,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyMessageChannelsResponse parses an HTTP response from a UpdateManyMessageChannelsWithResponse call
func ParseUpdateManyMessageChannelsResponse(rsp *http.Response) (*UpdateManyMessageChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyMessageChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateMessageChannels *[]MessageChannelForResponse `json:"updateMessageChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneMessageChannelResponse parses an HTTP response from a CreateOneMessageChannelWithResponse call
func ParseCreateOneMessageChannelResponse(rsp *http.Response) (*CreateOneMessageChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneMessageChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateMessageChannel Message Channels
				CreateMessageChannel *MessageChannelForResponse `json:"createMessageChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindMessageChannelDuplicatesResponse parses an HTTP response from a FindMessageChannelDuplicatesWithResponse call
func ParseFindMessageChannelDuplicatesResponse(rsp *http.Response) (*FindMessageChannelDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMessageChannelDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				MessageChannelDuplicates *[]MessageChannelForResponse `json:"messageChannelDuplicates,omitempty"`
				PageInfo                 *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyMessageChannelsResponse parses an HTTP response from a MergeManyMessageChannelsWithResponse call
func ParseMergeManyMessageChannelsResponse(rsp *http.Response) (*MergeManyMessageChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyMessageChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeMessageChannels Message Channels
				MergeMessageChannels *MessageChannelForResponse `json:"mergeMessageChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneMessageChannelResponse parses an HTTP response from a DeleteOneMessageChannelWithResponse call
func ParseDeleteOneMessageChannelResponse(rsp *http.Response) (*DeleteOneMessageChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneMessageChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageChannel *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneMessageChannelResponse parses an HTTP response from a FindOneMessageChannelWithResponse call
func ParseFindOneMessageChannelResponse(rsp *http.Response) (*FindOneMessageChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneMessageChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MessageChannel Message Channels
				MessageChannel *MessageChannelForResponse `json:"messageChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneMessageChannelResponse parses an HTTP response from a UpdateOneMessageChannelWithResponse call
func ParseUpdateOneMessageChannelResponse(rsp *http.Response) (*UpdateOneMessageChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneMessageChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateMessageChannel Message Channels
				UpdateMessageChannel *MessageChannelForResponse `json:"updateMessageChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyMessageFoldersResponse parses an HTTP response from a DeleteManyMessageFoldersWithResponse call
func ParseDeleteManyMessageFoldersResponse(rsp *http.Response) (*DeleteManyMessageFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyMessageFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageFolders *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyMessageFoldersResponse parses an HTTP response from a FindManyMessageFoldersWithResponse call
func ParseFindManyMessageFoldersResponse(rsp *http.Response) (*FindManyMessageFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyMessageFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				MessageFolders *[]MessageFolderForResponse `json:"messageFolders,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyMessageFoldersResponse parses an HTTP response from a UpdateManyMessageFoldersWithResponse call
func ParseUpdateManyMessageFoldersResponse(rsp *http.Response) (*UpdateManyMessageFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyMessageFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateMessageFolders *[]MessageFolderForResponse `json:"updateMessageFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneMessageFolderResponse parses an HTTP response from a CreateOneMessageFolderWithResponse call
func ParseCreateOneMessageFolderResponse(rsp *http.Response) (*CreateOneMessageFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneMessageFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateMessageFolder Folder for Message Channel
				CreateMessageFolder *MessageFolderForResponse `json:"createMessageFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindMessageFolderDuplicatesResponse parses an HTTP response from a FindMessageFolderDuplicatesWithResponse call
func ParseFindMessageFolderDuplicatesResponse(rsp *http.Response) (*FindMessageFolderDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMessageFolderDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				MessageFolderDuplicates *[]MessageFolderForResponse `json:"messageFolderDuplicates,omitempty"`
				PageInfo                *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyMessageFoldersResponse parses an HTTP response from a MergeManyMessageFoldersWithResponse call
func ParseMergeManyMessageFoldersResponse(rsp *http.Response) (*MergeManyMessageFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyMessageFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeMessageFolders Folder for Message Channel
				MergeMessageFolders *MessageFolderForResponse `json:"mergeMessageFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneMessageFolderResponse parses an HTTP response from a DeleteOneMessageFolderWithResponse call
func ParseDeleteOneMessageFolderResponse(rsp *http.Response) (*DeleteOneMessageFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneMessageFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageFolder *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneMessageFolderResponse parses an HTTP response from a FindOneMessageFolderWithResponse call
func ParseFindOneMessageFolderResponse(rsp *http.Response) (*FindOneMessageFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneMessageFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MessageFolder Folder for Message Channel
				MessageFolder *MessageFolderForResponse `json:"messageFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneMessageFolderResponse parses an HTTP response from a UpdateOneMessageFolderWithResponse call
func ParseUpdateOneMessageFolderResponse(rsp *http.Response) (*UpdateOneMessageFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneMessageFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateMessageFolder Folder for Message Channel
				UpdateMessageFolder *MessageFolderForResponse `json:"updateMessageFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyMessageParticipantsResponse parses an HTTP response from a DeleteManyMessageParticipantsWithResponse call
func ParseDeleteManyMessageParticipantsResponse(rsp *http.Response) (*DeleteManyMessageParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyMessageParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageParticipants *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyMessageParticipantsResponse parses an HTTP response from a FindManyMessageParticipantsWithResponse call
func ParseFindManyMessageParticipantsResponse(rsp *http.Response) (*FindManyMessageParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyMessageParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				MessageParticipants *[]MessageParticipantForResponse `json:"messageParticipants,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyMessageParticipantsResponse parses an HTTP response from a UpdateManyMessageParticipantsWithResponse call
func ParseUpdateManyMessageParticipantsResponse(rsp *http.Response) (*UpdateManyMessageParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyMessageParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateMessageParticipants *[]MessageParticipantForResponse `json:"updateMessageParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneMessageParticipantResponse parses an HTTP response from a CreateOneMessageParticipantWithResponse call
func ParseCreateOneMessageParticipantResponse(rsp *http.Response) (*CreateOneMessageParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneMessageParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateMessageParticipant Message Participants
				CreateMessageParticipant *MessageParticipantForResponse `json:"createMessageParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindMessageParticipantDuplicatesResponse parses an HTTP response from a FindMessageParticipantDuplicatesWithResponse call
func ParseFindMessageParticipantDuplicatesResponse(rsp *http.Response) (*FindMessageParticipantDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMessageParticipantDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				MessageParticipantDuplicates *[]MessageParticipantForResponse `json:"messageParticipantDuplicates,omitempty"`
				PageInfo                     *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyMessageParticipantsResponse parses an HTTP response from a MergeManyMessageParticipantsWithResponse call
func ParseMergeManyMessageParticipantsResponse(rsp *http.Response) (*MergeManyMessageParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyMessageParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeMessageParticipants Message Participants
				MergeMessageParticipants *MessageParticipantForResponse `json:"mergeMessageParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneMessageParticipantResponse parses an HTTP response from a DeleteOneMessageParticipantWithResponse call
func ParseDeleteOneMessageParticipantResponse(rsp *http.Response) (*DeleteOneMessageParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneMessageParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageParticipant *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneMessageParticipantResponse parses an HTTP response from a FindOneMessageParticipantWithResponse call
func ParseFindOneMessageParticipantResponse(rsp *http.Response) (*FindOneMessageParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneMessageParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MessageParticipant Message Participants
				MessageParticipant *MessageParticipantForResponse `json:"messageParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneMessageParticipantResponse parses an HTTP response from a UpdateOneMessageParticipantWithResponse call
func ParseUpdateOneMessageParticipantResponse(rsp *http.Response) (*UpdateOneMessageParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneMessageParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateMessageParticipant Message Participants
				UpdateMessageParticipant *MessageParticipantForResponse `json:"updateMessageParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyMessageThreadsResponse parses an HTTP response from a DeleteManyMessageThreadsWithResponse call
func ParseDeleteManyMessageThreadsResponse(rsp *http.Response) (*DeleteManyMessageThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyMessageThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageThreads *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageThreads,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyMessageThreadsResponse parses an HTTP response from a FindManyMessageThreadsWithResponse call
func ParseFindManyMessageThreadsResponse(rsp *http.Response) (*FindManyMessageThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyMessageThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				MessageThreads *[]MessageThreadForResponse `json:"messageThreads,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyMessageThreadsResponse parses an HTTP response from a UpdateManyMessageThreadsWithResponse call
func ParseUpdateManyMessageThreadsResponse(rsp *http.Response) (*UpdateManyMessageThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyMessageThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateMessageThreads *[]MessageThreadForResponse `json:"updateMessageThreads,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneMessageThreadResponse parses an HTTP response from a CreateOneMessageThreadWithResponse call
func ParseCreateOneMessageThreadResponse(rsp *http.Response) (*CreateOneMessageThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneMessageThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateMessageThread A group of related messages (e.g. email thread, chat thread)
				CreateMessageThread *MessageThreadForResponse `json:"createMessageThread,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindMessageThreadDuplicatesResponse parses an HTTP response from a FindMessageThreadDuplicatesWithResponse call
func ParseFindMessageThreadDuplicatesResponse(rsp *http.Response) (*FindMessageThreadDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMessageThreadDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				MessageThreadDuplicates *[]MessageThreadForResponse `json:"messageThreadDuplicates,omitempty"`
				PageInfo                *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyMessageThreadsResponse parses an HTTP response from a MergeManyMessageThreadsWithResponse call
func ParseMergeManyMessageThreadsResponse(rsp *http.Response) (*MergeManyMessageThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyMessageThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeMessageThreads A group of related messages (e.g. email thread, chat thread)
				MergeMessageThreads *MessageThreadForResponse `json:"mergeMessageThreads,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneMessageThreadResponse parses an HTTP response from a DeleteOneMessageThreadWithResponse call
func ParseDeleteOneMessageThreadResponse(rsp *http.Response) (*DeleteOneMessageThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneMessageThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessageThread *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessageThread,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneMessageThreadResponse parses an HTTP response from a FindOneMessageThreadWithResponse call
func ParseFindOneMessageThreadResponse(rsp *http.Response) (*FindOneMessageThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneMessageThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MessageThread A group of related messages (e.g. email thread, chat thread)
				MessageThread *MessageThreadForResponse `json:"messageThread,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneMessageThreadResponse parses an HTTP response from a UpdateOneMessageThreadWithResponse call
func ParseUpdateOneMessageThreadResponse(rsp *http.Response) (*UpdateOneMessageThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneMessageThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateMessageThread A group of related messages (e.g. email thread, chat thread)
				UpdateMessageThread *MessageThreadForResponse `json:"updateMessageThread,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyMessagesResponse parses an HTTP response from a DeleteManyMessagesWithResponse call
func ParseDeleteManyMessagesResponse(rsp *http.Response) (*DeleteManyMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessages *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessages,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyMessagesResponse parses an HTTP response from a FindManyMessagesWithResponse call
func ParseFindManyMessagesResponse(rsp *http.Response) (*FindManyMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Messages *[]MessageForResponse `json:"messages,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyMessagesResponse parses an HTTP response from a UpdateManyMessagesWithResponse call
func ParseUpdateManyMessagesResponse(rsp *http.Response) (*UpdateManyMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateMessages *[]MessageForResponse `json:"updateMessages,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneMessageResponse parses an HTTP response from a CreateOneMessageWithResponse call
func ParseCreateOneMessageResponse(rsp *http.Response) (*CreateOneMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateMessage A message sent or received through a messaging channel (email, chat, etc.)
				CreateMessage *MessageForResponse `json:"createMessage,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindMessageDuplicatesResponse parses an HTTP response from a FindMessageDuplicatesWithResponse call
func ParseFindMessageDuplicatesResponse(rsp *http.Response) (*FindMessageDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMessageDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				MessageDuplicates *[]MessageForResponse `json:"messageDuplicates,omitempty"`
				PageInfo          *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyMessagesResponse parses an HTTP response from a MergeManyMessagesWithResponse call
func ParseMergeManyMessagesResponse(rsp *http.Response) (*MergeManyMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeMessages A message sent or received through a messaging channel (email, chat, etc.)
				MergeMessages *MessageForResponse `json:"mergeMessages,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneMessageResponse parses an HTTP response from a DeleteOneMessageWithResponse call
func ParseDeleteOneMessageResponse(rsp *http.Response) (*DeleteOneMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteMessage *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteMessage,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneMessageResponse parses an HTTP response from a FindOneMessageWithResponse call
func ParseFindOneMessageResponse(rsp *http.Response) (*FindOneMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Message A message sent or received through a messaging channel (email, chat, etc.)
				Message *MessageForResponse `json:"message,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneMessageResponse parses an HTTP response from a UpdateOneMessageWithResponse call
func ParseUpdateOneMessageResponse(rsp *http.Response) (*UpdateOneMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateMessage A message sent or received through a messaging channel (email, chat, etc.)
				UpdateMessage *MessageForResponse `json:"updateMessage,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyNoteTargetsResponse parses an HTTP response from a DeleteManyNoteTargetsWithResponse call
func ParseDeleteManyNoteTargetsResponse(rsp *http.Response) (*DeleteManyNoteTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyNoteTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteNoteTargets *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteNoteTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyNoteTargetsResponse parses an HTTP response from a FindManyNoteTargetsWithResponse call
func ParseFindManyNoteTargetsResponse(rsp *http.Response) (*FindManyNoteTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyNoteTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				NoteTargets *[]NoteTargetForResponse `json:"noteTargets,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyNoteTargetsResponse parses an HTTP response from a UpdateManyNoteTargetsWithResponse call
func ParseUpdateManyNoteTargetsResponse(rsp *http.Response) (*UpdateManyNoteTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyNoteTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateNoteTargets *[]NoteTargetForResponse `json:"updateNoteTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneNoteTargetResponse parses an HTTP response from a CreateOneNoteTargetWithResponse call
func ParseCreateOneNoteTargetResponse(rsp *http.Response) (*CreateOneNoteTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneNoteTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateNoteTarget A note target
				CreateNoteTarget *NoteTargetForResponse `json:"createNoteTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindNoteTargetDuplicatesResponse parses an HTTP response from a FindNoteTargetDuplicatesWithResponse call
func ParseFindNoteTargetDuplicatesResponse(rsp *http.Response) (*FindNoteTargetDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindNoteTargetDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				NoteTargetDuplicates *[]NoteTargetForResponse `json:"noteTargetDuplicates,omitempty"`
				PageInfo             *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyNoteTargetsResponse parses an HTTP response from a MergeManyNoteTargetsWithResponse call
func ParseMergeManyNoteTargetsResponse(rsp *http.Response) (*MergeManyNoteTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyNoteTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeNoteTargets A note target
				MergeNoteTargets *NoteTargetForResponse `json:"mergeNoteTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneNoteTargetResponse parses an HTTP response from a DeleteOneNoteTargetWithResponse call
func ParseDeleteOneNoteTargetResponse(rsp *http.Response) (*DeleteOneNoteTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneNoteTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteNoteTarget *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteNoteTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneNoteTargetResponse parses an HTTP response from a FindOneNoteTargetWithResponse call
func ParseFindOneNoteTargetResponse(rsp *http.Response) (*FindOneNoteTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneNoteTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// NoteTarget A note target
				NoteTarget *NoteTargetForResponse `json:"noteTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneNoteTargetResponse parses an HTTP response from a UpdateOneNoteTargetWithResponse call
func ParseUpdateOneNoteTargetResponse(rsp *http.Response) (*UpdateOneNoteTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneNoteTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateNoteTarget A note target
				UpdateNoteTarget *NoteTargetForResponse `json:"updateNoteTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyNotesResponse parses an HTTP response from a DeleteManyNotesWithResponse call
func ParseDeleteManyNotesResponse(rsp *http.Response) (*DeleteManyNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteNotes *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteNotes,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyNotesResponse parses an HTTP response from a FindManyNotesWithResponse call
func ParseFindManyNotesResponse(rsp *http.Response) (*FindManyNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Notes *[]NoteForResponse `json:"notes,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyNotesResponse parses an HTTP response from a UpdateManyNotesWithResponse call
func ParseUpdateManyNotesResponse(rsp *http.Response) (*UpdateManyNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateNotes *[]NoteForResponse `json:"updateNotes,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneNoteResponse parses an HTTP response from a CreateOneNoteWithResponse call
func ParseCreateOneNoteResponse(rsp *http.Response) (*CreateOneNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateNote A note
				CreateNote *NoteForResponse `json:"createNote,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindNoteDuplicatesResponse parses an HTTP response from a FindNoteDuplicatesWithResponse call
func ParseFindNoteDuplicatesResponse(rsp *http.Response) (*FindNoteDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindNoteDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				NoteDuplicates *[]NoteForResponse `json:"noteDuplicates,omitempty"`
				PageInfo       *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyNotesResponse parses an HTTP response from a MergeManyNotesWithResponse call
func ParseMergeManyNotesResponse(rsp *http.Response) (*MergeManyNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeNotes A note
				MergeNotes *NoteForResponse `json:"mergeNotes,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneNoteResponse parses an HTTP response from a DeleteOneNoteWithResponse call
func ParseDeleteOneNoteResponse(rsp *http.Response) (*DeleteOneNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteNote *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteNote,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneNoteResponse parses an HTTP response from a FindOneNoteWithResponse call
func ParseFindOneNoteResponse(rsp *http.Response) (*FindOneNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Note A note
				Note *NoteForResponse `json:"note,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneNoteResponse parses an HTTP response from a UpdateOneNoteWithResponse call
func ParseUpdateOneNoteResponse(rsp *http.Response) (*UpdateOneNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateNote A note
				UpdateNote *NoteForResponse `json:"updateNote,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetOpenApiSchemaResponse parses an HTTP response from a GetOpenApiSchemaWithResponse call
func ParseGetOpenApiSchemaResponse(rsp *http.Response) (*GetOpenApiSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenApiSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Components *struct {
				Parameters *map[string]interface{} `json:"parameters,omitempty"`
				Responses  *map[string]interface{} `json:"responses,omitempty"`
				Schemas    *map[string]interface{} `json:"schemas,omitempty"`
			} `json:"components,omitempty"`
			Info *struct {
				Contact *struct {
					Email *string `json:"email,omitempty"`
				} `json:"contact,omitempty"`
				Description *string `json:"description,omitempty"`
				License     *struct {
					Name *string `json:"name,omitempty"`
					Url  *string `json:"url,omitempty"`
				} `json:"license,omitempty"`
				TermsOfService *string `json:"termsOfService,omitempty"`
				Title          *string `json:"title,omitempty"`
			} `json:"info,omitempty"`
			Openapi *string                 `json:"openapi,omitempty"`
			Paths   *map[string]interface{} `json:"paths,omitempty"`
			Servers *[]struct {
				Description *string `json:"description,omitempty"`
				Url         *string `json:"url,omitempty"`
			} `json:"servers,omitempty"`
			Tags *map[string]interface{} `json:"tags,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteManyOpportunitiesResponse parses an HTTP response from a DeleteManyOpportunitiesWithResponse call
func ParseDeleteManyOpportunitiesResponse(rsp *http.Response) (*DeleteManyOpportunitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyOpportunitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteOpportunities *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteOpportunities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyOpportunitiesResponse parses an HTTP response from a FindManyOpportunitiesWithResponse call
func ParseFindManyOpportunitiesResponse(rsp *http.Response) (*FindManyOpportunitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyOpportunitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Opportunities *[]OpportunityForResponse `json:"opportunities,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyOpportunitiesResponse parses an HTTP response from a UpdateManyOpportunitiesWithResponse call
func ParseUpdateManyOpportunitiesResponse(rsp *http.Response) (*UpdateManyOpportunitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyOpportunitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateOpportunities *[]OpportunityForResponse `json:"updateOpportunities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneOpportunityResponse parses an HTTP response from a CreateOneOpportunityWithResponse call
func ParseCreateOneOpportunityResponse(rsp *http.Response) (*CreateOneOpportunityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneOpportunityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateOpportunity An opportunity
				CreateOpportunity *OpportunityForResponse `json:"createOpportunity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOpportunityDuplicatesResponse parses an HTTP response from a FindOpportunityDuplicatesWithResponse call
func ParseFindOpportunityDuplicatesResponse(rsp *http.Response) (*FindOpportunityDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOpportunityDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				OpportunityDuplicates *[]OpportunityForResponse `json:"opportunityDuplicates,omitempty"`
				PageInfo              *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount *float32 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyOpportunitiesResponse parses an HTTP response from a MergeManyOpportunitiesWithResponse call
func ParseMergeManyOpportunitiesResponse(rsp *http.Response) (*MergeManyOpportunitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyOpportunitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeOpportunities An opportunity
				MergeOpportunities *OpportunityForResponse `json:"mergeOpportunities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneOpportunityResponse parses an HTTP response from a DeleteOneOpportunityWithResponse call
func ParseDeleteOneOpportunityResponse(rsp *http.Response) (*DeleteOneOpportunityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneOpportunityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteOpportunity *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteOpportunity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneOpportunityResponse parses an HTTP response from a FindOneOpportunityWithResponse call
func ParseFindOneOpportunityResponse(rsp *http.Response) (*FindOneOpportunityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneOpportunityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Opportunity An opportunity
				Opportunity *OpportunityForResponse `json:"opportunity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneOpportunityResponse parses an HTTP response from a UpdateOneOpportunityWithResponse call
func ParseUpdateOneOpportunityResponse(rsp *http.Response) (*UpdateOneOpportunityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneOpportunityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateOpportunity An opportunity
				UpdateOpportunity *OpportunityForResponse `json:"updateOpportunity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyPeopleResponse parses an HTTP response from a DeleteManyPeopleWithResponse call
func ParseDeleteManyPeopleResponse(rsp *http.Response) (*DeleteManyPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeletePeople *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deletePeople,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyPeopleResponse parses an HTTP response from a FindManyPeopleWithResponse call
func ParseFindManyPeopleResponse(rsp *http.Response) (*FindManyPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				People *[]PersonForResponse `json:"people,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyPeopleResponse parses an HTTP response from a UpdateManyPeopleWithResponse call
func ParseUpdateManyPeopleResponse(rsp *http.Response) (*UpdateManyPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdatePeople *[]PersonForResponse `json:"updatePeople,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOnePersonResponse parses an HTTP response from a CreateOnePersonWithResponse call
func ParseCreateOnePersonResponse(rsp *http.Response) (*CreateOnePersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOnePersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreatePerson A person
				CreatePerson *PersonForResponse `json:"createPerson,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindPersonDuplicatesResponse parses an HTTP response from a FindPersonDuplicatesWithResponse call
func ParseFindPersonDuplicatesResponse(rsp *http.Response) (*FindPersonDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPersonDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				PersonDuplicates *[]PersonForResponse `json:"personDuplicates,omitempty"`
				TotalCount       *float32             `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyPeopleResponse parses an HTTP response from a MergeManyPeopleWithResponse call
func ParseMergeManyPeopleResponse(rsp *http.Response) (*MergeManyPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergePeople A person
				MergePeople *PersonForResponse `json:"mergePeople,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOnePersonResponse parses an HTTP response from a DeleteOnePersonWithResponse call
func ParseDeleteOnePersonResponse(rsp *http.Response) (*DeleteOnePersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOnePersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeletePerson *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deletePerson,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOnePersonResponse parses an HTTP response from a FindOnePersonWithResponse call
func ParseFindOnePersonResponse(rsp *http.Response) (*FindOnePersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOnePersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Person A person
				Person *PersonForResponse `json:"person,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOnePersonResponse parses an HTTP response from a UpdateOnePersonWithResponse call
func ParseUpdateOnePersonResponse(rsp *http.Response) (*UpdateOnePersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOnePersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdatePerson A person
				UpdatePerson *PersonForResponse `json:"updatePerson,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyAttachmentsResponse parses an HTTP response from a RestoreManyAttachmentsWithResponse call
func ParseRestoreManyAttachmentsResponse(rsp *http.Response) (*RestoreManyAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreAttachments *[]AttachmentForResponse `json:"restoreAttachments,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneAttachmentResponse parses an HTTP response from a RestoreOneAttachmentWithResponse call
func ParseRestoreOneAttachmentResponse(rsp *http.Response) (*RestoreOneAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreAttachment An attachment
				RestoreAttachment *AttachmentForResponse `json:"restoreAttachment,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyBlocklistsResponse parses an HTTP response from a RestoreManyBlocklistsWithResponse call
func ParseRestoreManyBlocklistsResponse(rsp *http.Response) (*RestoreManyBlocklistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyBlocklistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreBlocklists *[]BlocklistForResponse `json:"restoreBlocklists,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneBlocklistResponse parses an HTTP response from a RestoreOneBlocklistWithResponse call
func ParseRestoreOneBlocklistResponse(rsp *http.Response) (*RestoreOneBlocklistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneBlocklistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreBlocklist Blocklist
				RestoreBlocklist *BlocklistForResponse `json:"restoreBlocklist,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyCalendarChannelEventAssociationsResponse parses an HTTP response from a RestoreManyCalendarChannelEventAssociationsWithResponse call
func ParseRestoreManyCalendarChannelEventAssociationsResponse(rsp *http.Response) (*RestoreManyCalendarChannelEventAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyCalendarChannelEventAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreCalendarChannelEventAssociations *[]CalendarChannelEventAssociationForResponse `json:"restoreCalendarChannelEventAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneCalendarChannelEventAssociationResponse parses an HTTP response from a RestoreOneCalendarChannelEventAssociationWithResponse call
func ParseRestoreOneCalendarChannelEventAssociationResponse(rsp *http.Response) (*RestoreOneCalendarChannelEventAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneCalendarChannelEventAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreCalendarChannelEventAssociation Calendar Channel Event Associations
				RestoreCalendarChannelEventAssociation *CalendarChannelEventAssociationForResponse `json:"restoreCalendarChannelEventAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyCalendarChannelsResponse parses an HTTP response from a RestoreManyCalendarChannelsWithResponse call
func ParseRestoreManyCalendarChannelsResponse(rsp *http.Response) (*RestoreManyCalendarChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyCalendarChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreCalendarChannels *[]CalendarChannelForResponse `json:"restoreCalendarChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneCalendarChannelResponse parses an HTTP response from a RestoreOneCalendarChannelWithResponse call
func ParseRestoreOneCalendarChannelResponse(rsp *http.Response) (*RestoreOneCalendarChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneCalendarChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreCalendarChannel Calendar Channels
				RestoreCalendarChannel *CalendarChannelForResponse `json:"restoreCalendarChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyCalendarEventParticipantsResponse parses an HTTP response from a RestoreManyCalendarEventParticipantsWithResponse call
func ParseRestoreManyCalendarEventParticipantsResponse(rsp *http.Response) (*RestoreManyCalendarEventParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyCalendarEventParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreCalendarEventParticipants *[]CalendarEventParticipantForResponse `json:"restoreCalendarEventParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneCalendarEventParticipantResponse parses an HTTP response from a RestoreOneCalendarEventParticipantWithResponse call
func ParseRestoreOneCalendarEventParticipantResponse(rsp *http.Response) (*RestoreOneCalendarEventParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneCalendarEventParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreCalendarEventParticipant Calendar event participants
				RestoreCalendarEventParticipant *CalendarEventParticipantForResponse `json:"restoreCalendarEventParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyCalendarEventsResponse parses an HTTP response from a RestoreManyCalendarEventsWithResponse call
func ParseRestoreManyCalendarEventsResponse(rsp *http.Response) (*RestoreManyCalendarEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyCalendarEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreCalendarEvents *[]CalendarEventForResponse `json:"restoreCalendarEvents,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneCalendarEventResponse parses an HTTP response from a RestoreOneCalendarEventWithResponse call
func ParseRestoreOneCalendarEventResponse(rsp *http.Response) (*RestoreOneCalendarEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneCalendarEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreCalendarEvent Calendar events
				RestoreCalendarEvent *CalendarEventForResponse `json:"restoreCalendarEvent,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyCompaniesResponse parses an HTTP response from a RestoreManyCompaniesWithResponse call
func ParseRestoreManyCompaniesResponse(rsp *http.Response) (*RestoreManyCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreCompanies *[]CompanyForResponse `json:"restoreCompanies,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneCompanyResponse parses an HTTP response from a RestoreOneCompanyWithResponse call
func ParseRestoreOneCompanyResponse(rsp *http.Response) (*RestoreOneCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreCompany A company
				RestoreCompany *CompanyForResponse `json:"restoreCompany,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyConnectedAccountsResponse parses an HTTP response from a RestoreManyConnectedAccountsWithResponse call
func ParseRestoreManyConnectedAccountsResponse(rsp *http.Response) (*RestoreManyConnectedAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyConnectedAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreConnectedAccounts *[]ConnectedAccountForResponse `json:"restoreConnectedAccounts,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneConnectedAccountResponse parses an HTTP response from a RestoreOneConnectedAccountWithResponse call
func ParseRestoreOneConnectedAccountResponse(rsp *http.Response) (*RestoreOneConnectedAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneConnectedAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreConnectedAccount A connected account
				RestoreConnectedAccount *ConnectedAccountForResponse `json:"restoreConnectedAccount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyDashboardsResponse parses an HTTP response from a RestoreManyDashboardsWithResponse call
func ParseRestoreManyDashboardsResponse(rsp *http.Response) (*RestoreManyDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreDashboards *[]DashboardForResponse `json:"restoreDashboards,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneDashboardResponse parses an HTTP response from a RestoreOneDashboardWithResponse call
func ParseRestoreOneDashboardResponse(rsp *http.Response) (*RestoreOneDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreDashboard A dashboard
				RestoreDashboard *DashboardForResponse `json:"restoreDashboard,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyFavoriteFoldersResponse parses an HTTP response from a RestoreManyFavoriteFoldersWithResponse call
func ParseRestoreManyFavoriteFoldersResponse(rsp *http.Response) (*RestoreManyFavoriteFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyFavoriteFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreFavoriteFolders *[]FavoriteFolderForResponse `json:"restoreFavoriteFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneFavoriteFolderResponse parses an HTTP response from a RestoreOneFavoriteFolderWithResponse call
func ParseRestoreOneFavoriteFolderResponse(rsp *http.Response) (*RestoreOneFavoriteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneFavoriteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreFavoriteFolder A Folder of favorites
				RestoreFavoriteFolder *FavoriteFolderForResponse `json:"restoreFavoriteFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyFavoritesResponse parses an HTTP response from a RestoreManyFavoritesWithResponse call
func ParseRestoreManyFavoritesResponse(rsp *http.Response) (*RestoreManyFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreFavorites *[]FavoriteForResponse `json:"restoreFavorites,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneFavoriteResponse parses an HTTP response from a RestoreOneFavoriteWithResponse call
func ParseRestoreOneFavoriteResponse(rsp *http.Response) (*RestoreOneFavoriteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneFavoriteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreFavorite A favorite that can be accessed from the left menu
				RestoreFavorite *FavoriteForResponse `json:"restoreFavorite,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyMessageChannelMessageAssociationsResponse parses an HTTP response from a RestoreManyMessageChannelMessageAssociationsWithResponse call
func ParseRestoreManyMessageChannelMessageAssociationsResponse(rsp *http.Response) (*RestoreManyMessageChannelMessageAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyMessageChannelMessageAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreMessageChannelMessageAssociations *[]MessageChannelMessageAssociationForResponse `json:"restoreMessageChannelMessageAssociations,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneMessageChannelMessageAssociationResponse parses an HTTP response from a RestoreOneMessageChannelMessageAssociationWithResponse call
func ParseRestoreOneMessageChannelMessageAssociationResponse(rsp *http.Response) (*RestoreOneMessageChannelMessageAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneMessageChannelMessageAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreMessageChannelMessageAssociation Message Synced with a Message Channel
				RestoreMessageChannelMessageAssociation *MessageChannelMessageAssociationForResponse `json:"restoreMessageChannelMessageAssociation,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyMessageChannelsResponse parses an HTTP response from a RestoreManyMessageChannelsWithResponse call
func ParseRestoreManyMessageChannelsResponse(rsp *http.Response) (*RestoreManyMessageChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyMessageChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreMessageChannels *[]MessageChannelForResponse `json:"restoreMessageChannels,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneMessageChannelResponse parses an HTTP response from a RestoreOneMessageChannelWithResponse call
func ParseRestoreOneMessageChannelResponse(rsp *http.Response) (*RestoreOneMessageChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneMessageChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreMessageChannel Message Channels
				RestoreMessageChannel *MessageChannelForResponse `json:"restoreMessageChannel,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyMessageFoldersResponse parses an HTTP response from a RestoreManyMessageFoldersWithResponse call
func ParseRestoreManyMessageFoldersResponse(rsp *http.Response) (*RestoreManyMessageFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyMessageFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreMessageFolders *[]MessageFolderForResponse `json:"restoreMessageFolders,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneMessageFolderResponse parses an HTTP response from a RestoreOneMessageFolderWithResponse call
func ParseRestoreOneMessageFolderResponse(rsp *http.Response) (*RestoreOneMessageFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneMessageFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreMessageFolder Folder for Message Channel
				RestoreMessageFolder *MessageFolderForResponse `json:"restoreMessageFolder,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyMessageParticipantsResponse parses an HTTP response from a RestoreManyMessageParticipantsWithResponse call
func ParseRestoreManyMessageParticipantsResponse(rsp *http.Response) (*RestoreManyMessageParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyMessageParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreMessageParticipants *[]MessageParticipantForResponse `json:"restoreMessageParticipants,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneMessageParticipantResponse parses an HTTP response from a RestoreOneMessageParticipantWithResponse call
func ParseRestoreOneMessageParticipantResponse(rsp *http.Response) (*RestoreOneMessageParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneMessageParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreMessageParticipant Message Participants
				RestoreMessageParticipant *MessageParticipantForResponse `json:"restoreMessageParticipant,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyMessageThreadsResponse parses an HTTP response from a RestoreManyMessageThreadsWithResponse call
func ParseRestoreManyMessageThreadsResponse(rsp *http.Response) (*RestoreManyMessageThreadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyMessageThreadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreMessageThreads *[]MessageThreadForResponse `json:"restoreMessageThreads,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneMessageThreadResponse parses an HTTP response from a RestoreOneMessageThreadWithResponse call
func ParseRestoreOneMessageThreadResponse(rsp *http.Response) (*RestoreOneMessageThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneMessageThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreMessageThread A group of related messages (e.g. email thread, chat thread)
				RestoreMessageThread *MessageThreadForResponse `json:"restoreMessageThread,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyMessagesResponse parses an HTTP response from a RestoreManyMessagesWithResponse call
func ParseRestoreManyMessagesResponse(rsp *http.Response) (*RestoreManyMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreMessages *[]MessageForResponse `json:"restoreMessages,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneMessageResponse parses an HTTP response from a RestoreOneMessageWithResponse call
func ParseRestoreOneMessageResponse(rsp *http.Response) (*RestoreOneMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreMessage A message sent or received through a messaging channel (email, chat, etc.)
				RestoreMessage *MessageForResponse `json:"restoreMessage,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyNoteTargetsResponse parses an HTTP response from a RestoreManyNoteTargetsWithResponse call
func ParseRestoreManyNoteTargetsResponse(rsp *http.Response) (*RestoreManyNoteTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyNoteTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreNoteTargets *[]NoteTargetForResponse `json:"restoreNoteTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneNoteTargetResponse parses an HTTP response from a RestoreOneNoteTargetWithResponse call
func ParseRestoreOneNoteTargetResponse(rsp *http.Response) (*RestoreOneNoteTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneNoteTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreNoteTarget A note target
				RestoreNoteTarget *NoteTargetForResponse `json:"restoreNoteTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyNotesResponse parses an HTTP response from a RestoreManyNotesWithResponse call
func ParseRestoreManyNotesResponse(rsp *http.Response) (*RestoreManyNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreNotes *[]NoteForResponse `json:"restoreNotes,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneNoteResponse parses an HTTP response from a RestoreOneNoteWithResponse call
func ParseRestoreOneNoteResponse(rsp *http.Response) (*RestoreOneNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreNote A note
				RestoreNote *NoteForResponse `json:"restoreNote,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyOpportunitiesResponse parses an HTTP response from a RestoreManyOpportunitiesWithResponse call
func ParseRestoreManyOpportunitiesResponse(rsp *http.Response) (*RestoreManyOpportunitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyOpportunitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreOpportunities *[]OpportunityForResponse `json:"restoreOpportunities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneOpportunityResponse parses an HTTP response from a RestoreOneOpportunityWithResponse call
func ParseRestoreOneOpportunityResponse(rsp *http.Response) (*RestoreOneOpportunityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneOpportunityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreOpportunity An opportunity
				RestoreOpportunity *OpportunityForResponse `json:"restoreOpportunity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyPeopleResponse parses an HTTP response from a RestoreManyPeopleWithResponse call
func ParseRestoreManyPeopleResponse(rsp *http.Response) (*RestoreManyPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestorePeople *[]PersonForResponse `json:"restorePeople,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOnePersonResponse parses an HTTP response from a RestoreOnePersonWithResponse call
func ParseRestoreOnePersonResponse(rsp *http.Response) (*RestoreOnePersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOnePersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestorePerson A person
				RestorePerson *PersonForResponse `json:"restorePerson,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyTaskTargetsResponse parses an HTTP response from a RestoreManyTaskTargetsWithResponse call
func ParseRestoreManyTaskTargetsResponse(rsp *http.Response) (*RestoreManyTaskTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyTaskTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreTaskTargets *[]TaskTargetForResponse `json:"restoreTaskTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneTaskTargetResponse parses an HTTP response from a RestoreOneTaskTargetWithResponse call
func ParseRestoreOneTaskTargetResponse(rsp *http.Response) (*RestoreOneTaskTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneTaskTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreTaskTarget A task target
				RestoreTaskTarget *TaskTargetForResponse `json:"restoreTaskTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyTasksResponse parses an HTTP response from a RestoreManyTasksWithResponse call
func ParseRestoreManyTasksResponse(rsp *http.Response) (*RestoreManyTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreTasks *[]TaskForResponse `json:"restoreTasks,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneTaskResponse parses an HTTP response from a RestoreOneTaskWithResponse call
func ParseRestoreOneTaskResponse(rsp *http.Response) (*RestoreOneTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreTask A task
				RestoreTask *TaskForResponse `json:"restoreTask,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyTimelineActivitiesResponse parses an HTTP response from a RestoreManyTimelineActivitiesWithResponse call
func ParseRestoreManyTimelineActivitiesResponse(rsp *http.Response) (*RestoreManyTimelineActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyTimelineActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreTimelineActivities *[]TimelineActivityForResponse `json:"restoreTimelineActivities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneTimelineActivityResponse parses an HTTP response from a RestoreOneTimelineActivityWithResponse call
func ParseRestoreOneTimelineActivityResponse(rsp *http.Response) (*RestoreOneTimelineActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneTimelineActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreTimelineActivity Aggregated / filtered event to be displayed on the timeline
				RestoreTimelineActivity *TimelineActivityForResponse `json:"restoreTimelineActivity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyWorkflowAutomatedTriggersResponse parses an HTTP response from a RestoreManyWorkflowAutomatedTriggersWithResponse call
func ParseRestoreManyWorkflowAutomatedTriggersResponse(rsp *http.Response) (*RestoreManyWorkflowAutomatedTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyWorkflowAutomatedTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreWorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"restoreWorkflowAutomatedTriggers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneWorkflowAutomatedTriggerResponse parses an HTTP response from a RestoreOneWorkflowAutomatedTriggerWithResponse call
func ParseRestoreOneWorkflowAutomatedTriggerResponse(rsp *http.Response) (*RestoreOneWorkflowAutomatedTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneWorkflowAutomatedTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreWorkflowAutomatedTrigger A workflow automated trigger
				RestoreWorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"restoreWorkflowAutomatedTrigger,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyWorkflowRunsResponse parses an HTTP response from a RestoreManyWorkflowRunsWithResponse call
func ParseRestoreManyWorkflowRunsResponse(rsp *http.Response) (*RestoreManyWorkflowRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreWorkflowRuns *[]WorkflowRunForResponse `json:"restoreWorkflowRuns,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneWorkflowRunResponse parses an HTTP response from a RestoreOneWorkflowRunWithResponse call
func ParseRestoreOneWorkflowRunResponse(rsp *http.Response) (*RestoreOneWorkflowRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreWorkflowRun A workflow run
				RestoreWorkflowRun *WorkflowRunForResponse `json:"restoreWorkflowRun,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyWorkflowVersionsResponse parses an HTTP response from a RestoreManyWorkflowVersionsWithResponse call
func ParseRestoreManyWorkflowVersionsResponse(rsp *http.Response) (*RestoreManyWorkflowVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyWorkflowVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreWorkflowVersions *[]WorkflowVersionForResponse `json:"restoreWorkflowVersions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneWorkflowVersionResponse parses an HTTP response from a RestoreOneWorkflowVersionWithResponse call
func ParseRestoreOneWorkflowVersionResponse(rsp *http.Response) (*RestoreOneWorkflowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneWorkflowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreWorkflowVersion A workflow version
				RestoreWorkflowVersion *WorkflowVersionForResponse `json:"restoreWorkflowVersion,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyWorkflowsResponse parses an HTTP response from a RestoreManyWorkflowsWithResponse call
func ParseRestoreManyWorkflowsResponse(rsp *http.Response) (*RestoreManyWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreWorkflows *[]WorkflowForResponse `json:"restoreWorkflows,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneWorkflowResponse parses an HTTP response from a RestoreOneWorkflowWithResponse call
func ParseRestoreOneWorkflowResponse(rsp *http.Response) (*RestoreOneWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreWorkflow A workflow
				RestoreWorkflow *WorkflowForResponse `json:"restoreWorkflow,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreManyWorkspaceMembersResponse parses an HTTP response from a RestoreManyWorkspaceMembersWithResponse call
func ParseRestoreManyWorkspaceMembersResponse(rsp *http.Response) (*RestoreManyWorkspaceMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreManyWorkspaceMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				RestoreWorkspaceMembers *[]WorkspaceMemberForResponse `json:"restoreWorkspaceMembers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRestoreOneWorkspaceMemberResponse parses an HTTP response from a RestoreOneWorkspaceMemberWithResponse call
func ParseRestoreOneWorkspaceMemberResponse(rsp *http.Response) (*RestoreOneWorkspaceMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreOneWorkspaceMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// RestoreWorkspaceMember A workspace member
				RestoreWorkspaceMember *WorkspaceMemberForResponse `json:"restoreWorkspaceMember,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyTaskTargetsResponse parses an HTTP response from a DeleteManyTaskTargetsWithResponse call
func ParseDeleteManyTaskTargetsResponse(rsp *http.Response) (*DeleteManyTaskTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyTaskTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteTaskTargets *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteTaskTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyTaskTargetsResponse parses an HTTP response from a FindManyTaskTargetsWithResponse call
func ParseFindManyTaskTargetsResponse(rsp *http.Response) (*FindManyTaskTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyTaskTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				TaskTargets *[]TaskTargetForResponse `json:"taskTargets,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyTaskTargetsResponse parses an HTTP response from a UpdateManyTaskTargetsWithResponse call
func ParseUpdateManyTaskTargetsResponse(rsp *http.Response) (*UpdateManyTaskTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyTaskTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateTaskTargets *[]TaskTargetForResponse `json:"updateTaskTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneTaskTargetResponse parses an HTTP response from a CreateOneTaskTargetWithResponse call
func ParseCreateOneTaskTargetResponse(rsp *http.Response) (*CreateOneTaskTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneTaskTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateTaskTarget A task target
				CreateTaskTarget *TaskTargetForResponse `json:"createTaskTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindTaskTargetDuplicatesResponse parses an HTTP response from a FindTaskTargetDuplicatesWithResponse call
func ParseFindTaskTargetDuplicatesResponse(rsp *http.Response) (*FindTaskTargetDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindTaskTargetDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TaskTargetDuplicates *[]TaskTargetForResponse `json:"taskTargetDuplicates,omitempty"`
				TotalCount           *float32                 `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyTaskTargetsResponse parses an HTTP response from a MergeManyTaskTargetsWithResponse call
func ParseMergeManyTaskTargetsResponse(rsp *http.Response) (*MergeManyTaskTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyTaskTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeTaskTargets A task target
				MergeTaskTargets *TaskTargetForResponse `json:"mergeTaskTargets,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneTaskTargetResponse parses an HTTP response from a DeleteOneTaskTargetWithResponse call
func ParseDeleteOneTaskTargetResponse(rsp *http.Response) (*DeleteOneTaskTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneTaskTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteTaskTarget *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteTaskTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneTaskTargetResponse parses an HTTP response from a FindOneTaskTargetWithResponse call
func ParseFindOneTaskTargetResponse(rsp *http.Response) (*FindOneTaskTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneTaskTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// TaskTarget A task target
				TaskTarget *TaskTargetForResponse `json:"taskTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneTaskTargetResponse parses an HTTP response from a UpdateOneTaskTargetWithResponse call
func ParseUpdateOneTaskTargetResponse(rsp *http.Response) (*UpdateOneTaskTargetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneTaskTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateTaskTarget A task target
				UpdateTaskTarget *TaskTargetForResponse `json:"updateTaskTarget,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyTasksResponse parses an HTTP response from a DeleteManyTasksWithResponse call
func ParseDeleteManyTasksResponse(rsp *http.Response) (*DeleteManyTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteTasks *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteTasks,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyTasksResponse parses an HTTP response from a FindManyTasksWithResponse call
func ParseFindManyTasksResponse(rsp *http.Response) (*FindManyTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Tasks *[]TaskForResponse `json:"tasks,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyTasksResponse parses an HTTP response from a UpdateManyTasksWithResponse call
func ParseUpdateManyTasksResponse(rsp *http.Response) (*UpdateManyTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateTasks *[]TaskForResponse `json:"updateTasks,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneTaskResponse parses an HTTP response from a CreateOneTaskWithResponse call
func ParseCreateOneTaskResponse(rsp *http.Response) (*CreateOneTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateTask A task
				CreateTask *TaskForResponse `json:"createTask,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindTaskDuplicatesResponse parses an HTTP response from a FindTaskDuplicatesWithResponse call
func ParseFindTaskDuplicatesResponse(rsp *http.Response) (*FindTaskDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindTaskDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TaskDuplicates *[]TaskForResponse `json:"taskDuplicates,omitempty"`
				TotalCount     *float32           `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyTasksResponse parses an HTTP response from a MergeManyTasksWithResponse call
func ParseMergeManyTasksResponse(rsp *http.Response) (*MergeManyTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeTasks A task
				MergeTasks *TaskForResponse `json:"mergeTasks,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneTaskResponse parses an HTTP response from a DeleteOneTaskWithResponse call
func ParseDeleteOneTaskResponse(rsp *http.Response) (*DeleteOneTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteTask *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteTask,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneTaskResponse parses an HTTP response from a FindOneTaskWithResponse call
func ParseFindOneTaskResponse(rsp *http.Response) (*FindOneTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Task A task
				Task *TaskForResponse `json:"task,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneTaskResponse parses an HTTP response from a UpdateOneTaskWithResponse call
func ParseUpdateOneTaskResponse(rsp *http.Response) (*UpdateOneTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateTask A task
				UpdateTask *TaskForResponse `json:"updateTask,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyTimelineActivitiesResponse parses an HTTP response from a DeleteManyTimelineActivitiesWithResponse call
func ParseDeleteManyTimelineActivitiesResponse(rsp *http.Response) (*DeleteManyTimelineActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyTimelineActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteTimelineActivities *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteTimelineActivities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyTimelineActivitiesResponse parses an HTTP response from a FindManyTimelineActivitiesWithResponse call
func ParseFindManyTimelineActivitiesResponse(rsp *http.Response) (*FindManyTimelineActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyTimelineActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				TimelineActivities *[]TimelineActivityForResponse `json:"timelineActivities,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyTimelineActivitiesResponse parses an HTTP response from a UpdateManyTimelineActivitiesWithResponse call
func ParseUpdateManyTimelineActivitiesResponse(rsp *http.Response) (*UpdateManyTimelineActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyTimelineActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateTimelineActivities *[]TimelineActivityForResponse `json:"updateTimelineActivities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneTimelineActivityResponse parses an HTTP response from a CreateOneTimelineActivityWithResponse call
func ParseCreateOneTimelineActivityResponse(rsp *http.Response) (*CreateOneTimelineActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneTimelineActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateTimelineActivity Aggregated / filtered event to be displayed on the timeline
				CreateTimelineActivity *TimelineActivityForResponse `json:"createTimelineActivity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindTimelineActivityDuplicatesResponse parses an HTTP response from a FindTimelineActivityDuplicatesWithResponse call
func ParseFindTimelineActivityDuplicatesResponse(rsp *http.Response) (*FindTimelineActivityDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindTimelineActivityDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TimelineActivityDuplicates *[]TimelineActivityForResponse `json:"timelineActivityDuplicates,omitempty"`
				TotalCount                 *float32                       `json:"totalCount,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyTimelineActivitiesResponse parses an HTTP response from a MergeManyTimelineActivitiesWithResponse call
func ParseMergeManyTimelineActivitiesResponse(rsp *http.Response) (*MergeManyTimelineActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyTimelineActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeTimelineActivities Aggregated / filtered event to be displayed on the timeline
				MergeTimelineActivities *TimelineActivityForResponse `json:"mergeTimelineActivities,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneTimelineActivityResponse parses an HTTP response from a DeleteOneTimelineActivityWithResponse call
func ParseDeleteOneTimelineActivityResponse(rsp *http.Response) (*DeleteOneTimelineActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneTimelineActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteTimelineActivity *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteTimelineActivity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneTimelineActivityResponse parses an HTTP response from a FindOneTimelineActivityWithResponse call
func ParseFindOneTimelineActivityResponse(rsp *http.Response) (*FindOneTimelineActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneTimelineActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// TimelineActivity Aggregated / filtered event to be displayed on the timeline
				TimelineActivity *TimelineActivityForResponse `json:"timelineActivity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneTimelineActivityResponse parses an HTTP response from a UpdateOneTimelineActivityWithResponse call
func ParseUpdateOneTimelineActivityResponse(rsp *http.Response) (*UpdateOneTimelineActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneTimelineActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateTimelineActivity Aggregated / filtered event to be displayed on the timeline
				UpdateTimelineActivity *TimelineActivityForResponse `json:"updateTimelineActivity,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyWorkflowAutomatedTriggersResponse parses an HTTP response from a DeleteManyWorkflowAutomatedTriggersWithResponse call
func ParseDeleteManyWorkflowAutomatedTriggersResponse(rsp *http.Response) (*DeleteManyWorkflowAutomatedTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyWorkflowAutomatedTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflowAutomatedTriggers *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflowAutomatedTriggers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyWorkflowAutomatedTriggersResponse parses an HTTP response from a FindManyWorkflowAutomatedTriggersWithResponse call
func ParseFindManyWorkflowAutomatedTriggersResponse(rsp *http.Response) (*FindManyWorkflowAutomatedTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyWorkflowAutomatedTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				WorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"workflowAutomatedTriggers,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyWorkflowAutomatedTriggersResponse parses an HTTP response from a UpdateManyWorkflowAutomatedTriggersWithResponse call
func ParseUpdateManyWorkflowAutomatedTriggersResponse(rsp *http.Response) (*UpdateManyWorkflowAutomatedTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyWorkflowAutomatedTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateWorkflowAutomatedTriggers *[]WorkflowAutomatedTriggerForResponse `json:"updateWorkflowAutomatedTriggers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneWorkflowAutomatedTriggerResponse parses an HTTP response from a CreateOneWorkflowAutomatedTriggerWithResponse call
func ParseCreateOneWorkflowAutomatedTriggerResponse(rsp *http.Response) (*CreateOneWorkflowAutomatedTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneWorkflowAutomatedTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateWorkflowAutomatedTrigger A workflow automated trigger
				CreateWorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"createWorkflowAutomatedTrigger,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindWorkflowAutomatedTriggerDuplicatesResponse parses an HTTP response from a FindWorkflowAutomatedTriggerDuplicatesWithResponse call
func ParseFindWorkflowAutomatedTriggerDuplicatesResponse(rsp *http.Response) (*FindWorkflowAutomatedTriggerDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindWorkflowAutomatedTriggerDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount                         *float32                               `json:"totalCount,omitempty"`
				WorkflowAutomatedTriggerDuplicates *[]WorkflowAutomatedTriggerForResponse `json:"workflowAutomatedTriggerDuplicates,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyWorkflowAutomatedTriggersResponse parses an HTTP response from a MergeManyWorkflowAutomatedTriggersWithResponse call
func ParseMergeManyWorkflowAutomatedTriggersResponse(rsp *http.Response) (*MergeManyWorkflowAutomatedTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyWorkflowAutomatedTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeWorkflowAutomatedTriggers A workflow automated trigger
				MergeWorkflowAutomatedTriggers *WorkflowAutomatedTriggerForResponse `json:"mergeWorkflowAutomatedTriggers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneWorkflowAutomatedTriggerResponse parses an HTTP response from a DeleteOneWorkflowAutomatedTriggerWithResponse call
func ParseDeleteOneWorkflowAutomatedTriggerResponse(rsp *http.Response) (*DeleteOneWorkflowAutomatedTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneWorkflowAutomatedTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflowAutomatedTrigger *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflowAutomatedTrigger,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneWorkflowAutomatedTriggerResponse parses an HTTP response from a FindOneWorkflowAutomatedTriggerWithResponse call
func ParseFindOneWorkflowAutomatedTriggerResponse(rsp *http.Response) (*FindOneWorkflowAutomatedTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneWorkflowAutomatedTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// WorkflowAutomatedTrigger A workflow automated trigger
				WorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"workflowAutomatedTrigger,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneWorkflowAutomatedTriggerResponse parses an HTTP response from a UpdateOneWorkflowAutomatedTriggerWithResponse call
func ParseUpdateOneWorkflowAutomatedTriggerResponse(rsp *http.Response) (*UpdateOneWorkflowAutomatedTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneWorkflowAutomatedTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateWorkflowAutomatedTrigger A workflow automated trigger
				UpdateWorkflowAutomatedTrigger *WorkflowAutomatedTriggerForResponse `json:"updateWorkflowAutomatedTrigger,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyWorkflowRunsResponse parses an HTTP response from a DeleteManyWorkflowRunsWithResponse call
func ParseDeleteManyWorkflowRunsResponse(rsp *http.Response) (*DeleteManyWorkflowRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflowRuns *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflowRuns,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyWorkflowRunsResponse parses an HTTP response from a FindManyWorkflowRunsWithResponse call
func ParseFindManyWorkflowRunsResponse(rsp *http.Response) (*FindManyWorkflowRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				WorkflowRuns *[]WorkflowRunForResponse `json:"workflowRuns,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyWorkflowRunsResponse parses an HTTP response from a UpdateManyWorkflowRunsWithResponse call
func ParseUpdateManyWorkflowRunsResponse(rsp *http.Response) (*UpdateManyWorkflowRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateWorkflowRuns *[]WorkflowRunForResponse `json:"updateWorkflowRuns,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneWorkflowRunResponse parses an HTTP response from a CreateOneWorkflowRunWithResponse call
func ParseCreateOneWorkflowRunResponse(rsp *http.Response) (*CreateOneWorkflowRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateWorkflowRun A workflow run
				CreateWorkflowRun *WorkflowRunForResponse `json:"createWorkflowRun,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindWorkflowRunDuplicatesResponse parses an HTTP response from a FindWorkflowRunDuplicatesWithResponse call
func ParseFindWorkflowRunDuplicatesResponse(rsp *http.Response) (*FindWorkflowRunDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindWorkflowRunDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount            *float32                  `json:"totalCount,omitempty"`
				WorkflowRunDuplicates *[]WorkflowRunForResponse `json:"workflowRunDuplicates,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyWorkflowRunsResponse parses an HTTP response from a MergeManyWorkflowRunsWithResponse call
func ParseMergeManyWorkflowRunsResponse(rsp *http.Response) (*MergeManyWorkflowRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeWorkflowRuns A workflow run
				MergeWorkflowRuns *WorkflowRunForResponse `json:"mergeWorkflowRuns,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneWorkflowRunResponse parses an HTTP response from a DeleteOneWorkflowRunWithResponse call
func ParseDeleteOneWorkflowRunResponse(rsp *http.Response) (*DeleteOneWorkflowRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflowRun *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflowRun,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneWorkflowRunResponse parses an HTTP response from a FindOneWorkflowRunWithResponse call
func ParseFindOneWorkflowRunResponse(rsp *http.Response) (*FindOneWorkflowRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// WorkflowRun A workflow run
				WorkflowRun *WorkflowRunForResponse `json:"workflowRun,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneWorkflowRunResponse parses an HTTP response from a UpdateOneWorkflowRunWithResponse call
func ParseUpdateOneWorkflowRunResponse(rsp *http.Response) (*UpdateOneWorkflowRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateWorkflowRun A workflow run
				UpdateWorkflowRun *WorkflowRunForResponse `json:"updateWorkflowRun,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyWorkflowVersionsResponse parses an HTTP response from a DeleteManyWorkflowVersionsWithResponse call
func ParseDeleteManyWorkflowVersionsResponse(rsp *http.Response) (*DeleteManyWorkflowVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyWorkflowVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflowVersions *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflowVersions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyWorkflowVersionsResponse parses an HTTP response from a FindManyWorkflowVersionsWithResponse call
func ParseFindManyWorkflowVersionsResponse(rsp *http.Response) (*FindManyWorkflowVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyWorkflowVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				WorkflowVersions *[]WorkflowVersionForResponse `json:"workflowVersions,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyWorkflowVersionsResponse parses an HTTP response from a UpdateManyWorkflowVersionsWithResponse call
func ParseUpdateManyWorkflowVersionsResponse(rsp *http.Response) (*UpdateManyWorkflowVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyWorkflowVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateWorkflowVersions *[]WorkflowVersionForResponse `json:"updateWorkflowVersions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneWorkflowVersionResponse parses an HTTP response from a CreateOneWorkflowVersionWithResponse call
func ParseCreateOneWorkflowVersionResponse(rsp *http.Response) (*CreateOneWorkflowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneWorkflowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateWorkflowVersion A workflow version
				CreateWorkflowVersion *WorkflowVersionForResponse `json:"createWorkflowVersion,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindWorkflowVersionDuplicatesResponse parses an HTTP response from a FindWorkflowVersionDuplicatesWithResponse call
func ParseFindWorkflowVersionDuplicatesResponse(rsp *http.Response) (*FindWorkflowVersionDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindWorkflowVersionDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount                *float32                      `json:"totalCount,omitempty"`
				WorkflowVersionDuplicates *[]WorkflowVersionForResponse `json:"workflowVersionDuplicates,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyWorkflowVersionsResponse parses an HTTP response from a MergeManyWorkflowVersionsWithResponse call
func ParseMergeManyWorkflowVersionsResponse(rsp *http.Response) (*MergeManyWorkflowVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyWorkflowVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeWorkflowVersions A workflow version
				MergeWorkflowVersions *WorkflowVersionForResponse `json:"mergeWorkflowVersions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneWorkflowVersionResponse parses an HTTP response from a DeleteOneWorkflowVersionWithResponse call
func ParseDeleteOneWorkflowVersionResponse(rsp *http.Response) (*DeleteOneWorkflowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneWorkflowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflowVersion *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflowVersion,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneWorkflowVersionResponse parses an HTTP response from a FindOneWorkflowVersionWithResponse call
func ParseFindOneWorkflowVersionResponse(rsp *http.Response) (*FindOneWorkflowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneWorkflowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// WorkflowVersion A workflow version
				WorkflowVersion *WorkflowVersionForResponse `json:"workflowVersion,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneWorkflowVersionResponse parses an HTTP response from a UpdateOneWorkflowVersionWithResponse call
func ParseUpdateOneWorkflowVersionResponse(rsp *http.Response) (*UpdateOneWorkflowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneWorkflowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateWorkflowVersion A workflow version
				UpdateWorkflowVersion *WorkflowVersionForResponse `json:"updateWorkflowVersion,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyWorkflowsResponse parses an HTTP response from a DeleteManyWorkflowsWithResponse call
func ParseDeleteManyWorkflowsResponse(rsp *http.Response) (*DeleteManyWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflows *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflows,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyWorkflowsResponse parses an HTTP response from a FindManyWorkflowsWithResponse call
func ParseFindManyWorkflowsResponse(rsp *http.Response) (*FindManyWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Workflows *[]WorkflowForResponse `json:"workflows,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyWorkflowsResponse parses an HTTP response from a UpdateManyWorkflowsWithResponse call
func ParseUpdateManyWorkflowsResponse(rsp *http.Response) (*UpdateManyWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateWorkflows *[]WorkflowForResponse `json:"updateWorkflows,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneWorkflowResponse parses an HTTP response from a CreateOneWorkflowWithResponse call
func ParseCreateOneWorkflowResponse(rsp *http.Response) (*CreateOneWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateWorkflow A workflow
				CreateWorkflow *WorkflowForResponse `json:"createWorkflow,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindWorkflowDuplicatesResponse parses an HTTP response from a FindWorkflowDuplicatesWithResponse call
func ParseFindWorkflowDuplicatesResponse(rsp *http.Response) (*FindWorkflowDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindWorkflowDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount         *float32               `json:"totalCount,omitempty"`
				WorkflowDuplicates *[]WorkflowForResponse `json:"workflowDuplicates,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyWorkflowsResponse parses an HTTP response from a MergeManyWorkflowsWithResponse call
func ParseMergeManyWorkflowsResponse(rsp *http.Response) (*MergeManyWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeWorkflows A workflow
				MergeWorkflows *WorkflowForResponse `json:"mergeWorkflows,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneWorkflowResponse parses an HTTP response from a DeleteOneWorkflowWithResponse call
func ParseDeleteOneWorkflowResponse(rsp *http.Response) (*DeleteOneWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkflow *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkflow,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneWorkflowResponse parses an HTTP response from a FindOneWorkflowWithResponse call
func ParseFindOneWorkflowResponse(rsp *http.Response) (*FindOneWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Workflow A workflow
				Workflow *WorkflowForResponse `json:"workflow,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneWorkflowResponse parses an HTTP response from a UpdateOneWorkflowWithResponse call
func ParseUpdateOneWorkflowResponse(rsp *http.Response) (*UpdateOneWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateWorkflow A workflow
				UpdateWorkflow *WorkflowForResponse `json:"updateWorkflow,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteManyWorkspaceMembersResponse parses an HTTP response from a DeleteManyWorkspaceMembersWithResponse call
func ParseDeleteManyWorkspaceMembersResponse(rsp *http.Response) (*DeleteManyWorkspaceMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManyWorkspaceMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkspaceMembers *[]struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkspaceMembers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindManyWorkspaceMembersResponse parses an HTTP response from a FindManyWorkspaceMembersWithResponse call
func ParseFindManyWorkspaceMembersResponse(rsp *http.Response) (*FindManyWorkspaceMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManyWorkspaceMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				WorkspaceMembers *[]WorkspaceMemberForResponse `json:"workspaceMembers,omitempty"`
			} `json:"data,omitempty"`
			PageInfo *struct {
				EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
				HasNextPage *bool               `json:"hasNextPage,omitempty"`
				StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
			} `json:"pageInfo,omitempty"`
			TotalCount *int `json:"totalCount,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateManyWorkspaceMembersResponse parses an HTTP response from a UpdateManyWorkspaceMembersWithResponse call
func ParseUpdateManyWorkspaceMembersResponse(rsp *http.Response) (*UpdateManyWorkspaceMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManyWorkspaceMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				UpdateWorkspaceMembers *[]WorkspaceMemberForResponse `json:"updateWorkspaceMembers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOneWorkspaceMemberResponse parses an HTTP response from a CreateOneWorkspaceMemberWithResponse call
func ParseCreateOneWorkspaceMemberResponse(rsp *http.Response) (*CreateOneWorkspaceMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOneWorkspaceMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				// CreateWorkspaceMember A workspace member
				CreateWorkspaceMember *WorkspaceMemberForResponse `json:"createWorkspaceMember,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindWorkspaceMemberDuplicatesResponse parses an HTTP response from a FindWorkspaceMemberDuplicatesWithResponse call
func ParseFindWorkspaceMemberDuplicatesResponse(rsp *http.Response) (*FindWorkspaceMemberDuplicatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindWorkspaceMemberDuplicatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				PageInfo *struct {
					EndCursor   *openapi_types.UUID `json:"endCursor,omitempty"`
					HasNextPage *bool               `json:"hasNextPage,omitempty"`
					StartCursor *openapi_types.UUID `json:"startCursor,omitempty"`
				} `json:"pageInfo,omitempty"`
				TotalCount                *float32                      `json:"totalCount,omitempty"`
				WorkspaceMemberDuplicates *[]WorkspaceMemberForResponse `json:"workspaceMemberDuplicates,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMergeManyWorkspaceMembersResponse parses an HTTP response from a MergeManyWorkspaceMembersWithResponse call
func ParseMergeManyWorkspaceMembersResponse(rsp *http.Response) (*MergeManyWorkspaceMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeManyWorkspaceMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// MergeWorkspaceMembers A workspace member
				MergeWorkspaceMembers *WorkspaceMemberForResponse `json:"mergeWorkspaceMembers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteOneWorkspaceMemberResponse parses an HTTP response from a DeleteOneWorkspaceMemberWithResponse call
func ParseDeleteOneWorkspaceMemberResponse(rsp *http.Response) (*DeleteOneWorkspaceMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOneWorkspaceMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				DeleteWorkspaceMember *struct {
					Id *openapi_types.UUID `json:"id,omitempty"`
				} `json:"deleteWorkspaceMember,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOneWorkspaceMemberResponse parses an HTTP response from a FindOneWorkspaceMemberWithResponse call
func ParseFindOneWorkspaceMemberResponse(rsp *http.Response) (*FindOneWorkspaceMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOneWorkspaceMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// WorkspaceMember A workspace member
				WorkspaceMember *WorkspaceMemberForResponse `json:"workspaceMember,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateOneWorkspaceMemberResponse parses an HTTP response from a UpdateOneWorkspaceMemberWithResponse call
func ParseUpdateOneWorkspaceMemberResponse(rsp *http.Response) (*UpdateOneWorkspaceMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOneWorkspaceMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// UpdateWorkspaceMember A workspace member
				UpdateWorkspaceMember *WorkspaceMemberForResponse `json:"updateWorkspaceMember,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
